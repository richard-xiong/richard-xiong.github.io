<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Go-kit 学习笔记七-Go退出时向Consul反注册服务的基本方法、优雅关闭服务</title>
    <url>/2020/09/16/Go-kit%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%83-Go%E9%80%80%E5%87%BA%E6%97%B6%E5%90%91Consul%E5%8F%8D%E6%B3%A8%E5%86%8C%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95%E3%80%81%E4%BC%98%E9%9B%85%E5%85%B3%E9%97%AD%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<h3 id="Go退出时向Consul反注册服务的基本方法、优雅关闭服务"><a href="#Go退出时向Consul反注册服务的基本方法、优雅关闭服务" class="headerlink" title="Go退出时向Consul反注册服务的基本方法、优雅关闭服务"></a>Go退出时向Consul反注册服务的基本方法、优雅关闭服务</h3><h4 id="需求背景："><a href="#需求背景：" class="headerlink" title="需求背景："></a>需求背景：</h4><p>比如我们再<code>consul</code>注册服务之后，如果服务宕机之后，再次重启服务会注册不上服务，因为我们代码里设置在<code>consul</code>注册的服务id是唯一的，需要把<code>consul</code>上不可用的服务移除掉，提供的服务如果不可用需要在<code>consul</code>调用反注册</p>
<h4 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h4><ol>
<li><p>创建<code>consul</code>反注册的<code>func</code></p>
<ol>
<li><p>修改之前的注册<code>service</code>的<code>func</code> 将创建<code>client</code>抽取出来放在<code>init()</code>函数中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ConsulClient *consulapi.Client</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    config := consulapi.DefaultConfig()</span><br><span class="line">    <span class="comment">// 设置consul 地址</span></span><br><span class="line">    config.Address = <span class="string">&quot;192.168.236.2:8500&quot;</span></span><br><span class="line">    <span class="comment">// 创建一个client 把我们的服务注册到consul上</span></span><br><span class="line">    clinet, err := consulapi.NewClient(config)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 异常处理</span></span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    ConsulClient=clinet</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改注册<code>service</code>的<code>func</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegService</span><span class="params">()</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建AgentServiceRegistration 对象</span></span><br><span class="line">    reg := consulapi.AgentServiceRegistration&#123;&#125;</span><br><span class="line">    <span class="comment">// 设置注册的id  这个不能重复</span></span><br><span class="line">    reg.ID = <span class="string">&quot;userservice&quot;</span></span><br><span class="line">    <span class="comment">// 注册服务的name 可以重复</span></span><br><span class="line">    reg.Name = <span class="string">&quot;userservice&quot;</span></span><br><span class="line">    <span class="comment">// 注册服务的地址</span></span><br><span class="line">    reg.Address = <span class="string">&quot;192.168.236.2&quot;</span></span><br><span class="line">    <span class="comment">// 注册服务的端口</span></span><br><span class="line">    reg.Port = <span class="number">8080</span></span><br><span class="line">    <span class="comment">// 注册服务的tags 可以多个</span></span><br><span class="line">    reg.Tags = []<span class="keyword">string</span>&#123;<span class="string">&quot;primary&quot;</span>, <span class="string">&quot;v1&quot;</span>&#125;</span><br><span class="line">    <span class="comment">// 创建 AgentServiceCheck 来设置checkhealth</span></span><br><span class="line">    check := consulapi.AgentServiceCheck&#123;&#125;</span><br><span class="line">    <span class="comment">// 触发的时长 5s</span></span><br><span class="line">    check.Interval = <span class="string">&quot;1s&quot;</span></span><br><span class="line">    <span class="comment">// 健康检测的接口</span></span><br><span class="line">    check.HTTP = <span class="string">&quot;http://192.168.236.2:8080/health&quot;</span></span><br><span class="line">    <span class="comment">// 这里需要传递一个指针</span></span><br><span class="line">    reg.Check = &amp;check</span><br><span class="line">    err := ConsulClient.Agent().ServiceRegister(&amp;reg)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 异常处理</span></span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建再服务宕机时候触发consul反注册的func</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取消注册</span></span><br><span class="line"><span class="function"><span class="keyword">func</span>  <span class="title">UnRegService</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 反注册只需要传 注册的id</span></span><br><span class="line">    err :=ConsulClient.Agent().ServiceDeregister(<span class="string">&quot;userservice&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 异常处理</span></span><br><span class="line">        log.Fatal(err)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ol>
<ol start="2">
<li><p>修改<code>main</code>方法的实现 （借助 从<code>chan</code> 无缓冲通道 如果没有数据会一直阻塞）</p>
<ol>
<li><p>创建<code>error chan</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">errChan := <span class="built_in">make</span>(<span class="keyword">chan</span> error) <span class="comment">// 创建无缓冲通道</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>启动协程来运行 consul注册和服务启动</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        util.RegService() <span class="comment">// consul 注册服务</span></span><br><span class="line">        <span class="comment">// 因为serverHandler 已经实现了handler 接口 所以http.ListenAndServe 可以直接调用</span></span><br><span class="line">        err := http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, r)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            errChan &lt;- err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动协程来监控 服务<code>Ctrl+C</code> 和<code>kill -9 pid</code> 的系统信号</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    signal_c := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line">    signal.Notify(signal_c, syscall.SIGINT, syscall.SIGTERM)</span><br><span class="line">    errChan &lt;- fmt.Errorf(<span class="string">&quot;%s&quot;</span>, &lt;- signal_c)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
</li>
<li><p>优雅退出</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  从errChan 取值 如果没有会一直阻塞</span></span><br><span class="line">getErr := &lt;- errChan</span><br><span class="line">     util.UnRegService()</span><br><span class="line">log.Println(getErr)</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Go-kit 学习笔记 一</title>
    <url>/2020/08/29/Go-kit-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/</url>
    <content><![CDATA[<p>Go-kit 的三层架构</p>
<ol>
<li><p>transport</p>
<p>主要负责与http、gRPC、thrift等相关逻辑</p>
</li>
<li><p>endpoint</p>
<p>定义request与response格式、并可以使用装饰器包装函数，以此来实现各种中间件之间的嵌套</p>
</li>
<li><p>service</p>
<p>这里定义的就是业务类、接口等</p>
</li>
</ol>
<p>我实现的时候是倒着创建</p>
<p>​    </p>
<ol>
<li><p>第一步 创建接口 以及关联词</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> IUserService <span class="keyword">interface</span> &#123;</span><br><span class="line">    GetName(userId <span class="keyword">int</span>) <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UserService <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this UserService)</span><span class="title">GetName</span><span class="params">(userId <span class="keyword">int</span>)</span><span class="title">string</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> userId==<span class="number">101</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;richard&quot;</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;guest&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>第二步 创建EndPoint</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> UserRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">    Uid <span class="keyword">int</span> <span class="string">`json:&quot;uid&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UserResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">    Result <span class="keyword">string</span> <span class="string">`json:&quot;result&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 首先定义 请求和响应的 <span class="keyword">struct</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>第三步 创建transport</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"># 当我们外部有请求过来的时候，我们需要对Request进行decode，</span><br><span class="line"># 注意：外部请求很有可能是rpc、http。参数形式也许是json也许是赤裸裸的url参数</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DecodeUserRequest</span><span class="params">(c context.Context,r *http.Request)</span><span class="params">(<span class="keyword">interface</span>&#123;&#125;,error)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在代码块里写</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个主要是判断参数是怎么来的,代码可以写成</span></span><br><span class="line">    <span class="keyword">if</span> r.URL.Query().Get(<span class="string">&quot;uid&quot;</span>) != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        uid, _ := strconv.Atoi(r.URL.Query().Get(<span class="string">&quot;uid&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> UserRequest&#123;Uid: uid&#125;, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>,errors.New(<span class="string">&quot;参数错误&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>对于响应：响应是我们发出的 我们需要encode，比较简单的就是json</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EncodeUserRequest</span><span class="params">(ctx context.Context,w http.ResponseWriter,response <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在func里添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 返回一个json</span><br><span class="line">w.Header().Set(&quot;Content-type&quot;,&quot;application&#x2F;json;charset&#x3D;utf-8&quot;)</span><br><span class="line">return json.NewEncoder(w).Encode(response)</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Go-kit 学习笔记-三</title>
    <url>/2020/08/30/Go-kit-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89/</url>
    <content><![CDATA[<p><img src="/images/Go-kit-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89/image-20200901224625446.png" alt="image-20200901224625446"></p>
<h3 id="介绍一个第三方路由"><a href="#介绍一个第三方路由" class="headerlink" title="介绍一个第三方路由"></a>介绍一个第三方路由</h3><p>使用第三方库<a href="https://github.com/gorilla/mux">mux</a>  来设置路由</p>
<p>安装方式</p>
<p>go get github.com/gotilla/mux</p>
<ol>
<li><p>创建路由</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r := mux.NewRouter()</span><br></pre></td></tr></table></figure>
</li>
<li><p>简单的使用 、这种是不指定<code>http method</code></p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := mux.NewRouter()</span><br><span class="line">    r.HandleFunc(<span class="string">&quot;/&quot;</span>, HomeHandler)</span><br><span class="line">    r.HandleFunc(<span class="string">&quot;/products&quot;</span>, ProductsHandler)</span><br><span class="line">    r.HandleFunc(<span class="string">&quot;/articles&quot;</span>, ArticlesHandler)</span><br><span class="line">    http.Handle(<span class="string">&quot;/&quot;</span>, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>路由规则支持正则</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r := mux.NewRouter()</span><br><span class="line">r.HandleFunc(<span class="string">&quot;/products/&#123;key&#125;&quot;</span>, ProductHandler)</span><br><span class="line">r.HandleFunc(<span class="string">&quot;/articles/&#123;category&#125;/&quot;</span>, ArticlesCategoryHandler)</span><br><span class="line">r.HandleFunc(<span class="string">&quot;/articles/&#123;category&#125;/&#123;id:[0-9]+&#125;&quot;</span>, ArticleHandler)</span><br></pre></td></tr></table></figure>



<ol start="4">
<li>指定<code>http method</code>  post请求 /specific</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r.Methods(<span class="string">&quot;POST&quot;</span>)</span><br><span class="line">r.HandleFunc(<span class="string">&quot;/specific&quot;</span>, specificHandler)</span><br><span class="line"># 也可以</span><br><span class="line">r.r.PathPrefix(<span class="string">&quot;/products&quot;</span>).Handler(catchAllHandler)</span><br></pre></td></tr></table></figure>



]]></content>
  </entry>
  <entry>
    <title>Go-kit 学习笔记-九-服务发现②</title>
    <url>/2020/09/16/Go-kit-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B9%9D-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E2%91%A1/</url>
    <content><![CDATA[<h3 id="通过服务中心取分几步"><a href="#通过服务中心取分几步" class="headerlink" title="通过服务中心取分几步"></a>通过服务中心取分几步</h3><ol>
<li><p>第一步 ：使用前面的consul api 创建一个client，然后go-kit的sd包帮我们封装好了一个专门的client</p>
<p>别忘了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> consulapi <span class="string">&quot;github.com/hashicorp/consul/api&quot;</span></span><br><span class="line">config := consulapi.DefaultConfig()</span><br><span class="line">    <span class="comment">// 设置consul 地址</span></span><br><span class="line">    config.Address = <span class="string">&quot;192.168.236.2:8500&quot;</span></span><br><span class="line">    <span class="comment">// 创建一个client 把我们的服务注册到consul上</span></span><br><span class="line">    apiClient, err := consulapi.NewClient(config)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 异常处理</span></span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里需要</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/go-kit/kit/sd/consul&quot;</span></span><br><span class="line"></span><br><span class="line">client:=consul.NewClient(apiClient)</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二步： 创建一个instancer</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> logger klog.Logger</span><br><span class="line">&#123;</span><br><span class="line">  logger=klog.NewLogfmtLogger(os.Stdout)</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  tags:=[]<span class="keyword">string</span>&#123;<span class="string">&quot;primary&quot;</span>,<span class="string">&quot;v1&quot;</span>&#125;</span><br><span class="line">  <span class="comment">// 可实时查询服务实例的状态信息</span></span><br><span class="line">  instancer:=consul.NewInstancer(client,logger,<span class="string">&quot;userservice&quot;</span>,tags,<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>第三步：创建Endpointer</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f:= <span class="function"><span class="keyword">func</span><span class="params">(serviceUrl <span class="keyword">string</span>)</span> <span class="params">(endpoint.Endpoint, io.Closer, error)</span></span> &#123;</span><br><span class="line">                    target,_:=url.Parse(<span class="string">&quot;http://&quot;</span>+serviceUrl) <span class="comment">//192.168.1.1:8080 服务器的真实地址</span></span><br><span class="line">                    <span class="keyword">return</span> httpTransport.NewClient(<span class="string">&quot;GET&quot;</span>,target,GetUserInfoRequest,GetUserInfoResponse).Endpoint(),<span class="literal">nil</span>,<span class="literal">nil</span></span><br><span class="line">                &#125;</span><br><span class="line">                endpointer:=sd.NewEndpointer(instancer,f,logger)</span><br></pre></td></tr></table></figure>

<p>EndPointer可以用来获取所有的Endpoint</p>
</li>
<li><p>第四步：执行</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">endpoints,_:=endpointer.Endpoints()</span><br><span class="line">fmt.Println(<span class="string">&quot;服务有&quot;</span>,<span class="built_in">len</span>(endpoints),<span class="string">&quot;条&quot;</span>)</span><br><span class="line"></span><br><span class="line">getUserInfo := endpoints[<span class="number">0</span>]</span><br><span class="line">ctx := context.Background() <span class="comment">// 第三步：创建一个空的上下文对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第四步：执行</span></span><br><span class="line">res, err := getUserInfo(ctx, UserRequest&#123;Uid: <span class="number">101</span>&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将response进行类型断言</span></span><br><span class="line">userInfo := res.(UserResponse)</span><br><span class="line">fmt.Println(userInfo.Result)</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Go-kit 学习笔记-二</title>
    <url>/2020/09/01/Go-kit-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/</url>
    <content><![CDATA[<h4 id="将上节的服务进行发布-在main-go-中添加"><a href="#将上节的服务进行发布-在main-go-中添加" class="headerlink" title="将上节的服务进行发布 在main.go 中添加"></a>将上节的服务进行发布 在<code>main.go</code> 中添加</h4><ol>
<li><p>第一层 先获取service</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">user:=Services.UserService&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二层 创建endpoint</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">endP:&#x3D;Services.GenUserEndpoint(user)    </span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>第三步 使用<code>go-kit</code>创建<code>handler</code>  借助<code>newServer</code>函数 返回了一个<code>server struct</code> 内部实现了<code>func (s Server) ServeHTTP(w http.ResponseWriter, r *http.Request) </code>  如何对请求进行处理</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">serverHandler:=httpTransport.NewServer(endP,Services.DecodeUserRequest,Services.EncodeUserRequest)</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li><p>因为serverHandler 已经实现了handler 接口 所以http.ListenAndServe 可以直接调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_ &#x3D; http.ListenAndServe(&quot;:8080&quot;, serverHandler)</span><br></pre></td></tr></table></figure>
</li>
<li><p>由于 <code>httpTransport.NewServer</code> 是<code>go-kit</code>中<code>http</code>包的方法<code> http.ListenAndServe</code> 是原生<code>http</code>包 包名重复 需要对<code>go-kit</code>的http 起alias</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">httpTransport &quot;github.com&#x2F;go-kit&#x2F;kit&#x2F;transport&#x2F;http&quot;</span><br><span class="line">    &quot;net&#x2F;http&quot;</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Go-kit 学习笔记-二十-熔断器学习3超时情况下的服务降级写法</title>
    <url>/2020/09/23/Go-kit-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C%E5%8D%81-%E7%86%94%E6%96%AD%E5%99%A8%E5%AD%A6%E4%B9%A03%E8%B6%85%E6%97%B6%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7%E5%86%99%E6%B3%95/</url>
    <content><![CDATA[<h3 id="熔断器"><a href="#熔断器" class="headerlink" title="熔断器-"></a>熔断器-</h3><p>我们把需求确定下：</p>
<p>假设老板规定：一旦商品获取超时，择我们返回一个推荐商品（很大可能就是一个静态数据）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReProduct</span><span class="params">()</span> <span class="params">(Product, error)</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> Product&#123;Id: <span class="number">999</span>,</span><br><span class="line">      Title: <span class="string">&quot;Richard Go kit 推荐精品&quot;</span>,</span><br><span class="line">      Price: <span class="number">88</span>,</span><br><span class="line">   &#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line">    <span class="comment">//configA := hystrix.CommandConfig&#123;Timeout: 5000&#125;</span></span><br><span class="line">    <span class="comment">// 通过name 将configA配置到get_prod上</span></span><br><span class="line">    hystrix.ConfigureCommand(<span class="string">&quot;get_prod&quot;</span>, hystrix.CommandConfig&#123;</span><br><span class="line">        Timeout: <span class="number">2000</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        err := hystrix.Do(<span class="string">&quot;get_prod&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">            p, _ := getProduct()</span><br><span class="line">            fmt.Println(p)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;, <span class="function"><span class="keyword">func</span><span class="params">(err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">      <span class="comment">// 定义下超时的调用方法</span></span><br><span class="line">            fmt.Println(ReProduct())</span><br><span class="line">            <span class="keyword">return</span> errors.New(<span class="string">&quot;my time out&quot;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mfxing  go run hystrix_demo.go</span><br><span class="line">2</span><br><span class="line">&#123;999 Richard Go kit 推荐精品 88&#125; &lt;nil&gt;</span><br><span class="line">fallback failed with &#x27;my time out&#x27;. run error was &#x27;hystrix: timeout&#x27;</span><br><span class="line">4</span><br><span class="line">&#123;101 Richard Go kit 笔记 1&#125;</span><br><span class="line">&#123;999 Richard Go kit 推荐精品 88&#125; &lt;nil&gt;</span><br><span class="line">fallback failed with &#x27;my time out&#x27;. run error was &#x27;hystrix: timeout&#x27;</span><br><span class="line">9</span><br><span class="line">&#123;101 Richard Go kit 笔记 1&#125;</span><br><span class="line">3</span><br><span class="line">&#123;101 Richard Go kit 笔记 1&#125;</span><br><span class="line">^Csignal: interrupt</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Go-kit 学习笔记-二十一-异步执行和服务降级</title>
    <url>/2020/09/23/Go-kit-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C%E5%8D%81%E4%B8%80-%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7/</url>
    <content><![CDATA[<h3 id="异步执行和服务降级"><a href="#异步执行和服务降级" class="headerlink" title="异步执行和服务降级"></a>异步执行和服务降级</h3><p>异步执行主要是使用的hystrix.go方法 参数和.do()是一样的，唯一的区别是前者是异步返回的err chan 后者是同步的返回的是error struct</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/afex/hystrix-go/hystrix&quot;</span></span><br><span class="line">    <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Product <span class="keyword">struct</span> &#123;</span><br><span class="line">    Id    <span class="keyword">int</span></span><br><span class="line">    Title <span class="keyword">string</span></span><br><span class="line">    Price <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getProduct</span><span class="params">()</span> <span class="params">(Product, error)</span></span> &#123;</span><br><span class="line">    r := rand.Intn(<span class="number">10</span>)</span><br><span class="line">    fmt.Println(r)</span><br><span class="line">    <span class="keyword">if</span> r &lt; <span class="number">5</span> &#123;</span><br><span class="line">        time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Product&#123;</span><br><span class="line">        Id:    <span class="number">101</span>,</span><br><span class="line">        Title: <span class="string">&quot;Richard Go kit 笔记&quot;</span>,</span><br><span class="line">        Price: <span class="number">1</span>,</span><br><span class="line">    &#125;, <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReProduct</span><span class="params">()</span> <span class="params">(Product, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Product&#123;Id: <span class="number">999</span>,</span><br><span class="line">        Title: <span class="string">&quot;Richard Go kit 推荐精品&quot;</span>,</span><br><span class="line">        Price: <span class="number">88</span>,</span><br><span class="line">    &#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line">    <span class="comment">//configA := hystrix.CommandConfig&#123;Timeout: 5000&#125;</span></span><br><span class="line">    <span class="comment">// 通过name 将configA配置到get_prod上</span></span><br><span class="line">    hystrix.ConfigureCommand(<span class="string">&quot;get_prod&quot;</span>, hystrix.CommandConfig&#123;</span><br><span class="line">        Timeout: <span class="number">2000</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    resultChan :=<span class="built_in">make</span>(<span class="keyword">chan</span> Product,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        errs := hystrix.Go(<span class="string">&quot;get_prod&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">            p, _ := getProduct()</span><br><span class="line">            fmt.Println(p)</span><br><span class="line">            resultChan &lt;-p</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;, <span class="function"><span class="keyword">func</span><span class="params">(err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">            fmt.Println(ReProduct())</span><br><span class="line">            rcp,err:=ReProduct()</span><br><span class="line">            resultChan &lt;- rcp</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> getProd:=&lt;-resultChan:</span><br><span class="line">            fmt.Println(getProd)</span><br><span class="line">        <span class="keyword">case</span> err:=&lt;-errs:</span><br><span class="line">            fmt.Println(err)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="执行测试"><a href="#执行测试" class="headerlink" title="执行测试"></a>执行测试</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mfxing  go run hystrix_demo.go</span><br><span class="line">8</span><br><span class="line">&#123;101 Richard Go kit 笔记 1&#125;</span><br><span class="line">&#123;101 Richard Go kit 笔记 1&#125;</span><br><span class="line">5</span><br><span class="line">&#123;101 Richard Go kit 笔记 1&#125;</span><br><span class="line">&#123;101 Richard Go kit 笔记 1&#125;</span><br><span class="line">0</span><br><span class="line">&#123;999 Richard Go kit 推荐精品 88&#125; &lt;nil&gt;</span><br><span class="line">&#123;999 Richard Go kit 推荐精品 88&#125;</span><br><span class="line">6</span><br><span class="line">&#123;101 Richard Go kit 笔记 1&#125;</span><br><span class="line">&#123;101 Richard Go kit 笔记 1&#125;</span><br><span class="line">0</span><br><span class="line">&#123;101 Richard Go kit 笔记 1&#125;</span><br><span class="line">&#123;101 Richard Go kit 笔记 1&#125;</span><br><span class="line">0</span><br><span class="line">^Csignal: interrupt</span><br></pre></td></tr></table></figure>



<p>更改下代码查看下如果降级方法执行失败了呢</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">errs := hystrix.Go(&quot;get_prod&quot;, func() error &#123;</span><br><span class="line">            p, _ := getProduct()</span><br><span class="line">            fmt.Println(p)</span><br><span class="line">            resultChan &lt;-p</span><br><span class="line">            return nil</span><br><span class="line">        &#125;, func(err error) error &#123;</span><br><span class="line">            // go 执行的错误 也能在这里接收到</span><br><span class="line">            //fmt.Println(ReProduct())</span><br><span class="line">            //rcp,err:=ReProduct()</span><br><span class="line">            //resultChan &lt;- rcp</span><br><span class="line">            // todo 如果降级方法都失败了？查看下情况回是什么样</span><br><span class="line">            return errors.New(&quot;降级方法错误&quot;)</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<p>重新执行代码 差看一下结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mfxing  go run hystrix_demo.go</span><br><span class="line">1</span><br><span class="line">fallback failed with &#x27;降级方法错误&#x27;. run error was &#x27;hystrix: timeout&#x27;</span><br><span class="line">6</span><br><span class="line">&#123;101 Richard Go kit 笔记 1&#125;</span><br><span class="line">&#123;101 Richard Go kit 笔记 1&#125;</span><br><span class="line">4</span><br><span class="line">&#123;101 Richard Go kit 笔记 1&#125;</span><br><span class="line">&#123;101 Richard Go kit 笔记 1&#125;</span><br><span class="line">1</span><br><span class="line">^Csignal: interrupt</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Go-kit 学习笔记-二十三-熔断器的打开与参数设置</title>
    <url>/2020/09/24/Go-kit-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C%E5%8D%81%E4%B8%89-%E7%86%94%E6%96%AD%E5%99%A8%E7%9A%84%E6%89%93%E5%BC%80%E4%B8%8E%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h3 id="熔断器的打开与参数设置"><a href="#熔断器的打开与参数设置" class="headerlink" title="熔断器的打开与参数设置"></a>熔断器的打开与参数设置</h3><h4 id="设置熔断器的参数"><a href="#设置熔断器的参数" class="headerlink" title="设置熔断器的参数"></a>设置熔断器的参数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RequestVolumeThreshold:5,</span><br><span class="line"></span><br><span class="line">ErrorPercentThreshold:20,</span><br></pre></td></tr></table></figure>

<p><strong>RequestVolumeThreshold</strong>：默认是20，熔断器请求的阈值。意识是有20个请求才进行错误百分百计算</p>
<p><strong>ErrorPercentThreshold</strong>：就是百分比错误。默认是50（50%）</p>
<p>为了展示效果我们将代码改为同步调用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/afex/hystrix-go/hystrix&quot;</span></span><br><span class="line">    <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Product <span class="keyword">struct</span> &#123;</span><br><span class="line">    Id    <span class="keyword">int</span></span><br><span class="line">    Title <span class="keyword">string</span></span><br><span class="line">    Price <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getProduct</span><span class="params">()</span> <span class="params">(Product, error)</span></span> &#123;</span><br><span class="line">    r := rand.Intn(<span class="number">10</span>)</span><br><span class="line">    <span class="comment">//fmt.Println(r)</span></span><br><span class="line">    <span class="keyword">if</span> r &lt; <span class="number">5</span> &#123;</span><br><span class="line">        time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Product&#123;</span><br><span class="line">        Id:    <span class="number">101</span>,</span><br><span class="line">        Title: <span class="string">&quot;Richard Go kit 笔记&quot;</span>,</span><br><span class="line">        Price: <span class="number">1</span>,</span><br><span class="line">    &#125;, <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReProduct</span><span class="params">()</span> <span class="params">(Product, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Product&#123;Id: <span class="number">999</span>,</span><br><span class="line">        Title: <span class="string">&quot;推荐精品&quot;</span>,</span><br><span class="line">        Price: <span class="number">88</span>,</span><br><span class="line">    &#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line">    <span class="comment">//configA := hystrix.CommandConfig&#123;Timeout: 5000&#125;</span></span><br><span class="line">    <span class="comment">// 通过name 将configA配置到get_prod上</span></span><br><span class="line">    hystrix.ConfigureCommand(<span class="string">&quot;get_prod&quot;</span>, hystrix.CommandConfig&#123;</span><br><span class="line">        Timeout:                <span class="number">2000</span>,</span><br><span class="line">        MaxConcurrentRequests:  <span class="number">5</span>, <span class="comment">// 设置熔断器的最大并发数 如果超过就会降级</span></span><br><span class="line">        RequestVolumeThreshold: <span class="number">3</span>,</span><br><span class="line">        ErrorPercentThreshold:  <span class="number">20</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++&#123;</span><br><span class="line"></span><br><span class="line">        errs := hystrix.Do(<span class="string">&quot;get_prod&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">            p, _ := getProduct()</span><br><span class="line">            fmt.Println(p)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;, <span class="function"><span class="keyword">func</span><span class="params">(err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">            <span class="comment">// 打印降级错误的原因</span></span><br><span class="line">            <span class="comment">//fmt.Println(err)</span></span><br><span class="line">            <span class="comment">// go 执行的错误 也能在这里接收到</span></span><br><span class="line">            fmt.Println(ReProduct())</span><br><span class="line">            rcp, err := ReProduct()</span><br><span class="line">            fmt.Println(rcp)</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        fmt.Println(errs)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mfxing  go run hystrix_demo.go</span><br><span class="line">&#123;999 推荐精品 88&#125; &lt;nil&gt;</span><br><span class="line">&#123;999 推荐精品 88&#125;</span><br><span class="line">&lt;nil&gt;</span><br><span class="line">&#123;999 推荐精品 88&#125; &lt;nil&gt;</span><br><span class="line">&#123;999 推荐精品 88&#125;</span><br><span class="line">&lt;nil&gt;</span><br><span class="line">&#123;101 Richard Go kit 笔记 1&#125;</span><br><span class="line">&#123;999 推荐精品 88&#125; &lt;nil&gt;</span><br><span class="line">&#123;999 推荐精品 88&#125;</span><br><span class="line">&lt;nil&gt;</span><br><span class="line">&#123;999 推荐精品 88&#125; &lt;nil&gt;</span><br><span class="line">&#123;999 推荐精品 88&#125;</span><br><span class="line">&lt;nil&gt;</span><br><span class="line">&#123;999 推荐精品 88&#125; &lt;nil&gt;</span><br><span class="line">&#123;999 推荐精品 88&#125;</span><br><span class="line">&lt;nil&gt;</span><br><span class="line">&#123;999 推荐精品 88&#125; &lt;nil&gt;</span><br><span class="line">&#123;999 推荐精品 88&#125;</span><br><span class="line">&lt;nil&gt;</span><br><span class="line">&#123;999 推荐精品 88&#125; &lt;nil&gt;</span><br><span class="line">&#123;999 推荐精品 88&#125;</span><br><span class="line">&lt;nil&gt;</span><br><span class="line">&#123;999 推荐精品 88&#125; &lt;nil&gt;</span><br><span class="line">&#123;999 推荐精品 88&#125;</span><br><span class="line">&lt;nil&gt;</span><br><span class="line">&#123;999 推荐精品 88&#125; &lt;nil&gt;</span><br><span class="line">&#123;999 推荐精品 88&#125;</span><br><span class="line">&lt;nil&gt;</span><br><span class="line">&#123;999 推荐精品 88&#125; &lt;nil&gt;</span><br><span class="line">&#123;999 推荐精品 88&#125;</span><br><span class="line">&lt;nil&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们可以看出 前几次打印的比较慢 后几次打印的比较快，直接走的是降级方法</p>
]]></content>
  </entry>
  <entry>
    <title>Go-kit 学习笔记-二十二-熔断器学习5控制最大并发数</title>
    <url>/2020/09/24/Go-kit-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C%E5%8D%81%E4%BA%8C-%E7%86%94%E6%96%AD%E5%99%A8%E5%AD%A6%E4%B9%A05%E6%8E%A7%E5%88%B6%E6%9C%80%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%95%B0/</url>
    <content><![CDATA[<p>用户前端如果不断的请求我们api，除了我们使用限流功能我们也可以加入最大并发数，前面做的练习是对整个进行一个限流，那如果单个我们可以使用hystrix.go进行控制</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/afex/hystrix-go/hystrix&quot;</span></span><br><span class="line">    <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Product <span class="keyword">struct</span> &#123;</span><br><span class="line">    Id    <span class="keyword">int</span></span><br><span class="line">    Title <span class="keyword">string</span></span><br><span class="line">    Price <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getProduct</span><span class="params">()</span> <span class="params">(Product, error)</span></span> &#123;</span><br><span class="line">    r := rand.Intn(<span class="number">10</span>)</span><br><span class="line">    <span class="comment">//fmt.Println(r)</span></span><br><span class="line">    <span class="keyword">if</span> r &lt; <span class="number">5</span> &#123;</span><br><span class="line">        <span class="comment">//time.Sleep(time.Second * 3)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Product&#123;</span><br><span class="line">        Id:    <span class="number">101</span>,</span><br><span class="line">        Title: <span class="string">&quot;Richard Go kit 笔记&quot;</span>,</span><br><span class="line">        Price: <span class="number">1</span>,</span><br><span class="line">    &#125;, <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReProduct</span><span class="params">()</span> <span class="params">(Product, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Product&#123;Id: <span class="number">999</span>,</span><br><span class="line">        Title: <span class="string">&quot;Richard Go kit 推荐精品&quot;</span>,</span><br><span class="line">        Price: <span class="number">88</span>,</span><br><span class="line">    &#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line">    <span class="comment">//configA := hystrix.CommandConfig&#123;Timeout: 5000&#125;</span></span><br><span class="line">    <span class="comment">// 通过name 将configA配置到get_prod上</span></span><br><span class="line">    hystrix.ConfigureCommand(<span class="string">&quot;get_prod&quot;</span>, hystrix.CommandConfig&#123;</span><br><span class="line">        Timeout:               <span class="number">2000</span>,</span><br><span class="line">        MaxConcurrentRequests: <span class="number">5</span>, <span class="comment">// 设置熔断器的最大并发数 如果超过就会降级</span></span><br><span class="line">    &#125;)</span><br><span class="line">    resultChan := <span class="built_in">make</span>(<span class="keyword">chan</span> Product, <span class="number">1</span>)</span><br><span class="line">    wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            wg.Add(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            errs := hystrix.Go(<span class="string">&quot;get_prod&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">                p, _ := getProduct()</span><br><span class="line">                resultChan &lt;- p</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            &#125;, <span class="function"><span class="keyword">func</span><span class="params">(err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">                <span class="comment">// 打印降级错误的原因</span></span><br><span class="line">                fmt.Println(err)</span><br><span class="line">                <span class="comment">// go 执行的错误 也能在这里接收到</span></span><br><span class="line">                <span class="comment">//fmt.Println(ReProduct())</span></span><br><span class="line">                rcp, err := ReProduct()</span><br><span class="line">                resultChan &lt;- rcp</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> getProd := &lt;-resultChan:</span><br><span class="line">                fmt.Println(getProd)</span><br><span class="line">            <span class="keyword">case</span> err := &lt;-errs:</span><br><span class="line">                fmt.Println(err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="测试-执行代码"><a href="#测试-执行代码" class="headerlink" title="测试 执行代码"></a>测试 执行代码</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mfxing  go run hystrix_demo.go</span><br><span class="line">&#123;101 Richard Go kit 笔记 1&#125;</span><br><span class="line">&#123;101 Richard Go kit 笔记 1&#125;</span><br><span class="line">&#123;101 Richard Go kit 笔记 1&#125;</span><br><span class="line">&#123;101 Richard Go kit 笔记 1&#125;</span><br><span class="line">hystrix: max concurrency</span><br><span class="line">hystrix: max concurrency</span><br><span class="line">&#123;101 Richard Go kit 笔记 1&#125;</span><br><span class="line">&#123;999 Richard Go kit 推荐精品 88&#125;</span><br><span class="line">&#123;101 Richard Go kit 笔记 1&#125;</span><br><span class="line">&#123;101 Richard Go kit 笔记 1&#125;</span><br><span class="line">&#123;999 Richard Go kit 推荐精品 88&#125;</span><br><span class="line">&#123;101 Richard Go kit 笔记 1&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Go-kit 学习笔记-二十五-熔断器整合到我们的客户端代码中初步</title>
    <url>/2020/09/25/Go-kit-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C%E5%8D%81%E4%BA%94-%E7%86%94%E6%96%AD%E5%99%A8%E6%95%B4%E5%90%88%E5%88%B0%E6%88%91%E4%BB%AC%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%A3%E7%A0%81%E4%B8%AD%E5%88%9D%E6%AD%A5/</url>
    <content><![CDATA[<h3 id="熔断器整合到我们的客户端代码中初步"><a href="#熔断器整合到我们的客户端代码中初步" class="headerlink" title="熔断器整合到我们的客户端代码中初步"></a>熔断器整合到我们的客户端代码中初步</h3><p>熔断器的设计其实是放在客户端的如果有网关 apigateway 则可以放在网关中</p>
<img src="/images/Go-kit-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C%E5%8D%81%E4%BA%94-%E7%86%94%E6%96%AD%E5%99%A8%E6%95%B4%E5%90%88%E5%88%B0%E6%88%91%E4%BB%AC%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%A3%E7%A0%81%E4%B8%AD%E5%88%9D%E6%AD%A5/image-20200924163333779.png" alt="image-20200924163333779" style="zoom:50%;" />



<p>为了测试我们先把之前客户端的调用封装成一个getUser()的方法，返回结果和err</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> util</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    . <span class="string">&quot;Go-kit-studt-client/services&quot;</span></span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/go-kit/kit/endpoint&quot;</span></span><br><span class="line">    klog <span class="string">&quot;github.com/go-kit/kit/log&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/go-kit/kit/sd&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/go-kit/kit/sd/consul&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/go-kit/kit/sd/lb&quot;</span></span><br><span class="line">    httpTransport <span class="string">&quot;github.com/go-kit/kit/transport/http&quot;</span></span><br><span class="line">    consulapi <span class="string">&quot;github.com/hashicorp/consul/api&quot;</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;net/url&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetUser</span><span class="params">()</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 为了代码可读性和清晰性 我们使用代码块的方式</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 第一步：创建client</span></span><br><span class="line">        config := consulapi.DefaultConfig()</span><br><span class="line">        <span class="comment">// 设置consul 地址</span></span><br><span class="line">        config.Address = <span class="string">&quot;192.168.236.2:8500&quot;</span></span><br><span class="line">        <span class="comment">// 创建一个client 把我们的服务注册到consul上</span></span><br><span class="line">        apiClient, err := consulapi.NewClient(config)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        client := consul.NewClient(apiClient)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> logger klog.Logger</span><br><span class="line">        &#123;</span><br><span class="line">            logger = klog.NewLogfmtLogger(os.Stdout)</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            tags := []<span class="keyword">string</span>&#123;<span class="string">&quot;primary&quot;</span>, <span class="string">&quot;v1&quot;</span>&#125;</span><br><span class="line">            <span class="comment">// 可实时查询服务实例的状态信息</span></span><br><span class="line">            instancer := consul.NewInstancer(client, logger, <span class="string">&quot;userservice&quot;</span>, tags, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line">                f := <span class="function"><span class="keyword">func</span><span class="params">(serviceUrl <span class="keyword">string</span>)</span> <span class="params">(endpoint.Endpoint, io.Closer, error)</span></span> &#123;</span><br><span class="line">                    target, _ := url.Parse(<span class="string">&quot;http://&quot;</span> + serviceUrl) <span class="comment">//192.168.1.1:8080 服务器的真实地址</span></span><br><span class="line">                    <span class="keyword">return</span> httpTransport.NewClient(<span class="string">&quot;GET&quot;</span>, target, GetUserInfoRequest, GetUserInfoResponse).Endpoint(), <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">                &#125;</span><br><span class="line">                endpointer := sd.NewEndpointer(instancer, f, logger)</span><br><span class="line">                endpoints, err := endpointer.Endpoints()</span><br><span class="line">                <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">                &#125;</span><br><span class="line">                fmt.Println(<span class="string">&quot;服务有&quot;</span>, <span class="built_in">len</span>(endpoints), <span class="string">&quot;条&quot;</span>)</span><br><span class="line">                <span class="comment">// mylb := lb.NewRoundRobin(endpointer) // 轮询调用</span></span><br><span class="line">                mylb := lb.NewRandom(endpointer, time.Now().UnixNano())</span><br><span class="line">                <span class="keyword">for</span> &#123;</span><br><span class="line">                    <span class="comment">// getUserInfo:=endpoints[0] 写死获取第一个</span></span><br><span class="line">                    getUserInfo, err := mylb.Endpoint() <span class="comment">// 如果一个都没有的情况下 第二个参数为nil</span></span><br><span class="line">                    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">                    &#125;</span><br><span class="line">                    ctx := context.Background() <span class="comment">// 第三步：创建一个空的上下文对象</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 第四步：执行</span></span><br><span class="line">                    res, err := getUserInfo(ctx, UserRequest&#123;Uid: <span class="number">101</span>&#125;)</span><br><span class="line">                    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 将response进行类型断言</span></span><br><span class="line">                    userInfo := res.(UserResponse)</span><br><span class="line">                    fmt.Println(userInfo.Result)</span><br><span class="line">                    time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">                    <span class="keyword">return</span> userInfo.Result, <span class="literal">nil</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
  </entry>
  <entry>
    <title>Go-kit 学习笔记-二十四-熔断器的三种状态、状态获取</title>
    <url>/2020/09/24/Go-kit-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C%E5%8D%81%E5%9B%9B-%E7%86%94%E6%96%AD%E5%99%A8%E7%9A%84%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81%E3%80%81%E7%8A%B6%E6%80%81%E8%8E%B7%E5%8F%96/</url>
    <content><![CDATA[<h3 id="熔断器的三种状态、状态获取"><a href="#熔断器的三种状态、状态获取" class="headerlink" title="熔断器的三种状态、状态获取"></a>熔断器的三种状态、状态获取</h3><p>熔断器有三种状态：</p>
<p>关闭：默认状态。如果请求次数异常超过设定比例，则打开熔断器</p>
<p>打开：当熔断器打开的时候。直接执行降级方法</p>
<p>半开: 定期的尝试发起请求来确认系统是否恢复了，如果恢复了，熔断器将转为关闭状态或者保持打开。</p>
<p>这三个状态的设置是通过ConfigureCommand种的sleepWIndow来设置的，默认是5s，他的含义是每隔5s会再重试一下 判断服务是否已经恢复，如果恢复就将状态关闭。</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/afex/hystrix-go/hystrix&quot;</span></span><br><span class="line">    <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Product <span class="keyword">struct</span> &#123;</span><br><span class="line">    Id    <span class="keyword">int</span></span><br><span class="line">    Title <span class="keyword">string</span></span><br><span class="line">    Price <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getProduct</span><span class="params">()</span> <span class="params">(Product, error)</span></span> &#123;</span><br><span class="line">    r := rand.Intn(<span class="number">10</span>)</span><br><span class="line">    <span class="comment">//fmt.Println(r)</span></span><br><span class="line">    <span class="keyword">if</span> r &lt; <span class="number">5</span> &#123;</span><br><span class="line">        time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Product&#123;</span><br><span class="line">        Id:    <span class="number">101</span>,</span><br><span class="line">        Title: <span class="string">&quot;Richard Go kit 笔记&quot;</span>,</span><br><span class="line">        Price: <span class="number">1</span>,</span><br><span class="line">    &#125;, <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReProduct</span><span class="params">()</span> <span class="params">(Product, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Product&#123;Id: <span class="number">999</span>,</span><br><span class="line">        Title: <span class="string">&quot;推荐精品&quot;</span>,</span><br><span class="line">        Price: <span class="number">88</span>,</span><br><span class="line">    &#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line">    <span class="comment">//configA := hystrix.CommandConfig&#123;Timeout: 5000&#125;</span></span><br><span class="line">    <span class="comment">// 通过name 将configA配置到get_prod上</span></span><br><span class="line">    hystrix.ConfigureCommand(<span class="string">&quot;get_prod&quot;</span>, hystrix.CommandConfig&#123;</span><br><span class="line">        Timeout:                <span class="number">2000</span>,</span><br><span class="line">        MaxConcurrentRequests:  <span class="number">5</span>, <span class="comment">// 设置熔断器的最大并发数 如果超过就会降级</span></span><br><span class="line">        RequestVolumeThreshold: <span class="number">3</span>,</span><br><span class="line">        ErrorPercentThreshold:  <span class="number">20</span>,</span><br><span class="line">        SleepWindow:            <span class="keyword">int</span>(time.Second * <span class="number">5</span>), <span class="comment">// 状态重试时间改为100s 方便测试</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        c,_,_:=hystrix.GetCircuit(<span class="string">&quot;get_prod&quot;</span>) <span class="comment">// 第一个参数是熔断器实例 ，第二个标识是否取到，第三个是err</span></span><br><span class="line">        errs := hystrix.Do(<span class="string">&quot;get_prod&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">            p, _ := getProduct()</span><br><span class="line">            fmt.Println(p)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;, <span class="function"><span class="keyword">func</span><span class="params">(err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">            <span class="comment">// 打印降级错误的原因</span></span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                fmt.Println(err)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// go 执行的错误 也能在这里接收到</span></span><br><span class="line">            fmt.Println(ReProduct())</span><br><span class="line">            rcp, err := ReProduct()</span><br><span class="line">            fmt.Println(rcp)</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> errs != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(errs)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打印熔断器状态</span></span><br><span class="line">        fmt.Println(c.IsOpen())</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mfxing  go run hystrix_demo.go </span><br><span class="line">hystrix: timeout</span><br><span class="line">&#123;999 推荐精品 88&#125; &lt;nil&gt;</span><br><span class="line">&#123;999 推荐精品 88&#125;</span><br><span class="line">false</span><br><span class="line">&#123;101 Richard Go kit 笔记 1&#125;</span><br><span class="line">hystrix: timeout</span><br><span class="line">&#123;999 推荐精品 88&#125; &lt;nil&gt;</span><br><span class="line">&#123;999 推荐精品 88&#125;</span><br><span class="line">false</span><br><span class="line">&#123;101 Richard Go kit 笔记 1&#125;</span><br><span class="line">false</span><br><span class="line">hystrix: circuit open</span><br><span class="line">&#123;999 推荐精品 88&#125; &lt;nil&gt;</span><br><span class="line">&#123;999 推荐精品 88&#125;</span><br><span class="line">true</span><br><span class="line">&#123;101 Richard Go kit 笔记 1&#125;</span><br><span class="line">hystrix: circuit open</span><br><span class="line">&#123;999 推荐精品 88&#125; &lt;nil&gt;</span><br><span class="line">&#123;999 推荐精品 88&#125;</span><br><span class="line">true</span><br><span class="line">hystrix: circuit open</span><br><span class="line">&#123;999 推荐精品 88&#125; &lt;nil&gt;</span><br><span class="line">&#123;999 推荐精品 88&#125;</span><br><span class="line">true</span><br><span class="line">hystrix: circuit open</span><br><span class="line">&#123;999 推荐精品 88&#125; &lt;nil&gt;</span><br><span class="line">&#123;999 推荐精品 88&#125;</span><br><span class="line">true</span><br><span class="line">hystrix: circuit open</span><br><span class="line">&#123;999 推荐精品 88&#125; &lt;nil&gt;</span><br><span class="line">&#123;999 推荐精品 88&#125;</span><br><span class="line">true</span><br><span class="line">^Csignal: interrupt</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 执行发现 一旦熔断器打开之后 打印就回快速很多了。</p>
]]></content>
  </entry>
  <entry>
    <title>Go-kit 学习笔记-八-服务发现</title>
    <url>/2020/09/16/Go-kit-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%AB-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/</url>
    <content><![CDATA[<h3 id="服务发现-01-客户端直接调用服务（直连方式）"><a href="#服务发现-01-客户端直接调用服务（直连方式）" class="headerlink" title="服务发现-01-客户端直接调用服务（直连方式）"></a>服务发现-01-客户端直接调用服务（直连方式）</h3><img src="/images/Go-kit-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%AB-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/image-20200915200828441.png" alt="image-20200915200828441" style="zoom: 33%;" />

<h3 id="创建一个新的项目-Go-kit-study-client"><a href="#创建一个新的项目-Go-kit-study-client" class="headerlink" title="创建一个新的项目 Go-kit-study-client"></a>创建一个新的项目 Go-kit-study-client</h3><ol>
<li><p>我们看到之前server 有service transport handler ，通过使用httpTransport.NewServer 来生成一个handler ，肯定也有生成client的方法,如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">httpTransport.NewClient(method,target,enc,dec) </span><br></pre></td></tr></table></figure>

<ol>
<li><p>method 请求方式</p>
</li>
<li><p>target 请求url，譬如 localhost:8080 (注意不带path)</p>
</li>
<li><p>enc </p>
<p>type EncodeRequestFunc func(context.Context,*http.Request,interface{}) error </p>
<p>请求的encode</p>
</li>
<li><p>dec</p>
</li>
</ol>
</li>
<li><p>创建<code>endpoint </code>和server定义的struct保持一致 因为需要encode 和decode </p>
<p><code>UserEndpoint.go</code> 内容如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Services</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UserRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">    Uid    <span class="keyword">int</span> <span class="string">`json:&quot;uid&quot;`</span></span><br><span class="line">    Method <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UserResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">    Result <span class="keyword">string</span> <span class="string">`json:&quot;result&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建UserTransport，因为server 对 request的endpoint进行decode，对response进行encode ，所以client 需要对request的endponit进行encode，对response进行decode</p>
<p>UserTransport.go的内容如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// context 暂时用不到</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetUserInfoRequest</span><span class="params">(_ context.Context,request *http.Request,r <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span>&#123;</span><br><span class="line">    userRequest:=r.(UserRequest)</span><br><span class="line">    request.URL.Path=<span class="string">&quot;/user/&quot;</span>+strconv.Itoa(userRequest.Uid)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetUserInfoResponse</span><span class="params">(_ context.Context, res *http.Response)</span> <span class="params">(response <span class="keyword">interface</span>&#123;&#125;, err error)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先对status code 进行判断</span></span><br><span class="line">    <span class="keyword">if</span> res.StatusCode!=<span class="number">200</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>,errors.New(<span class="string">&quot;no data&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> userResponse UserResponse</span><br><span class="line">    <span class="comment">// 对response进行 decode，将结果赋值给userResponse</span></span><br><span class="line">    err = json.NewDecoder(res.Body).Decode(&amp;userResponse)</span><br><span class="line">    <span class="keyword">if</span> err !=<span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>,err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> userResponse,<span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造go-kit的client</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    . <span class="string">&quot;Go-kit-studt-client/services&quot;</span></span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    httpTransport <span class="string">&quot;github.com/go-kit/kit/transport/http&quot;</span></span><br><span class="line">    <span class="string">&quot;net/url&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 指定服务器地址</span></span><br><span class="line">    target, _ := url.Parse(<span class="string">&quot;http://localhost:8080&quot;</span>)</span><br><span class="line">    <span class="comment">// 第一步： 创建直连的client ，这里我们必须写两个func 一个是如何请求 一个是响应我们怎么处理</span></span><br><span class="line">    client := httpTransport.NewClient(<span class="string">&quot;GET&quot;</span>, target, GetUserInfoRequest, GetUserInfoResponse)</span><br><span class="line">    <span class="comment">// 第二步： 暴露出endpoint（这货就是一个func） 以便执行</span></span><br><span class="line">    getUserInfo := client.Endpoint()</span><br><span class="line">    ctx := context.Background() <span class="comment">// 第三步：创建一个空的上下文对象</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 第四步：执行 </span></span><br><span class="line">    res, err := getUserInfo(ctx, UserRequest&#123;Uid: <span class="number">101</span>&#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将response进行类型断言</span></span><br><span class="line">    userInfo := res.(UserResponse)</span><br><span class="line">    fmt.Println(userInfo.Result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>运行main函数 执行结果如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GOROOT=/usr/local/go #gosetup</span><br><span class="line">GOPATH=/Users/mengfanxing_g/godev #gosetup</span><br><span class="line">/usr/local/go/bin/go build -o /private/var/folders/wz/y802yvq96ldfmsf9xkv_9jp00000gn/T/___go_build_Go_kit_studt_client Go-kit-studt-client #gosetup</span><br><span class="line">/private/var/folders/wz/y802yvq96ldfmsf9xkv_9jp00000gn/T/___go_build_Go_kit_studt_client #gosetup</span><br><span class="line">richard</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Go-kit 学习笔记-十-服务发现③</title>
    <url>/2020/09/16/Go-kit-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%81-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E2%91%A2/</url>
    <content><![CDATA[<h3 id="根据命令行参数注册多个服务"><a href="#根据命令行参数注册多个服务" class="headerlink" title="根据命令行参数注册多个服务"></a>根据命令行参数注册多个服务</h3><p>前提：想我们在本地模拟多个服务注册到consul</p>
<h4 id="获取参数flag包"><a href="#获取参数flag包" class="headerlink" title="获取参数flag包"></a>获取参数flag包</h4><ol>
<li><p>使用 </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">name:=flag.String(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;服务名称&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这样就可以使用 go run xxx.go  -name=xxoo</p>
</li>
<li><p>参数形式 (以下都可以)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-id=1</span><br><span class="line"></span><br><span class="line">--id=1</span><br><span class="line"></span><br><span class="line">-id 1</span><br><span class="line"></span><br><span class="line">--id 1</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="代码改造"><a href="#代码改造" class="headerlink" title="代码改造"></a>代码改造</h3><ol>
<li><p>创建一个接收服务名称和端口的实体</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ServiceModel <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Port <span class="keyword">int</span></span><br><span class="line">    Id   <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在main.go中接收 -name -port</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">    name := flag.String(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;服务名称&quot;</span>)</span><br><span class="line">    port := flag.Int(<span class="string">&quot;port&quot;</span>, <span class="number">0</span>, <span class="string">&quot;服务名称&quot;</span>)</span><br><span class="line">    flag.Parse()</span><br><span class="line">    <span class="keyword">if</span> *name == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;请指定服务名&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> *port == <span class="number">0</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;请指定端口 &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保存服务的名称和端口号</span></span><br><span class="line">    util.ServiceData.Name = *name</span><br><span class="line">    util.ServiceData.Port = *port</span><br><span class="line">...</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        util.RegService() <span class="comment">// consul 注册服务</span></span><br><span class="line">        <span class="comment">// 因为serverHandler 已经实现了handler 接口 所以http.ListenAndServe 可以直接调用</span></span><br><span class="line">        err := http.ListenAndServe(<span class="string">&quot;:&quot;</span>+strconv.Itoa(*port), r) <span class="comment">// 注意替换启动的端口</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            errChan &lt;- err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>修改consul的注册和反注册接口</p>
<ol>
<li><p>服务的id 使用uuid来生成</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  config := consulapi.DefaultConfig()</span><br><span class="line">  LocalIp = <span class="string">&quot;192.168.236.2&quot;</span></span><br><span class="line">  ConsulPort = <span class="string">&quot;8500&quot;</span></span><br><span class="line">  <span class="comment">// 设置consul 地址</span></span><br><span class="line">  config.Address = fmt.Sprintf(<span class="string">&quot;%s:%s&quot;</span>, LocalIp, ConsulPort)</span><br><span class="line">  <span class="comment">// 创建一个client 把我们的服务注册到consul上</span></span><br><span class="line">  client, err := consulapi.NewClient(config)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 异常处理</span></span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">  ConsulClient = client</span><br><span class="line">  <span class="comment">// service id 自动生成</span></span><br><span class="line">  ServiceData.Id=<span class="string">&quot;userservice&quot;</span>+ uuid.New().String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改注册服务func</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegService</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建AgentServiceRegistration 对象</span></span><br><span class="line">    reg := consulapi.AgentServiceRegistration&#123;&#125;</span><br><span class="line">    <span class="comment">// 设置注册的id  这个不能重复</span></span><br><span class="line">    reg.ID = ServiceData.Id</span><br><span class="line">    <span class="comment">// 注册服务的name 可以重复</span></span><br><span class="line">    reg.Name = ServiceData.Name</span><br><span class="line">    <span class="comment">// 注册服务的地址</span></span><br><span class="line">    reg.Address = LocalIp</span><br><span class="line">    <span class="comment">// 注册服务的端口</span></span><br><span class="line">    reg.Port = ServiceData.Port</span><br><span class="line">    <span class="comment">// 注册服务的tags 可以多个</span></span><br><span class="line">    reg.Tags = []<span class="keyword">string</span>&#123;<span class="string">&quot;primary&quot;</span>, <span class="string">&quot;v1&quot;</span>&#125;</span><br><span class="line">    <span class="comment">// 创建 AgentServiceCheck 来设置checkhealth</span></span><br><span class="line">    check := consulapi.AgentServiceCheck&#123;&#125;</span><br><span class="line">    <span class="comment">// 触发的时长 5s</span></span><br><span class="line">    check.Interval = <span class="string">&quot;5s&quot;</span></span><br><span class="line">    <span class="comment">// 健康检测的接口  注意修改checkheal接口</span></span><br><span class="line">    check.HTTP = fmt.Sprintf(<span class="string">&quot;http://%s:%d/health&quot;</span>, LocalIp,ServiceData.Port) </span><br><span class="line">    <span class="comment">// 这里需要传递一个指针</span></span><br><span class="line">    reg.Check = &amp;check</span><br><span class="line">    err := ConsulClient.Agent().ServiceRegister(&amp;reg)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 异常处理</span></span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>反注册 直接调用之前生成好的id即可</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取消注册</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UnRegService</span><span class="params">()</span></span> &#123;</span><br><span class="line">    err := ConsulClient.Agent().ServiceDeregister(ServiceData.Id)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 异常处理</span></span><br><span class="line">        log.Fatal(err)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Go-kit 学习笔记-十一-使用负载均衡的方式调用服务轮询方式</title>
    <url>/2020/09/17/Go-kit-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%81%E4%B8%80-%E4%BD%BF%E7%94%A8%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E8%B0%83%E7%94%A8%E6%9C%8D%E5%8A%A1%E8%BD%AE%E8%AF%A2%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="使用负载均衡的方式调用服务轮询方式"><a href="#使用负载均衡的方式调用服务轮询方式" class="headerlink" title="使用负载均衡的方式调用服务轮询方式"></a>使用负载均衡的方式调用服务轮询方式</h3><h4 id="Go-kit-帮我们封装了一个非常简单的负载均衡器"><a href="#Go-kit-帮我们封装了一个非常简单的负载均衡器" class="headerlink" title="Go-kit 帮我们封装了一个非常简单的负载均衡器"></a>Go-kit 帮我们封装了一个非常简单的负载均衡器</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">mylb := lb.NewRoundRobin(endpointer)</span><br></pre></td></tr></table></figure>



<p>在client服务中我们修改下获取endpoint的code</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">getUserInfo, _ := mylb.Endpoint() <span class="comment">// 如果一个都没有的情况下 第二个参数为nil</span></span><br></pre></td></tr></table></figure>



<h4 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h4><ol>
<li><p>​     修改代码 让客户端一直发送请求</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">                    <span class="comment">// getUserInfo:=endpoints[0] 写死获取第一个</span></span><br><span class="line">                    getUserInfo, _ := mylb.Endpoint() <span class="comment">// 如果一个都没有的情况下 第二个参数为nil</span></span><br><span class="line">                    ctx := context.Background()       <span class="comment">// 第三步：创建一个空的上下文对象</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 第四步：执行</span></span><br><span class="line">                    res, err := getUserInfo(ctx, UserRequest&#123;Uid: <span class="number">101</span>&#125;)</span><br><span class="line">                    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                        fmt.Println(err)</span><br><span class="line">                        os.Exit(<span class="number">1</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 将response进行类型断言</span></span><br><span class="line">                    userInfo := res.(UserResponse)</span><br><span class="line">                    fmt.Println(userInfo.Result)</span><br><span class="line">                    time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>执行 输出结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go run main.go</span><br><span class="line">mfxing  go run main.go</span><br><span class="line">service=userservice tags=&quot;[primary v1]&quot; instances=3</span><br><span class="line">服务有 3 条</span><br><span class="line">richard8080</span><br><span class="line">richard8081</span><br><span class="line">richard8082</span><br><span class="line">richard8080</span><br><span class="line">richard8081</span><br><span class="line">richard8082</span><br><span class="line">^Csignal: interrupt</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Go-kit 学习笔记-十七-统一异常处理设置自己的Error对象</title>
    <url>/2020/09/20/Go-kit-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%81%E4%B8%83-%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%B7%B1%E7%9A%84Error%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h3 id="统一异常处理设置自己的Error对象"><a href="#统一异常处理设置自己的Error对象" class="headerlink" title="统一异常处理设置自己的Error对象"></a>统一异常处理设置自己的Error对象</h3><p>先看下error的定义</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The error built-in interface type is the conventional interface for</span></span><br><span class="line"><span class="comment">// representing an error condition, with the nil value representing no error.</span></span><br><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此我们可以看出只要声明一个struct 然后实现了Error方法 这个struct就是一个Error</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> util</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyError <span class="keyword">struct</span> &#123;</span><br><span class="line">    Code    <span class="keyword">int</span></span><br><span class="line">    Message <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMyError</span><span class="params">(code <span class="keyword">int</span>, messgae <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;MyError&#123;Code: code, Message: messgae&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.Message</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后在 MyErrorEncoder 通过类型断言进行处理</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyErrorEncoder</span><span class="params">(_ context.Context, err error, w http.ResponseWriter)</span></span> &#123;</span><br><span class="line">    contentType, body := <span class="string">&quot;text/plain; charset=utf-8&quot;</span>, []<span class="keyword">byte</span>(err.Error())</span><br><span class="line">    w.Header().Set(<span class="string">&quot;Content-Type&quot;</span>, contentType)</span><br><span class="line">    <span class="keyword">if</span> myerr, ok := err.(*util.MyError); ok &#123; <span class="comment">// 类型断言一下</span></span><br><span class="line">        w.WriteHeader(myerr.Code)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        w.WriteHeader(<span class="number">500</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    _, _ = w.Write(body)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>修改负载均衡返回的错误</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// api 限流 的实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RateLimit</span><span class="params">(limiter *rate.Limiter)</span> <span class="title">endpoint</span>.<span class="title">Middleware</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(next endpoint.Endpoint)</span> <span class="title">endpoint</span>.<span class="title">Endpoint</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, request <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(response <span class="keyword">interface</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> limiter.Allow() &#123;</span><br><span class="line">                <span class="keyword">return</span> next(ctx, request)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//return nil, errors.New(&quot;too many requests&quot;)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, util.NewMyError(<span class="number">429</span>,<span class="string">&quot;too many request&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>​    启动程序</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> run main.<span class="keyword">go</span> --name=userservice -port=<span class="number">8080</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/images/Go-kit-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%81%E4%B8%83-%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%B7%B1%E7%9A%84Error%E5%AF%B9%E8%B1%A1/image-20200919172145389.png" alt="image-20200919172145389" style="zoom:50%;" />]]></content>
  </entry>
  <entry>
    <title>Go-kit 学习笔记-十三-API限流1go内置的rate包学习上</title>
    <url>/2020/09/17/Go-kit-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%81%E4%B8%89-API%E9%99%90%E6%B5%811go%E5%86%85%E7%BD%AE%E7%9A%84rate%E5%8C%85%E5%AD%A6%E4%B9%A0%E4%B8%8A/</url>
    <content><![CDATA[<h3 id="API限流1go内置的rate包学习上—Wait、WaitN"><a href="#API限流1go内置的rate包学习上—Wait、WaitN" class="headerlink" title="API限流1go内置的rate包学习上—Wait、WaitN"></a>API限流1go内置的rate包学习上—Wait、WaitN</h3><h4 id="需求："><a href="#需求：" class="headerlink" title="需求："></a>需求：</h4><p>​    场景1： 付费的用户对api的调用不限制次数，不付费的用户1分钟只能请求50次</p>
<p>​    场景2： 对于并发量高的接口做请求次数限制 防刷</p>
<h4 id="Go内置的rate包"><a href="#Go内置的rate包" class="headerlink" title="Go内置的rate包"></a>Go内置的rate包</h4><p>​    Go提供了一个内置的现流包 <code>&quot;golang.org/x/time/rate&quot;</code> 可以非常方便的实现限流</p>
<p>一般市面上常用的限流算法有两种： <code>漏桶</code> 和<code>令牌桶</code></p>
<img src="/images/Go-kit-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%81%E4%B8%89-API%E9%99%90%E6%B5%811go%E5%86%85%E7%BD%AE%E7%9A%84rate%E5%8C%85%E5%AD%A6%E4%B9%A0%E4%B8%8A/format,png.png" alt="限流——令牌桶算法（与漏桶的区别）_HD243608836的博客-CSDN博客" style="zoom:80%;" />



<p><img src="/images/Go-kit-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%81%E4%B8%89-API%E9%99%90%E6%B5%811go%E5%86%85%E7%BD%AE%E7%9A%84rate%E5%8C%85%E5%AD%A6%E4%B9%A0%E4%B8%8A/format,png-20200916204340747.png" alt="限流——令牌桶算法（与漏桶的区别）_HD243608836的博客-CSDN博客"></p>
<h5 id="核心的三个方法："><a href="#核心的三个方法：" class="headerlink" title="核心的三个方法："></a>核心的三个方法：</h5><ol>
<li>wait/waitN</li>
<li>allow/allowN</li>
<li>reserve/reserveN</li>
</ol>
<h4 id="wait-waitN的使用"><a href="#wait-waitN的使用" class="headerlink" title="wait/waitN的使用"></a>wait/waitN的使用</h4><h5 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r := rate.NewLimiter(r, b) </span><br></pre></td></tr></table></figure>

<h5 id="理解："><a href="#理解：" class="headerlink" title="理解："></a>理解：</h5><p>​    桶容量为<code>B</code>，灌满，然后每次往里面填充<code>r</code>个令牌。（r 就是速率）</p>
<p><code>r:=rate.NewLimiter(1, 5)</code> // 第二个参数就是容量<code>b</code>，第一个每次放几个(<code>r</code>)</p>
<p><code>fmt.Println(r.Limit(),r.Burst())</code></p>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><h5 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := rate.NewLimiter(<span class="number">1</span>, <span class="number">5</span>) </span><br><span class="line">    ctx := context.Background()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        r.WaitN(ctx, <span class="number">2</span>) <span class="comment">// 每次取两个</span></span><br><span class="line">        fmt.Println(time.Now().Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>))</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mfxing  go run flag_1.go</span><br><span class="line">2020-09-16 20:27:32</span><br><span class="line">2020-09-16 20:27:33</span><br><span class="line">2020-09-16 20:27:34</span><br><span class="line">2020-09-16 20:27:35</span><br><span class="line">2020-09-16 20:27:37</span><br><span class="line">2020-09-16 20:27:39</span><br><span class="line">2020-09-16 20:27:41</span><br><span class="line">2020-09-16 20:27:43</span><br><span class="line">2020-09-16 20:27:45</span><br><span class="line">2020-09-16 20:27:47</span><br><span class="line">2020-09-16 20:27:49</span><br><span class="line">2020-09-16 20:27:51</span><br><span class="line">2020-09-16 20:27:53</span><br><span class="line">2020-09-16 20:27:55</span><br><span class="line">^Csignal: interrupt</span><br><span class="line"><span class="meta">#</span><span class="bash">可以看出 从第五个开始需要每隔一秒才输出，达到限流目的</span></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Go-kit 学习笔记-十九-熔断器学习2配置command、超时报错、设置最大超时时间</title>
    <url>/2020/09/23/Go-kit-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%81%E4%B9%9D-%E7%86%94%E6%96%AD%E5%99%A8%E5%AD%A6%E4%B9%A02%E9%85%8D%E7%BD%AEcommand%E3%80%81%E8%B6%85%E6%97%B6%E6%8A%A5%E9%94%99%E3%80%81%E8%AE%BE%E7%BD%AE%E6%9C%80%E5%A4%A7%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<p><a href="https://github.com/afex/hystrix-go">Hystrix-go的文档</a></p>
<h3 id="配置command、超时报错、设置最大超时时间"><a href="#配置command、超时报错、设置最大超时时间" class="headerlink" title="配置command、超时报错、设置最大超时时间"></a>配置command、超时报错、设置最大超时时间</h3><p>hystrix的本质是commond的模式，把每一个执行过程都封装成一个commond，然后委托hystrix去执行</p>
<p>修改下上节课的代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/afex/hystrix-go/hystrix&quot;</span></span><br><span class="line">    <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Product <span class="keyword">struct</span> &#123;</span><br><span class="line">    Id <span class="keyword">int</span></span><br><span class="line">    Title <span class="keyword">string</span></span><br><span class="line">    Price <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getProduct</span><span class="params">()</span><span class="params">(Product,error)</span></span>&#123;</span><br><span class="line">    r:=rand.Intn(<span class="number">10</span>)</span><br><span class="line">    fmt.Println(r)</span><br><span class="line">    <span class="keyword">if</span> r&lt;<span class="number">8</span>&#123;</span><br><span class="line">        time.Sleep(time.Second*<span class="number">3</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  Product&#123;</span><br><span class="line">        Id: <span class="number">101</span>,</span><br><span class="line">        Title: <span class="string">&quot;Richard Go kit 笔记&quot;</span>,</span><br><span class="line">        Price: <span class="number">1</span>,</span><br><span class="line">    &#125;,<span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line">    configA:=hystrix.CommandConfig&#123;Timeout: <span class="number">5000</span>,&#125;</span><br><span class="line">  <span class="comment">// 通过name 将configA配置到get_prod上</span></span><br><span class="line">    hystrix.ConfigureCommand(<span class="string">&quot;get_prod&quot;</span>,configA)</span><br><span class="line">    <span class="keyword">for</span>  &#123;</span><br><span class="line">        err:=hystrix.Do(<span class="string">&quot;get_prod&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">            p,_:=getProduct()</span><br><span class="line">            fmt.Println(p)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;,<span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">if</span> err !=<span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mfxing  go run hystrix_demo.go</span><br><span class="line">3</span><br><span class="line">&#123;101 Richard Go kit 笔记 1&#125;</span><br><span class="line">1</span><br><span class="line">&#123;101 Richard Go kit 笔记 1&#125;</span><br><span class="line">9</span><br><span class="line">&#123;101 Richard Go kit 笔记 1&#125;</span><br><span class="line">4</span><br><span class="line">^Csignal: interrupt</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Go-kit 学习笔记-十二-使用负载均衡的方式调用服务随机方式</title>
    <url>/2020/09/17/Go-kit-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%81%E4%BA%8C-%E4%BD%BF%E7%94%A8%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E8%B0%83%E7%94%A8%E6%9C%8D%E5%8A%A1%E9%9A%8F%E6%9C%BA%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>###使用负载均衡的方式调用服务随机方式</p>
<p>修改go-kit提供轮询的负载均衡方式</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mylb := lb.NewRoundRobin(endpointer) // 轮询调用</span></span><br><span class="line">mylb := lb.NewRandom(endpointer, time.Now().UnixNano()) <span class="comment">// 第一个参数是endpointer，第二个参数是一个int64的随机种子</span></span><br></pre></td></tr></table></figure>



<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go run main.go</span><br><span class="line">service=userservice tags=&quot;[primary v1]&quot; instances=3</span><br><span class="line">服务有 3 条</span><br><span class="line">richard8081</span><br><span class="line">richard8080</span><br><span class="line">richard8080</span><br><span class="line">richard8080</span><br><span class="line">richard8081</span><br><span class="line">^Csignal: interrupt</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Go-kit 学习笔记-十五-API限流3集成限流功能到我们的服务中</title>
    <url>/2020/09/17/Go-kit-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%81%E4%BA%94-API%E9%99%90%E6%B5%813%E9%9B%86%E6%88%90%E9%99%90%E6%B5%81%E5%8A%9F%E8%83%BD%E5%88%B0%E6%88%91%E4%BB%AC%E7%9A%84%E6%9C%8D%E5%8A%A1%E4%B8%AD/</url>
    <content><![CDATA[<h3 id="API限流-集成限流功能到我们的服务中"><a href="#API限流-集成限流功能到我们的服务中" class="headerlink" title="API限流-集成限流功能到我们的服务中"></a>API限流-集成限流功能到我们的服务中</h3><h4 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h4><ol>
<li>方案一：在server端的endpoint方法加入 rate中的*Limiter，然后对limiter进行判断 ，弊端 这样对代码侵入性很强 不推荐</li>
<li>方案二 ： 类似于python的装饰模式，封装好一个新的func  然后返回值是endpoint </li>
</ol>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><ol>
<li><p>​    步骤一： 创建一个func 架子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RateLimit</span><span class="params">(limiter *rate.Limiter)</span> <span class="title">endpoint</span>.<span class="title">Middleware</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>步骤二： 确定好返回值   </p>
<pre><code>     1.首先查看endpoint.Middleware 的定义如下
         //    Middleware is a chainable behavior modifier for endpoints.
        // type Middleware func(Endpoint) Endpoint 
    2.再去看 Endpoint的定义 如下
   // type Endpoint func(ctx context.Context, request interface&#123;&#125;)                  //(response interface&#123;&#125;, err error)</code></pre>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RateLimit</span><span class="params">(limiter *rate.Limiter)</span> <span class="title">endpoint</span>.<span class="title">Middleware</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(next endpoint.Endpoint)</span> <span class="title">endpoint</span>.<span class="title">Endpoint</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, request <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(response <span class="keyword">interface</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class="line">            <span class="comment">// 对limtier进行判断 </span></span><br><span class="line">      <span class="comment">// todo 实现业务逻辑</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最终的实现</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RateLimit</span><span class="params">(limiter *rate.Limiter)</span> <span class="title">endpoint</span>.<span class="title">Middleware</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(next endpoint.Endpoint)</span> <span class="title">endpoint</span>.<span class="title">Endpoint</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, request <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(response <span class="keyword">interface</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> limiter.Allow() &#123;</span><br><span class="line">                <span class="keyword">return</span> next(ctx, request)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;too many requests&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在main函数中应用</p>
   <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// 创建一个limiter</span></span><br><span class="line">newLimiter :=rate.NewLimiter(<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment">// 第二层 创建endpoint</span></span><br><span class="line">endP := Services.RateLimit(newLimiter)(Services.GenUserEndpoint(user))</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><p>​    在浏览器中请求 ip:port/user/101  一直刷新 就会有too many requests 出现</p>
]]></content>
  </entry>
  <entry>
    <title>Go-kit 学习笔记-十八-服务容错、熔断器入门</title>
    <url>/2020/09/20/Go-kit-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%81%E5%85%AB-%E6%9C%8D%E5%8A%A1%E5%AE%B9%E9%94%99%E3%80%81%E7%86%94%E6%96%AD%E5%99%A8%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h3 id="服务容错、熔断器入门"><a href="#服务容错、熔断器入门" class="headerlink" title="服务容错、熔断器入门"></a>服务容错、熔断器入门</h3><p>第三方库： <a href="https://github.com/afex/hystrix-go">https://github.com/afex/hystrix-go</a></p>
<p>本质是：隔离远程服务，防止级联故障发生</p>
<p>同款的项目：netflix同名java项目： <a href="https://github.com/Netflix/Hystrix">https://github.com/Netflix/Hystrix</a></p>
<p>安装 go get github.com/afex/hystrix-go</p>
<p><img src="/images/Go-kit-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%81%E5%85%AB-%E6%9C%8D%E5%8A%A1%E5%AE%B9%E9%94%99%E3%80%81%E7%86%94%E6%96%AD%E5%99%A8%E5%85%A5%E9%97%A8/image-20200919182206067.png" alt="image-20200919182206067"></p>
<h4 id="随机延迟3s"><a href="#随机延迟3s" class="headerlink" title="随机延迟3s"></a>随机延迟3s</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Product <span class="keyword">struct</span> &#123;</span><br><span class="line">    Id <span class="keyword">int</span></span><br><span class="line">    Title <span class="keyword">string</span></span><br><span class="line">    Price <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getProduct</span><span class="params">()</span><span class="params">(Product,error)</span></span>&#123;</span><br><span class="line">    r:=rand.Intn(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">if</span> r&lt;<span class="number">6</span>&#123;</span><br><span class="line">        fmt.Println(r)</span><br><span class="line">        time.Sleep(<span class="number">3</span>*time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  Product&#123;</span><br><span class="line">        Id: <span class="number">101</span>,</span><br><span class="line">        Title: <span class="string">&quot;Richard Go kit 笔记&quot;</span>,</span><br><span class="line">        Price: <span class="number">1</span>,</span><br><span class="line">    &#125;,<span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line">    <span class="keyword">for</span>  &#123;</span><br><span class="line">        p,_:=getProduct() <span class="comment">// 这里随机延迟3s</span></span><br><span class="line">        fmt.Println(p)</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Go-kit 学习笔记-十六-统一异常处理上编写自定义处理函数</title>
    <url>/2020/09/19/Go-kit-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%81%E5%85%AD-%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%8A%E7%BC%96%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h3 id="统一异常处理上编写自定义处理函数"><a href="#统一异常处理上编写自定义处理函数" class="headerlink" title="统一异常处理上编写自定义处理函数"></a>统一异常处理上编写自定义处理函数</h3><h5 id="自定义函数应该再哪里去调用"><a href="#自定义函数应该再哪里去调用" class="headerlink" title="自定义函数应该再哪里去调用"></a>自定义函数应该再哪里去调用</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">serverHandler := httpTransport.NewServer(endP, Services.DecodeUserRequest, Services.EncodeUserRequest)</span><br></pre></td></tr></table></figure>

<p>第一个参数是endpoint 第二个参数是requestdecoder ，第三个是response encode，其实还有第四个参数，options切片</p>
<p>我们可以使用httpTransport.ServerOption 来创建一个options切</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">options:=[]httpTransport.ServerOption&#123;</span><br><span class="line">        httpTransport.ServerErrorEncoder(ErrorEncoder), </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>根据doc 我们可以看到ServerErrorEncoder 里面需要传入的是ErrorEncoder，在go-kit中server有实现好的json和默认encoder</p>
<img src="/images/Go-kit-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%81%E5%85%AD-%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%8A%E7%BC%96%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/image-20200919162945035.png" alt="image-20200919162945035" style="zoom: 50%;" />

<p>我们仿照defaultErrorEncode方法 实现一个</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyErrorEncoder</span><span class="params">(_ context.Context, err error, w http.ResponseWriter)</span></span> &#123;</span><br><span class="line">    contentType, body := <span class="string">&quot;text/plain; charset=utf-8&quot;</span>, []<span class="keyword">byte</span>(err.Error())</span><br><span class="line">    w.Header().Set(<span class="string">&quot;Content-Type&quot;</span>, contentType)</span><br><span class="line">    w.WriteHeader(<span class="number">901</span>)</span><br><span class="line">    w.Write(body)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在main.go 方法中调用 </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用自定义错误方法</span></span><br><span class="line">options:=[]httpTransport.ServerOption&#123;</span><br><span class="line">    httpTransport.ServerErrorEncoder(Services.MyErrorEncoder),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">serverHandler := httpTransport.NewServer(endP, Services.DecodeUserRequest, Services.EncodeUserRequest,options...)</span><br></pre></td></tr></table></figure>



<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>多次请求/user/123接口会返回901的错误</p>
<p><img src="/images/Go-kit-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%81%E5%85%AD-%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%8A%E7%BC%96%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/image-20200919163429208.png" alt="image-20200919163429208"></p>
]]></content>
  </entry>
  <entry>
    <title>Go-kit 学习笔记-十四-API限流2go内置的rate包学习下</title>
    <url>/2020/09/17/Go-kit-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%81%E5%9B%9B-API%E9%99%90%E6%B5%812go%E5%86%85%E7%BD%AE%E7%9A%84rate%E5%8C%85%E5%AD%A6%E4%B9%A0%E4%B8%8B/</url>
    <content><![CDATA[<h3 id="AllowN、httpserver测试"><a href="#AllowN、httpserver测试" class="headerlink" title="AllowN、httpserver测试"></a>AllowN、httpserver测试</h3><h4 id="allowN和waitN的区别"><a href="#allowN和waitN的区别" class="headerlink" title="allowN和waitN的区别"></a>allowN和waitN的区别</h4><p>​    allowN 如果不满足的条件会返回一个bool类型的值 而waitN不满足条件会进行程序阻塞</p>
<h4 id="allow的使用"><a href="#allow的使用" class="headerlink" title="allow的使用"></a>allow的使用</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := rate.NewLimiter(<span class="number">1</span>, <span class="number">5</span>) </span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r.AllowN(time.Now(), <span class="number">2</span>) &#123; <span class="comment">// 使用allowN</span></span><br><span class="line">            fmt.Println(time.Now().Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            fmt.Println(<span class="string">&quot;too many request&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mfxing  go run flag_1.go</span><br><span class="line">2020-09-16 21:19:31</span><br><span class="line">2020-09-16 21:19:32</span><br><span class="line">2020-09-16 21:19:33</span><br><span class="line">2020-09-16 21:19:34</span><br><span class="line">too many request</span><br><span class="line">2020-09-16 21:19:36</span><br><span class="line">too many request</span><br><span class="line">^Csignal: interrupt</span><br></pre></td></tr></table></figure>



<h4 id="allowN应用到httpserver中"><a href="#allowN应用到httpserver中" class="headerlink" title="allowN应用到httpserver中"></a>allowN应用到httpserver中</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> r = rate.NewLimiter(<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个简单的server</span></span><br><span class="line">    mux := http.NewServeMux()</span><br><span class="line">    mux.HandleFunc(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> r.AllowN(time.Now(), <span class="number">2</span>) &#123;</span><br><span class="line">            _, _ = writer.Write([]<span class="keyword">byte</span>(<span class="string">&quot;OK!!!!!&quot;</span>))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            http.Error(writer, <span class="string">&quot;too many request&quot;</span>, http.StatusTooManyRequests)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    _ = http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, mux)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在正式的环境中我们需要使用中间件来进行对<code>handler</code>进行包装 如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> r = rate.NewLimiter(<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值需要是一个http Handler</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyLimiter</span><span class="params">(next http.Handler)</span> <span class="title">http</span>.<span class="title">Handler</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r.AllowN(time.Now(), <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// 将请求的调用链放行</span></span><br><span class="line">            next.ServeHTTP(writer, request)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            http.Error(writer, <span class="string">&quot;too many request&quot;</span>, http.StatusTooManyRequests)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个简单的server</span></span><br><span class="line">    mux := http.NewServeMux()</span><br><span class="line">    mux.HandleFunc(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">        _, _ = writer.Write([]<span class="keyword">byte</span>(<span class="string">&quot;OK!!!!!&quot;</span>))</span><br><span class="line">    &#125;)</span><br><span class="line">    _ = http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, MyLimiter(mux))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Go-kit 学习笔记五-服务注册与发现</title>
    <url>/2020/09/15/Go-kit-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/</url>
    <content><![CDATA[<h3 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h3><p><img src="/images/Go-kit-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/image-20200914235250075.png" alt="image-20200914235250075"></p>
<p>从图中我们能发现 注册中心除了能对api1和api2提供服务外 还能对服务本身进行健康检查</p>
<h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>服务管理软件，支持多数据中心，分布式高可用，服务发现和配置共享、成员管理和消息广播，支持acl访问控制。 相关的软件有<code>Zookeeper</code>，<code>etcd</code>，<code>springcloud</code>里的<code>Eureka</code></p>
<p>来到官网</p>
<p><code>https://www.consul.io/downloads</code></p>
<ol>
<li>根据你的机器下载对应的文件</li>
<li>解压后就是一个可执行文件</li>
<li>拷贝到<code>/usr/local/bin</code>目录下 或者你喜欢的环境变量中</li>
<li>执行<code>consul -v</code> 出现正常的版本就可以继续往下了</li>
</ol>
<h4 id="使用docker-镜像部署consul"><a href="#使用docker-镜像部署consul" class="headerlink" title="使用docker 镜像部署consul"></a>使用docker 镜像部署consul</h4><p>docker 镜像地址</p>
<p><code>https://hub.docker.com/_/consul</code></p>
<p>拉取镜像 （镜像是基于alpine 3.7的）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull consul</span><br></pre></td></tr></table></figure>

<h4 id="最简单的容器启动"><a href="#最简单的容器启动" class="headerlink" title="最简单的容器启动"></a>最简单的容器启动</h4><p>启动一个服务端</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --name=cs --network host -p 8500:8500 \</span><br><span class="line">consul agent -server -bootstrap -ui -client 0.0.0.0 -data-dir=/tmp/consul  </span><br></pre></td></tr></table></figure>

<p>(8500是后台ui的端口，别忘了sudo iptables -I INPUT -p tcp -dport 8500 -j ACCEPT)</p>
<p>接下来就可以访问 <a href="http://localhost:8500/">http://localhost:8500</a> 查看后台情况</p>
<p>-server 表示以服务端的方式启动</p>
<p>-bootstrap 表示自己为leader 不需要选举</p>
<p>-ui 启动一个内置管理web页面</p>
<p>-client 表示客户端可以访问的ip，0.0.0.0 表示任意ip都可以访问，否则默认本机可以访问</p>
<h4 id="使用文档"><a href="#使用文档" class="headerlink" title="使用文档"></a>使用文档</h4><ol>
<li><p>基本api 教学 ，文档地址</p>
<p><code>https://www.consul.io/api-docs</code></p>
</li>
<li><p>查看当前所有服务</p>
<p><code>http://127.0.0.1:8500/v1/agent/services</code></p>
</li>
</ol>
<h3 id="尝试手动注册一个服务"><a href="#尝试手动注册一个服务" class="headerlink" title="尝试手动注册一个服务"></a>尝试手动注册一个服务</h3><p>首先确保自己本地服务启动</p>
<p>并确保虚拟机上能访问</p>
<p>譬如我们代码里的请求：<code>http://localhost:8080/user/101</code></p>
<p>然后增加一个<code>/health</code> 输出<code>&#123;&quot;status&quot;:200&#125; </code>  注意json头要加</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r := myMux.NewRouter()</span><br><span class="line">    &#123;</span><br><span class="line">        r.Methods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;DELETE&quot;</span>).Path(<span class="string">&quot;/user/&#123;uid:[0-9]+&#125;&quot;</span>).Handler(serverHandler)</span><br><span class="line">        r.Methods(<span class="string">&quot;GET&quot;</span>).Path(<span class="string">&quot;/health&quot;</span>).HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">            writer.Header().Set(<span class="string">&quot;Content-type&quot;</span>, <span class="string">&quot;Application/json&quot;</span>)</span><br><span class="line">            _, _ = writer.Write([]<span class="keyword">byte</span>(<span class="string">`&#123;&quot;status&quot;:200&#125;`</span>))</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为serverHandler 已经实现了handler 接口 所以http.ListenAndServe 可以直接调用</span></span><br><span class="line">    _ = http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, r)</span><br></pre></td></tr></table></figure>



<p>创建一个json文件,内容如下</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;ID&quot;</span>: <span class="string">&quot;userservice&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;Name&quot;</span>: <span class="string">&quot;userservice&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;Tags&quot;</span>: [<span class="string">&quot;primary&quot;</span>, <span class="string">&quot;v1&quot;</span>],</span><br><span class="line">  <span class="attr">&quot;Address&quot;</span>:<span class="string">&quot;192.168.1.1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;Port&quot;</span>:<span class="number">8080</span>,</span><br><span class="line">  <span class="attr">&quot;Check&quot;</span>:&#123;</span><br><span class="line">    <span class="attr">&quot;HTTP&quot;</span>:<span class="string">&quot;http://localhost:8080/health&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;Interval&quot;</span>:<span class="string">&quot;5s&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>提交服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl --request PUT  --data @p.json localhost:8500/v1/agent/service/register</span><br></pre></td></tr></table></figure>

<p>这时我们继续查看</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl http://localhost:8500/v1/agent/services</span><br><span class="line">&#123;&quot;userservice&quot;:&#123;&quot;ID&quot;:&quot;userservice&quot;,&quot;Service&quot;:&quot;userservice&quot;,&quot;Tags&quot;:[&quot;primary&quot;,&quot;v1&quot;],&quot;Meta&quot;:&#123;&#125;,&quot;Port&quot;:8080,&quot;Address&quot;:&quot;192.168.0.1&quot;,&quot;TaggedAddresses&quot;:&#123;&quot;lan_ipv4&quot;:&#123;&quot;Address&quot;:&quot;192.168.0.1&quot;,&quot;Port&quot;:8080&#125;,&quot;wan_ipv4&quot;:&#123;&quot;Address&quot;:&quot;192.168.0.1&quot;,&quot;Port&quot;:8080&#125;&#125;,&quot;Weights&quot;:&#123;&quot;Passing&quot;:1,&quot;Warning&quot;:1&#125;,&quot;EnableTagOverride&quot;:false&#125;&#125;%</span><br></pre></td></tr></table></figure>

<p>并且再本地的uiweb管理页面也能查看到 注册好的userservice了</p>
<p>反注册</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl \</span><br><span class="line"> --request PUT \</span><br><span class="line">http://localhost:8500/v1/agent/service/deregister/userservice</span><br></pre></td></tr></table></figure>

<p>这时再去查看服务列表就会发现变成空了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> curl http://localhost:8500/v1/agent/services</span><br><span class="line">&#123;&#125;%</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Go-kit 学习笔记-四</title>
    <url>/2020/09/01/Go-kit-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9B%9B/</url>
    <content><![CDATA[<h3 id="通过httpmethod-执行不同的服务方法"><a href="#通过httpmethod-执行不同的服务方法" class="headerlink" title="通过httpmethod 执行不同的服务方法"></a>通过httpmethod 执行不同的服务方法</h3><ol>
<li><p>将获取到的method 保存到request 中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DecodeUserRequest</span><span class="params">(c context.Context, r *http.Request)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 这个主要是判断参数是怎么来的,代码可以写成</span></span><br><span class="line"></span><br><span class="line">    vars:=mux.Vars(r)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>  uid,ok:=vars[<span class="string">&quot;uid&quot;</span>];ok&#123;</span><br><span class="line">        uid, _ := strconv.Atoi(uid)</span><br><span class="line">        <span class="keyword">return</span> UserRequest&#123;Uid: uid,Method: r.Method&#125;, <span class="literal">nil</span>  <span class="comment">// 通过r.method 获取</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>,errors.New(<span class="string">&quot;参数错误&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在service中实现相应的方法</p>
<ol>
<li><p>​    添加删除的接口</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> IUserService <span class="keyword">interface</span> &#123;</span><br><span class="line">    GetName(userId <span class="keyword">int</span>) <span class="keyword">string</span></span><br><span class="line">    DeleteName(userId <span class="keyword">int</span>) error <span class="comment">// 新增删除接口 返回错误信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现删除的接口 (这里101标识是管理员用户)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this UserService)</span> <span class="title">DeleteName</span><span class="params">(userId <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> userId == <span class="number">101</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">&quot;无权限&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据method 执行不同的方法 调用service中声明好的方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 因为这个IUserService 可能有多个版本的实现 所以这里使 用接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenUserEndpoint</span><span class="params">(userService IUserService)</span> <span class="title">endpoint</span>.<span class="title">Endpoint</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, request <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(response <span class="keyword">interface</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class="line">        r := request.(UserRequest)</span><br><span class="line">        <span class="keyword">var</span> result <span class="keyword">string</span></span><br><span class="line">        <span class="keyword">if</span> r.Method == <span class="string">&quot;GET&quot;</span> &#123;  <span class="comment">// 判断不同的method</span></span><br><span class="line">            result = userService.GetName(r.Uid)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> r.Method == <span class="string">&quot;DELETE&quot;</span> &#123;</span><br><span class="line">            err := userService.DeleteName(r.Uid)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123; <span class="comment">// 代表没有权限</span></span><br><span class="line">                result = err.Error()</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result = fmt.Sprintf(<span class="string">&quot;用户%d删除成功&quot;</span>, r.Uid)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> UserResponse&#123;Result: result&#125;, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在路由中支持 <code>GET</code> <code>DELETE</code> 方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r:=myMux.NewRouter()</span><br><span class="line">&#123;</span><br><span class="line">    r.Methods(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;DELETE&quot;</span>).Path(<span class="string">&quot;/user/&#123;uid:[0-9]+&#125;&quot;</span>).Handler(serverHandler)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 因为serverHandler 已经实现了handler 接口 所以http.ListenAndServe 可以直接调用</span></span><br><span class="line">_ = http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, r)</span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ol>
<h3 id="验证结果"><a href="#验证结果" class="headerlink" title="验证结果"></a>验证结果</h3><ol>
<li><p>GET 获取管理员用户</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl --request GET \</span><br><span class="line">  --url http://localhost:8080/user/101</span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;result&quot;: &quot;richard&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>GET 获取普通用户</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl --request GET \</span><br><span class="line">  --url http://localhost:8080/user/102</span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;result&quot;: &quot;guest&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除普通用户</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl --request DELETE \</span><br><span class="line">  --url http://localhost:8080/user/102</span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;result&quot;: &quot;用户102删除成功&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除管理员用户</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl --request DELETE \</span><br><span class="line">  --url http://localhost:8080/user/101</span><br><span class="line">  </span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;result&quot;: &quot;无权限&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="5">
<li><p>其他http method 请求</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl --request POST \</span><br><span class="line">  --url http://localhost:8080/user/101</span><br><span class="line">  </span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line">405 Method Not Allowed</span><br></pre></td></tr></table></figure>



</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Go-kit 学习笔记六- 使用go向Consul注册服务的基本方法</title>
    <url>/2020/09/16/Go-kit-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AD-%E4%BD%BF%E7%94%A8go%E5%90%91Consul%E6%B3%A8%E5%86%8C%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="使用go向Consul注册服务的基本方法"><a href="#使用go向Consul注册服务的基本方法" class="headerlink" title="使用go向Consul注册服务的基本方法"></a>使用go向Consul注册服务的基本方法</h3><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p> 下载<code>consul</code>的依赖 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go get github.com/hashicorp/consul</span><br></pre></td></tr></table></figure>



<p>将<code>p.json</code>的文件使用<code>go</code>来调用</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;ID&quot;</span>: <span class="string">&quot;userservice&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;Name&quot;</span>: <span class="string">&quot;userservice&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;Tags&quot;</span>: [<span class="string">&quot;primary&quot;</span>, <span class="string">&quot;v1&quot;</span>],</span><br><span class="line">  <span class="attr">&quot;Address&quot;</span>:<span class="string">&quot;192.168.1.1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;Port&quot;</span>:<span class="number">8080</span>,</span><br><span class="line">  <span class="attr">&quot;Check&quot;</span>:&#123;</span><br><span class="line">    <span class="attr">&quot;HTTP&quot;</span>:<span class="string">&quot;http://localhost:8080/health&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;Interval&quot;</span>:<span class="string">&quot;5s&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><code>gofunc</code>如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    consulapi <span class="string">&quot;github.com/hashicorp/consul/api&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegService</span><span class="params">()</span></span> &#123;</span><br><span class="line">    config := consulapi.DefaultConfig()</span><br><span class="line">    <span class="comment">// 设置consul 地址</span></span><br><span class="line">    config.Address = <span class="string">&quot;192.168.236.2:8500&quot;</span></span><br><span class="line">    <span class="comment">// 创建AgentServiceRegistration 对象</span></span><br><span class="line">    reg := consulapi.AgentServiceRegistration&#123;&#125;</span><br><span class="line">    <span class="comment">// 设置注册的id  这个不能重复</span></span><br><span class="line">    reg.ID = <span class="string">&quot;userservice1&quot;</span></span><br><span class="line">    <span class="comment">// 注册服务的name 可以重复</span></span><br><span class="line">    reg.Name = <span class="string">&quot;userservice&quot;</span></span><br><span class="line">    <span class="comment">// 注册服务的地址</span></span><br><span class="line">    reg.Address = <span class="string">&quot;192.168.236.2&quot;</span></span><br><span class="line">    <span class="comment">// 注册服务的端口</span></span><br><span class="line">    reg.Port = <span class="number">8080</span></span><br><span class="line">    <span class="comment">// 注册服务的tags 可以多个</span></span><br><span class="line">    reg.Tags = []<span class="keyword">string</span>&#123;<span class="string">&quot;primary&quot;</span>, <span class="string">&quot;v1&quot;</span>&#125;</span><br><span class="line">    <span class="comment">// 创建 AgentServiceCheck 来设置checkhealth</span></span><br><span class="line">    check := consulapi.AgentServiceCheck&#123;&#125;</span><br><span class="line">    <span class="comment">// 触发的时长 5s</span></span><br><span class="line">    check.Interval = <span class="string">&quot;1s&quot;</span></span><br><span class="line">    <span class="comment">// 健康检测的接口</span></span><br><span class="line">    check.HTTP = <span class="string">&quot;http://192.168.236.2:8080/health&quot;</span></span><br><span class="line">    <span class="comment">// 这里需要传递一个指针</span></span><br><span class="line">    reg.Check = &amp;check</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个client 把我们的服务注册到consul上</span></span><br><span class="line">    client, err := consulapi.NewClient(config)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 异常处理</span></span><br><span class="line">        log.Fatal(err)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    err = client.Agent().ServiceRegister(&amp;reg)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 异常处理</span></span><br><span class="line">        log.Fatal(err)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在<code>main.go</code>中调用该<code>func</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">util.RegService() <span class="comment">// consul 注册服务</span></span><br><span class="line">    <span class="comment">// 因为serverHandler 已经实现了handler 接口 所以http.ListenAndServe 可以直接调用</span></span><br><span class="line">    _ = http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, r)</span><br></pre></td></tr></table></figure>



<p>启动服务之后就可以在consul的内置web管理界面上看到注册的userservice服务了</p>
<p><img src="/images/Go-kit-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AD-%E4%BD%BF%E7%94%A8go%E5%90%91Consul%E6%B3%A8%E5%86%8C%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/image-20200915174630772.png" alt="image-20200915174630772"></p>
<p>如果停止服务之后，过一会儿consul就看不到我们注册的服务了。</p>
]]></content>
  </entry>
  <entry>
    <title>Go 语言学习笔记 Gin框架(一)</title>
    <url>/2020/08/06/Go-%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Gin%E6%A1%86%E6%9E%B6-%E4%B8%80/</url>
    <content><![CDATA[<h1 id="Go-语言学习笔记-Gin框架-一"><a href="#Go-语言学习笔记-Gin框架-一" class="headerlink" title="Go 语言学习笔记 Gin框架(一)"></a>Go 语言学习笔记 Gin框架(一)</h1><h2 id="httprouter的性能"><a href="#httprouter的性能" class="headerlink" title="httprouter的性能"></a>httprouter的性能</h2><table>
<thead>
<tr>
<th>Benchmark name</th>
<th>(1)</th>
<th>(2)</th>
<th>(3)</th>
<th>(4)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>BenchmarkGin_GithubAll</strong></td>
<td><strong>30000</strong></td>
<td><strong>48375</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
</tr>
<tr>
<td>BenchmarkAce_GithubAll</td>
<td>10000</td>
<td>134059</td>
<td>13792</td>
<td>167</td>
</tr>
<tr>
<td>BenchmarkBear_GithubAll</td>
<td>5000</td>
<td>534445</td>
<td>86448</td>
<td>943</td>
</tr>
<tr>
<td>BenchmarkBeego_GithubAll</td>
<td>3000</td>
<td>592444</td>
<td>74705</td>
<td>812</td>
</tr>
</tbody></table>
<ul>
<li>(1): Total Repetitions achieved in constant time, higher means more confident result</li>
<li>(2): Single Repetition Duration (ns/op), lower is better</li>
<li>(3): Heap Memory (B/op), lower is better</li>
<li>(4): Average Allocations per Repetition (allocs/op), lower is better</li>
</ul>
<h2 id="内置使用了jsoniter"><a href="#内置使用了jsoniter" class="headerlink" title="内置使用了jsoniter"></a>内置使用了jsoniter</h2><p>Gin uses <code>encoding/json</code> as default json package but you can change to <a href="https://github.com/json-iterator/go">jsoniter</a> by build from other tags.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go build -tags=jsoniter .</span></span><br></pre></td></tr></table></figure>

<h2 id="router-api支持restful"><a href="#router-api支持restful" class="headerlink" title="router api支持restful"></a>router api支持restful</h2><h3 id="支持GET-POST-PUT-PATCH-DELETE-and-OPTIONS"><a href="#支持GET-POST-PUT-PATCH-DELETE-and-OPTIONS" class="headerlink" title="支持GET, POST, PUT, PATCH, DELETE and OPTIONS"></a>支持GET, POST, PUT, PATCH, DELETE and OPTIONS</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Creates a gin router with default middleware:</span></span><br><span class="line">    <span class="comment">// logger and recovery (crash-free) middleware</span></span><br><span class="line">    router := gin.Default()</span><br><span class="line"></span><br><span class="line">    router.GET(<span class="string">&quot;/someGet&quot;</span>, getting)</span><br><span class="line">    router.POST(<span class="string">&quot;/somePost&quot;</span>, posting)</span><br><span class="line">    router.PUT(<span class="string">&quot;/somePut&quot;</span>, putting)</span><br><span class="line">    router.DELETE(<span class="string">&quot;/someDelete&quot;</span>, deleting)</span><br><span class="line">    router.PATCH(<span class="string">&quot;/somePatch&quot;</span>, patching)</span><br><span class="line">    router.HEAD(<span class="string">&quot;/someHead&quot;</span>, head)</span><br><span class="line">    router.OPTIONS(<span class="string">&quot;/someOptions&quot;</span>, options)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// By default it serves on :8080 unless a</span></span><br><span class="line">    <span class="comment">// PORT environment variable was defined.</span></span><br><span class="line">    router.Run()</span><br><span class="line">    <span class="comment">// router.Run(&quot;:3000&quot;) for a hard coded port</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="支持路径中带有参数"><a href="#支持路径中带有参数" class="headerlink" title="支持路径中带有参数"></a>支持路径中带有参数</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    router := gin.Default()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This handler will match /user/john but will not match /user/ or /user</span></span><br><span class="line">    router.GET(<span class="string">&quot;/user/:name&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        name := c.Param(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">        c.String(http.StatusOK, <span class="string">&quot;Hello %s&quot;</span>, name)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// However, this one will match /user/john/ and also /user/john/send</span></span><br><span class="line">    <span class="comment">// If no other routers match /user/john, it will redirect to /user/john/</span></span><br><span class="line">    router.GET(<span class="string">&quot;/user/:name/*action&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        name := c.Param(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">        action := c.Param(<span class="string">&quot;action&quot;</span>)</span><br><span class="line">        message := name + <span class="string">&quot; is &quot;</span> + action</span><br><span class="line">        c.String(http.StatusOK, message)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For each matched request Context will hold the route definition</span></span><br><span class="line">    router.POST(<span class="string">&quot;/user/:name/*action&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        c.FullPath() == <span class="string">&quot;/user/:name/*action&quot;</span> <span class="comment">// true</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    router.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="支持url地址中kv获取"><a href="#支持url地址中kv获取" class="headerlink" title="支持url地址中kv获取"></a>支持url地址中kv获取</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    router := gin.Default()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Query string parameters are parsed using the existing underlying request object.</span></span><br><span class="line">    <span class="comment">// The request responds to a url matching:  /welcome?firstname=Jane&amp;lastname=Doe</span></span><br><span class="line">    router.GET(<span class="string">&quot;/welcome&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        firstname := c.DefaultQuery(<span class="string">&quot;firstname&quot;</span>, <span class="string">&quot;Guest&quot;</span>) <span class="comment">// 如果获取不到可以使用默认值</span></span><br><span class="line">        lastname := c.Query(<span class="string">&quot;lastname&quot;</span>) <span class="comment">// 如果获取不到是空字符串 shortcut for c.Request.URL.Query().Get(&quot;lastname&quot;)</span></span><br><span class="line"></span><br><span class="line">        c.String(http.StatusOK, <span class="string">&quot;Hello %s %s&quot;</span>, firstname, lastname)</span><br><span class="line">    &#125;)</span><br><span class="line">    router.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="支持获取form表单中的kv"><a href="#支持获取form表单中的kv" class="headerlink" title="支持获取form表单中的kv"></a>支持获取form表单中的kv</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    router := gin.Default()</span><br><span class="line"></span><br><span class="line">    router.POST(<span class="string">&quot;/form_post&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        message := c.PostForm(<span class="string">&quot;message&quot;</span>)</span><br><span class="line">        nick := c.DefaultPostForm(<span class="string">&quot;nick&quot;</span>, <span class="string">&quot;anonymous&quot;</span>) <span class="comment">// nick获取不到就赋值为anonymous</span></span><br><span class="line"></span><br><span class="line">        c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">            <span class="string">&quot;status&quot;</span>:  <span class="string">&quot;posted&quot;</span>,</span><br><span class="line">            <span class="string">&quot;message&quot;</span>: message,</span><br><span class="line">            <span class="string">&quot;nick&quot;</span>:    nick,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    router.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="支持url和post-form-联合的取值"><a href="#支持url和post-form-联合的取值" class="headerlink" title="支持url和post form 联合的取值"></a>支持url和post form 联合的取值</h3><p>请求:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/post?id=1234&amp;page=1</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">name=manu&amp;message=this_is_great</span><br></pre></td></tr></table></figure>

<p>接收：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    router := gin.Default()</span><br><span class="line"></span><br><span class="line">    router.POST(<span class="string">&quot;/post&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        id := c.Query(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">        page := c.DefaultQuery(<span class="string">&quot;page&quot;</span>, <span class="string">&quot;0&quot;</span>)</span><br><span class="line">        name := c.PostForm(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">        message := c.PostForm(<span class="string">&quot;message&quot;</span>)</span><br><span class="line"></span><br><span class="line">        fmt.Printf(<span class="string">&quot;id: %s; page: %s; name: %s; message: %s&quot;</span>, id, page, name, message)</span><br><span class="line">    &#125;)</span><br><span class="line">    router.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">id: 1234; page: 1; name: manu; message: this_is_great</span><br></pre></td></tr></table></figure>

<p>###支持post form传递map</p>
<p>请求：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;post?ids[a]&#x3D;1234&amp;ids[b]&#x3D;hello HTTP&#x2F;1.1</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">names[first]&#x3D;thinkerou&amp;names[second]&#x3D;tianou</span><br></pre></td></tr></table></figure>

<p>接收：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    router := gin.Default()</span><br><span class="line"></span><br><span class="line">    router.POST(<span class="string">&quot;/post&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        ids := c.QueryMap(<span class="string">&quot;ids&quot;</span>)</span><br><span class="line">        names := c.PostFormMap(<span class="string">&quot;names&quot;</span>)</span><br><span class="line"></span><br><span class="line">        fmt.Printf(<span class="string">&quot;ids: %v; names: %v&quot;</span>, ids, names)</span><br><span class="line">    &#125;)</span><br><span class="line">    router.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ids: map[b:hello a:1234], names: map[second:tianou first:thinkerou]</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h2><h3 id="单个文件"><a href="#单个文件" class="headerlink" title="单个文件"></a>单个文件</h3><p>请求：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -X POST http://localhost:8080/upload \</span><br><span class="line">  -F &quot;file=@/Users/appleboy/test.zip&quot; \</span><br><span class="line">  -H &quot;Content-Type: multipart/form-data&quot;</span><br></pre></td></tr></table></figure>

<p>接收：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    router := gin.Default()</span><br><span class="line">    <span class="comment">// Set a lower memory limit for multipart forms (default is 32 MiB)</span></span><br><span class="line">    <span class="comment">// router.MaxMultipartMemory = 8 &lt;&lt; 20  // 8 MiB</span></span><br><span class="line">    router.POST(<span class="string">&quot;/upload&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        <span class="comment">// single file</span></span><br><span class="line">        file, _ := c.FormFile(<span class="string">&quot;file&quot;</span>)</span><br><span class="line">        log.Println(file.Filename)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Upload the file to specific dst.</span></span><br><span class="line">        <span class="comment">// c.SaveUploadedFile(file, dst)</span></span><br><span class="line"></span><br><span class="line">        c.String(http.StatusOK, fmt.Sprintf(<span class="string">&quot;&#x27;%s&#x27; uploaded!&quot;</span>, file.Filename))</span><br><span class="line">    &#125;)</span><br><span class="line">    router.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="多个文件"><a href="#多个文件" class="headerlink" title="多个文件"></a>多个文件</h3><p>请求：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -X POST http://localhost:8080/upload \</span><br><span class="line">  -F &quot;upload[]=@/Users/appleboy/test1.zip&quot; \</span><br><span class="line">  -F &quot;upload[]=@/Users/appleboy/test2.zip&quot; \</span><br><span class="line">  -H &quot;Content-Type: multipart/form-data&quot;</span><br></pre></td></tr></table></figure>

<p>接收：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    router := gin.Default()</span><br><span class="line">    <span class="comment">// Set a lower memory limit for multipart forms (default is 32 MiB)</span></span><br><span class="line">    <span class="comment">// router.MaxMultipartMemory = 8 &lt;&lt; 20  // 8 MiB</span></span><br><span class="line">    router.POST(<span class="string">&quot;/upload&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        <span class="comment">// Multipart form</span></span><br><span class="line">        form, _ := c.MultipartForm()</span><br><span class="line">        files := form.File[<span class="string">&quot;upload[]&quot;</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _, file := <span class="keyword">range</span> files &#123;</span><br><span class="line">            log.Println(file.Filename)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Upload the file to specific dst.</span></span><br><span class="line">            <span class="comment">// c.SaveUploadedFile(file, dst)</span></span><br><span class="line">        &#125;</span><br><span class="line">        c.String(http.StatusOK, fmt.Sprintf(<span class="string">&quot;%d files uploaded!&quot;</span>, <span class="built_in">len</span>(files)))</span><br><span class="line">    &#125;)</span><br><span class="line">    router.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="路由分组"><a href="#路由分组" class="headerlink" title="路由分组"></a>路由分组</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    router := gin.Default()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Simple group: v1</span></span><br><span class="line">    v1 := router.Group(<span class="string">&quot;/v1&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        v1.POST(<span class="string">&quot;/login&quot;</span>, loginEndpoint)</span><br><span class="line">        v1.POST(<span class="string">&quot;/submit&quot;</span>, submitEndpoint)</span><br><span class="line">        v1.POST(<span class="string">&quot;/read&quot;</span>, readEndpoint)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Simple group: v2</span></span><br><span class="line">    v2 := router.Group(<span class="string">&quot;/v2&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        v2.POST(<span class="string">&quot;/login&quot;</span>, loginEndpoint)</span><br><span class="line">        v2.POST(<span class="string">&quot;/submit&quot;</span>, submitEndpoint)</span><br><span class="line">        v2.POST(<span class="string">&quot;/read&quot;</span>, readEndpoint)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    router.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r := gin.New() <span class="comment">//初始化一个空白的gin</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r := gin.Default() <span class="comment">// 初始化一个带有Logger and Recovery 中间件的gin</span></span><br></pre></td></tr></table></figure>

<h4 id="加载中间件"><a href="#加载中间件" class="headerlink" title="加载中间件"></a>加载中间件</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认情况下，gin.DefaultWriter=os.Stdout</span></span><br><span class="line">r.Use(gin.Logger())</span><br><span class="line"><span class="comment">//Recovery 中间件可以从任何panic中恢复，如果出现panic，则会写入500。</span></span><br><span class="line">r.Use(gin.Recovery())</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="指定路由使用中间件"><a href="#指定路由使用中间件" class="headerlink" title="指定路由使用中间件"></a>指定路由使用中间件</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于每个路由中间件，您可以添加任意数量的</span></span><br><span class="line">r.GET(<span class="string">&quot;/benchmark&quot;</span>, MyBenchLogger(), benchEndpoint)</span><br></pre></td></tr></table></figure>



<h4 id="指定group添加authorized-认证"><a href="#指定group添加authorized-认证" class="headerlink" title="指定group添加authorized 认证"></a>指定group添加authorized 认证</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">authorized := r.Group(<span class="string">&quot;/&quot;</span>)</span><br><span class="line"><span class="comment">// 每个组中间件！在本例中，我们使用自定义创建的//AuthRequired（）中间件就在“authorized”组中。</span></span><br><span class="line">authorized.Use(AuthRequired())</span><br><span class="line">&#123;</span><br><span class="line">  authorized.POST(<span class="string">&quot;/login&quot;</span>, loginEndpoint)</span><br><span class="line">  authorized.POST(<span class="string">&quot;/submit&quot;</span>, submitEndpoint)</span><br><span class="line">  authorized.POST(<span class="string">&quot;/read&quot;</span>, readEndpoint)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 还可以嵌套使用</span></span><br><span class="line">  testing := authorized.Group(<span class="string">&quot;testing&quot;</span>)</span><br><span class="line">  testing.GET(<span class="string">&quot;/analytics&quot;</span>, analyticsEndpoint)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="自定义日志"><a href="#自定义日志" class="headerlink" title="自定义日志"></a>自定义日志</h4><p>#####设置日志输出格式 </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    router := gin.New()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LoggerWithFormatter middleware will write the logs to gin.DefaultWriter</span></span><br><span class="line">    <span class="comment">// By default gin.DefaultWriter = os.Stdout</span></span><br><span class="line">    router.Use(gin.LoggerWithFormatter(<span class="function"><span class="keyword">func</span><span class="params">(param gin.LogFormatterParams)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// your custom format</span></span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%s - [%s] \&quot;%s %s %s %d %s \&quot;%s\&quot; %s\&quot;\n&quot;</span>,</span><br><span class="line">                param.ClientIP,</span><br><span class="line">                param.TimeStamp.Format(time.RFC1123),</span><br><span class="line">                param.Method,</span><br><span class="line">                param.Path,</span><br><span class="line">                param.Request.Proto,</span><br><span class="line">                param.StatusCode,</span><br><span class="line">                param.Latency,</span><br><span class="line">                param.Request.UserAgent(),</span><br><span class="line">                param.ErrorMessage,</span><br><span class="line">        )</span><br><span class="line">    &#125;))</span><br><span class="line">    router.Use(gin.Recovery())</span><br><span class="line"></span><br><span class="line">    router.GET(<span class="string">&quot;/ping&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        c.String(<span class="number">200</span>, <span class="string">&quot;pong&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    router.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">::1 - [Fri, 07 Dec 2018 17:04:38 JST] &quot;GET &#x2F;ping HTTP&#x2F;1.1 200 122.767µs &quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;71.0.3578.80 Safari&#x2F;537.36&quot; &quot;</span><br></pre></td></tr></table></figure>

<h5 id="控制日志颜色"><a href="#控制日志颜色" class="headerlink" title="控制日志颜色"></a>控制日志颜色</h5><p>关闭日志颜色</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">gin.DisableConsoleColor()</span><br></pre></td></tr></table></figure>

<p>开启日志颜色</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">gin.ForceConsoleColor()</span><br></pre></td></tr></table></figure>

<h2 id="参数绑定和校验"><a href="#参数绑定和校验" class="headerlink" title="参数绑定和校验"></a>参数绑定和校验</h2><p>支持json、xml、yaml 和标准化form values</p>
]]></content>
      <categories>
        <category>go</category>
        <category>gin</category>
      </categories>
      <tags>
        <tag>gin</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 语言学习笔记 Gin框架(五)</title>
    <url>/2020/08/06/Go-%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Gin%E6%A1%86%E6%9E%B6-%E4%BA%94/</url>
    <content><![CDATA[<h1 id="gin-router的使用"><a href="#gin-router的使用" class="headerlink" title="gin router的使用"></a>gin router的使用</h1><h2 id="gin简单的router-启动一个http服务"><a href="#gin简单的router-启动一个http服务" class="headerlink" title="gin简单的router 启动一个http服务"></a>gin简单的router 启动一个http服务</h2><h3 id="基本的router-注册"><a href="#基本的router-注册" class="headerlink" title="基本的router 注册"></a>基本的router 注册</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helloHandler</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">        <span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello q1mi!&quot;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line">    r.GET(<span class="string">&quot;/hello&quot;</span>, helloHandler)</span><br><span class="line">    <span class="keyword">if</span> err := r.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;startup service failed, err:%v\n&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：</p>
<p>适用于路由条目比较少的简单项目或者项目demo。</p>
<h3 id="路由拆分成单独文件或者包"><a href="#路由拆分成单独文件或者包" class="headerlink" title="路由拆分成单独文件或者包"></a>路由拆分成单独文件或者包</h3><p>当项目的规模增大后就不太适合继续在项目的<code>main.go</code>文件中去实现路由注册相关逻辑了，我们会倾向于把路由部分的代码都拆分出来，形成一个单独的文件或包：</p>
<p>我们在<code>routers.go</code>文件中定义并注册路由信息：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helloHandler</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">        <span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello q1mi!&quot;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setupRouter</span><span class="params">()</span> *<span class="title">gin</span>.<span class="title">Engine</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line">    r.GET(<span class="string">&quot;/hello&quot;</span>, helloHandler)</span><br><span class="line">    <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>

<p>此时<code>main.go</code>中调用上面定义好的<code>setupRouter</code>函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := setupRouter()</span><br><span class="line">    <span class="keyword">if</span> err := r.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;startup service failed, err:%v\n&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此时的目录结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gin_demo</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── main.go</span><br><span class="line">└── routers.go</span><br></pre></td></tr></table></figure>

<p>把路由部分的代码单独拆分成包的话也是可以的，拆分后的目录结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gin_demo</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── main.go</span><br><span class="line">└── routers</span><br><span class="line">    └── routers.go</span><br></pre></td></tr></table></figure>

<p><code>routers/routers.go</code>需要注意此时<code>setupRouter</code>需要改成首字母大写：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> routers</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helloHandler</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">        <span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello q1mi!&quot;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SetupRouter 配置路由信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetupRouter</span><span class="params">()</span> *<span class="title">gin</span>.<span class="title">Engine</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line">    r.GET(<span class="string">&quot;/hello&quot;</span>, helloHandler)</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>main.go</code>文件内容如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;gin_demo/routers&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := routers.SetupRouter()</span><br><span class="line">    <span class="keyword">if</span> err := r.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;startup service failed, err:%v\n&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="路由拆分成多个文件"><a href="#路由拆分成多个文件" class="headerlink" title="路由拆分成多个文件"></a>路由拆分成多个文件</h3><p>当我们的业务规模继续膨胀，单独的一个<code>routers</code>文件或包已经满足不了我们的需求了，</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetupRouter</span><span class="params">()</span> *<span class="title">gin</span>.<span class="title">Engine</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line">    r.GET(<span class="string">&quot;/hello&quot;</span>, helloHandler)</span><br><span class="line">  r.GET(<span class="string">&quot;/xx1&quot;</span>, xxHandler1)</span><br><span class="line">  ...</span><br><span class="line">  r.GET(<span class="string">&quot;/xx30&quot;</span>, xxHandler30)</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为我们把所有的路由注册都写在一个<code>SetupRouter</code>函数中的话就会太复杂了。</p>
<p>我们可以分开定义多个路由文件，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gin_demo</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── main.go</span><br><span class="line">└── routers</span><br><span class="line">    ├── blog.go</span><br><span class="line">    └── shop.go</span><br></pre></td></tr></table></figure>

<p><code>routers/shop.go</code>中添加一个<code>LoadShop</code>的函数，将shop相关的路由注册到指定的路由器：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadShop</span><span class="params">(e *gin.Engine)</span></span>  &#123;</span><br><span class="line">    e.GET(<span class="string">&quot;/hello&quot;</span>, helloHandler)</span><br><span class="line">  e.GET(<span class="string">&quot;/goods&quot;</span>, goodsHandler)</span><br><span class="line">  e.GET(<span class="string">&quot;/checkout&quot;</span>, checkoutHandler)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>routers/blog.go</code>中添加一个`LoadBlog的函数，将blog相关的路由注册到指定的路由器：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadBlog</span><span class="params">(e *gin.Engine)</span></span> &#123;</span><br><span class="line">    e.GET(<span class="string">&quot;/post&quot;</span>, postHandler)</span><br><span class="line">  e.GET(<span class="string">&quot;/comment&quot;</span>, commentHandler)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在main函数中实现最终的注册逻辑如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line">    routers.LoadBlog(r)</span><br><span class="line">    routers.LoadShop(r)</span><br><span class="line">    <span class="keyword">if</span> err := r.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;startup service failed, err:%v\n&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="路由拆分到不同的APP"><a href="#路由拆分到不同的APP" class="headerlink" title="路由拆分到不同的APP"></a>路由拆分到不同的APP</h3><p>有时候项目规模实在太大，那么我们就更倾向于把业务拆分的更详细一些，例如把不同的业务代码拆分成不同的APP。</p>
<p>因此我们在项目目录下单独定义一个<code>app</code>目录，用来存放我们不同业务线的代码文件，这样就很容易进行横向扩展。大致目录结构如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gin_demo</span><br><span class="line">├── app</span><br><span class="line">│   ├── blog</span><br><span class="line">│   │   ├── handler.go</span><br><span class="line">│   │   └── router.go</span><br><span class="line">│   └── shop</span><br><span class="line">│       ├── handler.go</span><br><span class="line">│       └── router.go</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── main.go</span><br><span class="line">└── routers</span><br><span class="line">    └── routers.go</span><br></pre></td></tr></table></figure>

<p>其中<code>app/blog/router.go</code>用来定义post相关路由信息，具体内容如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Routers</span><span class="params">(e *gin.Engine)</span></span> &#123;</span><br><span class="line">    e.GET(<span class="string">&quot;/post&quot;</span>, postHandler)</span><br><span class="line">    e.GET(<span class="string">&quot;/comment&quot;</span>, commentHandler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>app/shop/router.go</code>用来定义shop相关路由信息，具体内容如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Routers</span><span class="params">(e *gin.Engine)</span></span> &#123;</span><br><span class="line">    e.GET(<span class="string">&quot;/goods&quot;</span>, goodsHandler)</span><br><span class="line">    e.GET(<span class="string">&quot;/checkout&quot;</span>, checkoutHandler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>routers/routers.go</code>中根据需要定义<code>Include</code>函数用来注册子app中定义的路由，<code>Init</code>函数用来进行路由的初始化操作：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Option <span class="function"><span class="keyword">func</span><span class="params">(*gin.Engine)</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> options = []Option&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册app的路由配置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Include</span><span class="params">(opts ...Option)</span></span> &#123;</span><br><span class="line">    options = <span class="built_in">append</span>(options, opts...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Init</span><span class="params">()</span> *<span class="title">gin</span>.<span class="title">Engine</span></span> &#123;</span><br><span class="line">    r := gin.New()</span><br><span class="line">    <span class="keyword">for</span> _, opt := <span class="keyword">range</span> options &#123;</span><br><span class="line">        opt(r)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>main.go</code>中按如下方式先注册子app中的路由，然后再进行路由的初始化：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 加载多个APP的路由配置</span></span><br><span class="line">    routers.Include(shop.Routers, blog.Routers)</span><br><span class="line">    <span class="comment">// 初始化路由</span></span><br><span class="line">    r := routers.Init()</span><br><span class="line">    <span class="keyword">if</span> err := r.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;startup service failed, err:%v\n&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>go</category>
        <category>gin</category>
      </categories>
      <tags>
        <tag>gin</tag>
        <tag>router</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 语言学习笔记 Gin框架(二)</title>
    <url>/2020/08/06/Go-%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Gin%E6%A1%86%E6%9E%B6-%E4%BA%8C/</url>
    <content><![CDATA[<h1 id="使用viper读取配置文件"><a href="#使用viper读取配置文件" class="headerlink" title="使用viper读取配置文件"></a>使用viper读取配置文件</h1><p>应用系统的配置信息，一般分为两种，一是经常变化的配置则保存到数据库，另外一种则是不常变化的则以配置文件的形式保存。一般而言，应用系统至少有三组运行环境：开发环境、测试环境、生产环境</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h2 id="青铜时代"><a href="#青铜时代" class="headerlink" title="青铜时代"></a>青铜时代</h2><p>一开始的时候，我针对每个环境配置各自的yaml，在启动的时候根据环境变量读取相应的配置文件，处理代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initConfig</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    env := os.Getenv(<span class="string">&quot;GO_ENV&quot;</span>)</span><br><span class="line">    viper.SetConfigName(env)</span><br><span class="line">    viper.AddConfigPath(<span class="string">&quot;./configs&quot;</span>)</span><br><span class="line">    viper.SetConfigType(<span class="string">&quot;yml&quot;</span>)</span><br><span class="line">    err = viper.ReadInConfig()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    err := initConfig()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(viper.GetString(<span class="string">&quot;db.uri&quot;</span>))</span><br><span class="line">    fmt.Println(viper.GetString(<span class="string">&quot;db.poolSize&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不同环境的配置文件如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># test</span></span><br><span class="line"><span class="attr">app:</span> <span class="string">viper-test</span></span><br><span class="line"><span class="attr">db:</span></span><br><span class="line">  <span class="attr">uri:</span> <span class="string">postgres://tree:mypwd@127.0.0.1:5432/viper-test?connect_timeout=5&amp;sslmode=disable</span></span><br><span class="line">  <span class="attr">poolSize:</span> <span class="number">100</span></span><br><span class="line"><span class="comment"># production</span></span><br><span class="line"><span class="attr">app:</span> <span class="string">viper-test</span></span><br><span class="line"><span class="attr">db:</span></span><br><span class="line">  <span class="attr">uri:</span> <span class="string">postgres://tree:mypwd@10.1.1.1:5432/viper?connect_timeout=5&amp;sslmode=disable</span></span><br><span class="line">  <span class="attr">poolSize:</span> <span class="number">100</span></span><br></pre></td></tr></table></figure>

<p>由上面的代码可以看出，因为viper读取的配置只有一份，因此需要在每个配置中将所有的配置都一一填写，而不同环境的配置绝大部分都是相同的，只有小部分是不一致。一开始只有不到10个配置项的时候还好维护，后面配置信息越来越多，几十个的时候就是一个深坑了，看到眼都花了，太难管理。</p>
<h2 id="白银时代"><a href="#白银时代" class="headerlink" title="白银时代"></a>白银时代</h2><p>各运行环境中的配置90%左右是相同，而剩下的10%才是各环境的差异配置，是否可以将相同的配置以默认值的形式保存，而各环境与默认值不相同的再覆盖呢？查看了一下文档，发现了 <code>viper.SetDefault</code> 的函数，一开始是直接在代码一行行的把默认配置写上，但是这样无法利用yaml的便利，在研究了相关的代码之后，最后调整为如下的处理形式，代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initConfig</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    configType := <span class="string">&quot;yml&quot;</span></span><br><span class="line">    defaultPath := <span class="string">&quot;./configs&quot;</span></span><br><span class="line">    v := viper.New()</span><br><span class="line">    <span class="comment">// 从default中读取默认的配置</span></span><br><span class="line">    v.SetConfigName(<span class="string">&quot;default&quot;</span>)</span><br><span class="line">    v.AddConfigPath(defaultPath)</span><br><span class="line">    v.SetConfigType(configType)</span><br><span class="line">    err = v.ReadInConfig()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    configs := v.AllSettings()</span><br><span class="line">    <span class="comment">// 将default中的配置全部以默认配置写入</span></span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> configs &#123;</span><br><span class="line">        viper.SetDefault(k, v)</span><br><span class="line">    &#125;</span><br><span class="line">    env := os.Getenv(<span class="string">&quot;GO_ENV&quot;</span>)</span><br><span class="line">    <span class="comment">// 根据配置的env读取相应的配置信息</span></span><br><span class="line">    <span class="keyword">if</span> env != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        viper.SetConfigName(env)</span><br><span class="line">        viper.AddConfigPath(defaultPath)</span><br><span class="line">        viper.SetConfigType(configType)</span><br><span class="line">        err = viper.ReadInConfig()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此函数将 <code>default.yml</code> 的所有配置读取至一个新的viper实例中，再以 <code>SetDefault</code> 将所有配置写入为默认配置，而各环境配置文件只需要配置差异部分，配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># default</span><br><span class="line">app: viper-test</span><br><span class="line">db:</span><br><span class="line">  uri: postgres:&#x2F;&#x2F;tree:mypwd@127.0.0.1:5432&#x2F;viper-test?connect_timeout&#x3D;5&amp;sslmode&#x3D;disable</span><br><span class="line">  poolSize: 100</span><br><span class="line"># test与default完全一致，为空文件</span><br><span class="line"># production只是数据库连接串不一致，只需要配置此项</span><br><span class="line">db:</span><br><span class="line">  uri: postgres:&#x2F;&#x2F;tree:mypwd@10.1.1.1:5432&#x2F;viper?connect_timeout&#x3D;5&amp;sslmode&#x3D;disable</span><br></pre></td></tr></table></figure>

<p>通过此调整，不再需要重复的维护相同的配置项，而且也能直观的看出各运行环境的配置差异，减少配置信息的出错概率。</p>
<hr>
<h2 id="王者时代"><a href="#王者时代" class="headerlink" title="王者时代"></a>王者时代</h2><p>因为主要是后端程序应用，程序交付一般都是通过docker镜像的形式，配置文件与编译后的应用程序一起打包至镜像中，在多个项目中也使用得挺顺畅。最近有一个项目非运行在docker环境下，因此希望能将配置文件一起打包至应用程序的方式，在了解了几个相关的项目，最终选择了使用 <a href="https://www.jishuwen.com/jump/aHR0cHM6Ly9naXRodWIuY29tL2dvYnVmZmFsby9wYWNrcg==">packr</a> 来将配置文件打包，调整之后的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func initConfig() (err error) &#123;</span><br><span class="line">    box :&#x3D; packr.NewBox(&quot;.&#x2F;configs&quot;)</span><br><span class="line">    configType :&#x3D; &quot;yml&quot;</span><br><span class="line">    defaultConfig :&#x3D; box.Bytes(&quot;default.yml&quot;)</span><br><span class="line">    v :&#x3D; viper.New()</span><br><span class="line">    v.SetConfigType(configType)</span><br><span class="line">    err &#x3D; v.ReadConfig(bytes.NewReader(defaultConfig))</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    configs :&#x3D; v.AllSettings()</span><br><span class="line">    &#x2F;&#x2F; 将default中的配置全部以默认配置写入</span><br><span class="line">    for k, v :&#x3D; range configs &#123;</span><br><span class="line">        viper.SetDefault(k, v)</span><br><span class="line">    &#125;</span><br><span class="line">    env :&#x3D; os.Getenv(&quot;GO_ENV&quot;)</span><br><span class="line">    &#x2F;&#x2F; 根据配置的env读取相应的配置信息</span><br><span class="line">    if env !&#x3D; &quot;&quot; &#123;</span><br><span class="line">        envConfig :&#x3D; box.Bytes(env + &quot;.yml&quot;)</span><br><span class="line"></span><br><span class="line">        viper.SetConfigType(configType)</span><br><span class="line">        err &#x3D; viper.ReadConfig(bytes.NewReader(envConfig))</span><br><span class="line">        if err !&#x3D; nil &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调整之后，配置文件也编译至程序中，后续可以单执行文件交付，只通过在启动时指定 <code>GO_ENV</code> 则可。</p>
]]></content>
      <categories>
        <category>go</category>
        <category>gin</category>
      </categories>
      <tags>
        <tag>viper</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 语言学习笔记 Gin框架(六)</title>
    <url>/2020/08/06/Go-%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Gin%E6%A1%86%E6%9E%B6-%E5%85%AD/</url>
    <content><![CDATA[<p>#gin与 swagger的集成</p>
<h2 id="swagger的介绍"><a href="#swagger的介绍" class="headerlink" title="swagger的介绍"></a>swagger的介绍</h2><h3 id="什么是swagger"><a href="#什么是swagger" class="headerlink" title="什么是swagger"></a>什么是swagger</h3><p>Swagger 是一个规范和一套完整的框架，用于生成、描述、调用以及可视化 RESTful 风格的 Web 服务。</p>
<p>Swagger的总体目标是使客户端和文件系统服务器以同样的速度来更新，方法，参数和模型紧密集成到服务器端的代码中，允许API始终保持同步。</p>
<p>Swagger 让部署管理和使用API从未如此简单。</p>
<p>Swagger包括库、编辑器、代码生成器等很多部分，这里我们主要讲一下Swagger Editor。这是一个完全开源的项目，并且它也是一个基于Angular的成功案例，我们可以下载源码并自己部署它，也可以修改它或集成到我们自己的软件中。</p>
<p>在Swagger Editor中，我们可以基于YAML语法定义我们的RESTful API，然后它会自动生成一篇排版优美的API文档，并且提供实时预览。相信大多数朋友都遇到过这样一个场景：明明调用的是之前约定好的API，拿到的结果却不是想要的。</p>
<p>可能因为是有人修改了API的接口，却忘了更新文档；或者是文档更新的不及时；又或者是文档写的有歧义，大家的理解各不相同。总之，让API文档总是与API定义同步更新，是一件非常有价值的事。</p>
<h3 id="自动文档的好处？"><a href="#自动文档的好处？" class="headerlink" title="自动文档的好处？"></a>自动文档的好处？</h3><ol>
<li><p>不用手动写文档了，通过注解就可以自动化文档</p>
</li>
<li><p>文档和代码同步更新，代码更新之后不需要再更新文档</p>
</li>
<li><p>浏览器友好</p>
</li>
<li><p>使用Swagger框架可以调试API，在浏览器端可以看到更多的<code>request</code>和<code>response</code>信息</p>
</li>
</ol>
<h3 id="自动化文档开发的初衷"><a href="#自动化文档开发的初衷" class="headerlink" title="自动化文档开发的初衷"></a>自动化文档开发的初衷</h3><p>我们需要开发一个API应用，然后需要和手机组的开发人员一起合作，当然我们首先想到的是文档先行，我们也根据之前的经验写了我们需要的API原型文档，我们还是根据github的文档格式写了一些漂亮的文档，但是我们开始担心这个文档如果两边不同步怎么办？因为毕竟是原型文档，变动是必不可少的。手机组有一个同事之前在雅虎工作过，他推荐我看一个swagger的应用，看了swagger的标准和文档化的要求，感觉太棒了，这个简直就是神器啊，通过swagger可以方便的查看API的文档，同时使用API的用户可以直接通过swagger进行请求和获取结果。所以我就开始学习swagger的标准，同时开始进行Go源码的研究，通过Go里面的AST进行源码分析，针对comments解析，然后生成swagger标准的json格式，这样最后就可以和swagger完美结合了。</p>
<p>这样做的好处有三个：</p>
<p>注释标准化<br>有了注释之后，以后API代码维护相当方便<br>根据注释自动化生成文档，方便调用的用户查看和测试</p>
<h2 id="安装swagger"><a href="#安装swagger" class="headerlink" title="安装swagger"></a>安装swagger</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> get -u github.com/swaggo/swag/cmd/swag</span><br></pre></td></tr></table></figure>

<p>等待安装完成，在我们的终端中执行 <code>swag init</code>，目录为根目录，于 <code>main.go</code> 同目录。</p>
<p>执行完成后，会在根目录下新建一个 <code>docs</code> 文件夹。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docs</span><br><span class="line">|</span><br><span class="line">|-docs.go</span><br><span class="line">|-swagger.json</span><br><span class="line">|-swagger.yaml</span><br></pre></td></tr></table></figure>

<p>接下来就可以完善项目了。</p>
<p>将下面两行放入 <code>initRouter</code> 中的 <code>import</code> 中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">swaggerFiles &quot;github.com&#x2F;swaggo&#x2F;files&quot;</span><br><span class="line">ginSwagger &quot;github.com&#x2F;swaggo&#x2F;gin-swagger&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>选择 <code>Sync packages of GinStudy</code>,此时 <code>IDE</code> 就会自动帮我下载，并添加到 <code>go.mod</code> 中。</p>
<h2 id="集成swagger"><a href="#集成swagger" class="headerlink" title="集成swagger"></a>集成swagger</h2><p>对 <code>swagger</code> 安装完成后，我们就可以对项目进行集成了。</p>
<p>在 <code>initRouter</code> 中添加路由，这个路由是对 <code>swagger</code> 的访问地址来进行添加的</p>
<p>在<code>routers/routers.go</code>的<code>Init</code>方法中添加</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">url := ginSwagger.URL(<span class="string">&quot;http://localhost:8080/swagger/doc.json&quot;</span>)</span><br><span class="line">r.GET(<span class="string">&quot;/swagger/*any&quot;</span>, ginSwagger.WrapHandler(swaggerFiles.Handler, url))</span><br></pre></td></tr></table></figure>

<p>其中 <code>url</code> 定义了 <code>swagger</code> 的 <code>doc.json</code> 路径，我们可以直接访问该 <code>json</code> 来进行查看。</p>
<p>接下来就是完善文档的时间。</p>
<p>在 <code>main.go</code> 中 <code>main</code> 方法上添加注释。同时引入我们生成 <code>docs.go</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @title Gin swagger</span></span><br><span class="line"><span class="comment">// @version 1.0</span></span><br><span class="line"><span class="comment">// @description Gin swagger 示例项目</span></span><br><span class="line"><span class="comment">// @contact.name</span></span><br><span class="line"><span class="comment">// @contact.url https://youngxhui.top</span></span><br><span class="line"><span class="comment">// @contact.email youngxhui@g mail.com</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @license.name Apache 2.0</span></span><br><span class="line"><span class="comment">// @license.url http://www.apache.org/licenses/LICENSE-2.0.html</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @host localhost:8080</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述的注释基本都是很好理解的，不做过多解释。</p>
<p>主要的项目介绍注释就是这些，接下来进行我们的接口方法注释。</p>
<p>在我们的 <code>handler</code> 中添加注释</p>
<p>打开 <code>app/user/handler.go</code> ,在 <code>CreateUser</code> 方法上添加。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @Summary 创建用户</span></span><br><span class="line"><span class="comment">// @Tags 用户模块</span></span><br><span class="line"><span class="comment">// @version 1.0</span></span><br><span class="line"><span class="comment">// @Accept application/x-www-form-urlencoded</span></span><br><span class="line"><span class="comment">// @Param name query string true &quot;name&quot;</span></span><br><span class="line"><span class="comment">// @Param age query int true &quot;age&quot;</span></span><br><span class="line"><span class="comment">// @Success 200 object model.UserModel 成功后返回值</span></span><br><span class="line"><span class="comment">// @Router  /v1/users [post]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateUser</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    name := c.Query(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">    age := c.Query(<span class="string">&quot;age&quot;</span>)</span><br><span class="line">    ageInt, _ := strconv.Atoi(age)</span><br><span class="line">    basicHandle := app.BasicController&#123;Ctx: c&#125;</span><br><span class="line">    basicHandle.Ok(userService.Create(name, ageInt, time.Now()))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>@Summary 是对该接口的一个描述</li>
<li>@Tags 是对接口的标注，同一个 tag 为一组，这样方便我们整理接口</li>
<li>@Version 表明该接口的版本</li>
<li>@Accept 表示该该请求的请求类型</li>
<li>@Param 表示参数 分别有以下参数 参数名词 参数类型 数据类型 是否必须 注释 属性(可选参数),参数之间用空格隔开。</li>
<li>@Success 表示请求成功后返回，它有以下参数 请求返回状态码，参数类型，数据类型，注释</li>
<li>@Failure 请求失败后返回，参数同上 (todo)</li>
<li>@Router 该函数定义了请求路由并且包含路由的请求方式。</li>
</ul>
<p>具体参数类型，数据类型等可以查看<a href="https://swaggo.github.io/swaggo.io/declarative_comments_format/api_operation.html">官方文档</a></p>
<p>其中文档中没有说明的地方这里说明一下，关于 <code>Param</code> 的参数类型有以下几种</p>
<ul>
<li>query 形如 <code>\user?username=Jack&amp;age=18</code></li>
<li>body 需要将数据放到 body 中进行请求</li>
<li>path 形如 <code>\user\1</code></li>
<li>formdata 接收的是form表单提交的参数</li>
</ul>
<p>不同的参数类型对应的不同请求，请对应使用。</p>
<p>这样我们就完成了添加接口的文档注释。</p>
<p>我们对形如 <code>/v1/users/:id</code> 的接口，最后的 id 通过 <code>&#123;&#125;</code> 包裹。</p>
<p>细心的小伙伴可能会发现我们最后的返回结果为 <code>model.Result</code> ，这是为了我们统一返回结果而新建的一个结构体，方便前端进行解析。具体函数如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> &#123;</span><br><span class="line">    Code    <span class="keyword">int</span>         <span class="string">`json:&quot;code&quot; example:&quot;000&quot;`</span></span><br><span class="line">    Message <span class="keyword">string</span>      <span class="string">`json:&quot;message&quot; example:&quot;请求信息&quot;`</span></span><br><span class="line">    Data    <span class="keyword">interface</span>&#123;&#125; <span class="string">`json:&quot;data&quot; `</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们在对 <code>Result</code> 中的 <code>tag</code> 会有 <code>example</code> ,这个仍旧是 <code>swagger</code> 的标签，用来给该结构体一个示例。</p>
<p>同理，我们可以对之前的 <code>article</code> 进行注释。</p>
<p>当我们完成了所有的代码注释时，在控制台中重新执行 <code>swag init</code>，它会根据我们的注释生成 <code>docs.go</code> 及其对应的 json 和 yaml 文件。</p>
<p>启动我们的项目，访问 <code>http://localhost:8080/swagger/index.html</code> 就可以查看我们的文档,效果如下</p>
<p><img src="/images/swagger_demo.png" alt="效果图"></p>
]]></content>
      <categories>
        <category>go</category>
        <category>gin</category>
      </categories>
      <tags>
        <tag>gin</tag>
        <tag>swageer</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 语言学习笔记 Gin框架(四)</title>
    <url>/2020/08/06/Go-%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Gin%E6%A1%86%E6%9E%B6-%E5%9B%9B/</url>
    <content><![CDATA[<h1 id="gin获取请求的参数信息"><a href="#gin获取请求的参数信息" class="headerlink" title="gin获取请求的参数信息"></a>gin获取请求的参数信息</h1><p>【注】c 就是func中的参数(c  *gin.Contex)</p>
<h2 id="1-从uri-path中获取"><a href="#1-从uri-path中获取" class="headerlink" title="[1].从uri-path中获取"></a>[1].从uri-path中获取</h2><p>请求:</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">curl -X GET \</span><br><span class="line">  http://localhost:8080/v1/order/1 \</span><br><span class="line">  -H &#x27;Postman-Token: e4d0bf85-df6b-4ab0-bcca-1feb5a76f531&#x27; \</span><br><span class="line">  -H &#x27;cache-control: no-cache&#x27;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>获取uri-path参数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">id:=c.Param(<span class="string">&quot;id&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="2-从parameters中获取"><a href="#2-从parameters中获取" class="headerlink" title="[2].从parameters中获取"></a>[2].从parameters中获取</h2><p>请求：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -X GET \</span><br><span class="line">  http://localhost:8080/v1/order?firstname=Jack&amp;lastname=ma \</span><br><span class="line">  -H &#x27;Postman-Token: e4d0bf85-df6b-4ab0-bcca-1feb5a76f531&#x27; \</span><br><span class="line">  -H &#x27;cache-control: no-cache&#x27;  </span><br></pre></td></tr></table></figure>

<p>获取parameters参数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">firstName := c.DefaultQuery(<span class="string">&quot;firstName&quot;</span>, <span class="string">&quot;Guest&quot;</span>)  <span class="comment">//如果读取不到firstName会给赋值一个默认的值 Guest</span></span><br><span class="line">lastName := c.Query(<span class="string">&quot;lastName&quot;</span>)<span class="comment">// 读取 lastName的值，如果读取不到返回空字符串</span></span><br><span class="line"><span class="comment">// c.Query(&quot;lastname&quot;) 等价于 c.Request.URL.Query().Get(&quot;lastname&quot;)</span></span><br></pre></td></tr></table></figure>

<h2 id="3-从Multipart-Urlencoded-Form中获取"><a href="#3-从Multipart-Urlencoded-Form中获取" class="headerlink" title="[3].从Multipart/Urlencoded Form中获取"></a>[3].从Multipart/Urlencoded Form中获取</h2><p>请求:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -X POST \</span><br><span class="line">  &#x27;http://localhost:8080/v1/order/1/10010?pkg=test.1&#x27; \</span><br><span class="line">  -H &#x27;Postman-Token: 49319e4b-fd9a-416e-a69b-5ffb54b12413&#x27; \</span><br><span class="line">  -H &#x27;cache-control: no-cache&#x27; \</span><br><span class="line">  -H &#x27;content-type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW&#x27; \</span><br><span class="line">  -F message=msg</span><br></pre></td></tr></table></figure>

<p>获取Multipart/Urlencoded Form参数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">message := c.PostForm(<span class="string">&quot;message&quot;</span>) <span class="comment">// 读取 message的值，如果读取不到返回空字符串</span></span><br><span class="line">nick := c.DefaultPostForm(<span class="string">&quot;nick&quot;</span>, <span class="string">&quot;anonymous&quot;</span>) <span class="comment">// 读取nick的值，如果读取不到会给nick赋默认值anonymous</span></span><br></pre></td></tr></table></figure>

<h2 id="4-从parameter-form-读取map或者array"><a href="#4-从parameter-form-读取map或者array" class="headerlink" title="[4].从parameter/form 读取map或者array"></a>[4].从parameter/form 读取map或者array</h2><p>请求:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -X PUT \</span><br><span class="line">  &#x27;http://localhost:8080/v1/order/1?idMap[a]=aaa&amp;idMap[b]=bbb&amp;idArr=c1,c2&#x27; \</span><br><span class="line">  -H &#x27;Content-Type: application/x-www-form-urlencoded&#x27; \</span><br><span class="line">  -H &#x27;Postman-Token: a2f3a545-3b19-4a5d-a542-8b83c19ee2f9&#x27; \</span><br><span class="line">  -H &#x27;cache-control: no-cache&#x27; \</span><br><span class="line">  -d &#x27;nameArr=name1&amp;nameArr=name2&amp;nameMap%5Ba%5D=namea&amp;nameMap%5Bb%5D=nameb&amp;undefined=&#x27;</span><br></pre></td></tr></table></figure>



<p>从parameter获取map,array,从application/x-www-form-urlencoded body中获取map array</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">idMap := c.QueryMap(<span class="string">&quot;idMap&quot;</span>) <span class="comment">//从paramter获取map</span></span><br><span class="line">idArr := c.QueryArray(<span class="string">&quot;idArr&quot;</span>)<span class="comment">//从paramter获取array</span></span><br><span class="line">nameArr := c.PostFormArray(<span class="string">&quot;nameArr&quot;</span>) <span class="comment">// 从form获取map</span></span><br><span class="line">nameMap := c.PostFormMap(<span class="string">&quot;nameMap&quot;</span>)<span class="comment">// 从form获取array</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>go</category>
        <category>gin</category>
      </categories>
      <tags>
        <tag>gin</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang小技巧-自定义三元表达式</title>
    <url>/2020/10/15/Golang%E5%B0%8F%E6%8A%80%E5%B7%A7-%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%89%E5%85%83%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>三元表达式的介绍在这里:</p>
<ul>
<li><a href="http://en.wikipedia.org/wiki/%3F">http://en.wikipedia.org/wiki/%3F</a>:</li>
<li><a href="http://en.wikipedia.org/wiki/IIf">http://en.wikipedia.org/wiki/IIf</a></li>
</ul>
<p>Go语言明确不支持三元表达式，这里是相关的讨论：<br><a href="https://groups.google.com/d/msg/golang-nuts/dbyqx_LGUxM/tLFFSXSfOdQJ">https://groups.google.com/d/msg/golang-nuts/dbyqx_LGUxM/tLFFSXSfOdQJ</a></p>
<p>官方FAQ的说明在这里：<br><a href="http://golang.org/doc/faq#Does_Go_have_a_ternary_form">http://golang.org/doc/faq#Does_Go_have_a_ternary_form</a></p>
<p>官方FAQ推荐的做法是用 <code>if</code> 代替：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> expr &#123;</span><br><span class="line">    n = trueVal</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    n = falseVal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过用 <code>if</code> 的问题是变量 <code>n</code> 有作用域问题.<br>我们需要在 <code>if</code> 之前先定义变量 <code>n</code>，这样才可以在 <code>if</code> 语句之后使用变量 <code>n</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> n <span class="keyword">int</span></span><br><span class="line"><span class="keyword">if</span> expr &#123;</span><br><span class="line">    n = trueVal</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    n = falseVal</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println</span>(n)</span><br></pre></td></tr></table></figure>

<p>本来一个简单的 <code>n := expr? trueVal: falseVal</code> 就能够表达的问题，变的复杂了很多。<br>这和Go所追求的简单思路是有冲突的。</p>
<p>类似的有 <code>max</code>/<code>min</code> 等函数。因为这类函数使用频度比较高，在很多pkg的内部都定义了私有的实现。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>熟悉Go语言的用户应该可以发现，这个 <code>max</code> 只支持 <code>int</code> 类型。<br>对于支持泛型的C++语言来说，<code>max</code> 一般被实现为一个模板函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">template &lt;class T&gt;</span><br><span class="line"><span class="keyword">const</span> T&amp; max (<span class="keyword">const</span> T&amp; a, <span class="keyword">const</span> T&amp; b) &#123;</span><br><span class="line">    <span class="keyword">return</span> (a&lt;b)?b:a;     <span class="comment">// or: return comp(a,b)?b:a; for version (2)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在C++版本中，不仅用到的泛型<code>T</code>，还依赖 <code>a&lt;b</code> 的运算符重载特性。<br>在C语言中，虽然没有泛型和运算符重载，但是三元表达式也具备全部的特性（因为表达式天生就是支持泛型的）。</p>
<p>而这些都是Go语言中缺少的特性。<br>不过在Go语言中可以模拟一个更普通的函数(<code>If</code> 的首字母大写，是函数名，不是 <code>if</code> 关键字)：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">If</span><span class="params">(condition <span class="keyword">bool</span>, trueVal, falseVal <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    <span class="keyword">if</span> condition &#123;</span><br><span class="line">        <span class="keyword">return</span> trueVal</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> falseVal</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a, b := <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">max := If(a &gt; b, a, b).(<span class="keyword">int</span>)</span><br><span class="line"><span class="built_in">println</span>(max)</span><br></pre></td></tr></table></figure>

<p>有几个关键点：</p>
<ul>
<li>Go不支持运算符重载，因此需要先将 <code>a&lt;b</code> 在函数外转换为 <code>bool</code> 条件</li>
<li>Go不支持泛型，只能用 <code>interface&#123;&#125;</code> 模拟</li>
<li>返回的类型安全需要用户自己保证，<code>.(type)</code> 的类型必须匹配</li>
<li><code>interface&#123;&#125;</code> 是运行时泛型，性能没有编译时泛型高</li>
</ul>
<p>由此可见，<code>?:</code> 不仅仅是一个简单的三元表达式。其实它更像一个内置的泛型版的函数（因为表达式天生就是支持泛型的）。</p>
<p>期望未来的Go版本中，能完善对 <code>?:</code> 三元表达式 和 编译时的泛型 的支持。</p>
<p>补充：<br>星星 同学的提示：可能会导致深入嵌套的滥用： <code>c?d?e?0:1:2:3</code> 。<br>因为三元表达式是一个表达式，必然是允许嵌套的。</p>
<p>不过我觉得嵌套不是问题的本质，函数也能导致嵌套的滥用。<br>但是不能因为滥用的行为来排斥有存在价值的语法（比如三元表达式）。</p>
]]></content>
  </entry>
  <entry>
    <title>algorithm-希尔排序</title>
    <url>/2020/08/07/algorithm-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="希尔排序的思路"><a href="#希尔排序的思路" class="headerlink" title="希尔排序的思路"></a>希尔排序的思路</h3><p><strong>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</strong></p>
<p>序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。</p>
<p><img src="https://images2015.cnblogs.com/blog/1024555/201611/1024555-20161128110416068-1421707828.png" alt="img"></p>
<p>上代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">    <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> length = <span class="number">15</span></span><br><span class="line">    <span class="keyword">var</span> list []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以时间戳为种子生成随机数，保证每次运行数据不重复</span></span><br><span class="line">    r := rand.New(rand.NewSource(time.Now().UnixNano()))</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length; i++ &#123;</span><br><span class="line">        list = <span class="built_in">append</span>(list, <span class="keyword">int</span>(r.Intn(<span class="number">1000</span>)))</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(list)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里就以n/2为增量z</span></span><br><span class="line">    gap := <span class="number">2</span></span><br><span class="line">    step := length / gap</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> step &gt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="comment">// 这里按步长开始每个分组的排序</span></span><br><span class="line">        <span class="keyword">for</span> i := step; i &lt; length; i++ &#123;</span><br><span class="line">            <span class="comment">// 将按步长分组的子队列用直接插入排序算法进行排序</span></span><br><span class="line">            insertionSortByStep(list, step)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 完成一轮后再次缩小增量</span></span><br><span class="line">        step /= gap</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出每轮缩小增量各组排序后的结果</span></span><br><span class="line">        fmt.Println(list)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里把上篇直接选择排序的算法抽出来，并将步长从1改成step</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertionSortByStep</span><span class="params">(tree []<span class="keyword">int</span>, step <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := step; i &lt; <span class="built_in">len</span>(tree); i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := i; j &gt;= step &amp;&amp; tree[j] &lt; tree[j-step]; j -= step &#123;</span><br><span class="line">            tree[j], tree[j-step] = tree[j-step], tree[j]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><p>最坏情况：O($ \log n^2$)<br>最好情况:    O($ \log 2n$)<br>平均情况：  O($ \log 2/3n$)  </p>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>因为没有借助额外的空间 空间浮渣度为<code>O(1)</code></p>
<p>Shell排序比冒泡排序快5倍，比插入排序大致快2倍。Shell排序比起QuickSort，MergeSort，HeapSort慢很多。但是它相对比较简单，它适合于数据量在5000以下并且速度并不是特别重要的场合。它对于数据量较小的数列重复排序是非常好的。</p>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>sort</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>希尔排序</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang疑问 Use of new vs var in Go</title>
    <url>/2020/10/13/Golang%E7%96%91%E9%97%AE-Use-of-new-vs-var-in-Go/</url>
    <content><![CDATA[<p><strong>Q： Is there any difference between:</strong></p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b bar</span><br><span class="line">foo(&amp;b)</span><br></pre></td></tr></table></figure>

<p>and</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">b := <span class="built_in">new</span>(bar)</span><br><span class="line">foo(b)</span><br></pre></td></tr></table></figure>

<p>The use of new creates an allocation.</p>
<p><strong>A： No, there is no difference, as, contrary to C, Go explicitly states that you can give a pointer to a locally created variable.</strong></p>
]]></content>
  </entry>
  <entry>
    <title>algorithm-归并排序</title>
    <url>/2020/08/07/algorithm-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="归并排序的思路"><a href="#归并排序的思路" class="headerlink" title="归并排序的思路"></a>归并排序的思路</h3><p>将一排数据，进行左右不断地进行划分（递[归]），然后再对比左右两边的数据后再(合[并])，这就是”归并排序“。</p>
<blockquote>
<p>注意：[左右]对比，是指左的第一个元素，与右边的第一个元素进行对比，哪个小，就先放到结果的第一位，然后左或右取出了元素的那边的索引进行++，没有取出的元素的，则不用进行++。 比较完后，还要分别将左，右的剩余的元素，追加到结果列的后面</p>
</blockquote>
<h2 id="归并排序-MergeSort"><a href="#归并排序-MergeSort" class="headerlink" title="归并排序(MergeSort)"></a>归并排序(MergeSort)</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">import <span class="string">&quot;time&quot;</span></span><br><span class="line">import number <span class="string">&quot;github.com/emacsist/go-common/helper/number&quot;</span></span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    data := number.GenerateInt(100000, 100000)</span><br><span class="line">    start := makeTimestamp()</span><br><span class="line">    // fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, data)</span><br><span class="line">    data = mergeSort(data)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;cost %v ms \n&quot;</span>, makeTimestamp()-start)</span><br><span class="line">    // fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">func makeTimestamp() int64 &#123;</span><br><span class="line">    <span class="built_in">return</span> time.Now().UnixNano() / int64(time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func mergeSort(data []int) []int &#123;</span><br><span class="line">    <span class="keyword">if</span> len(data) &lt;= 1 &#123;</span><br><span class="line">        <span class="built_in">return</span> data</span><br><span class="line">    &#125;</span><br><span class="line">    //递[归]</span><br><span class="line">    middle := len(data) / 2</span><br><span class="line">    //不断地进行左右对半划分</span><br><span class="line">    left := mergeSort(data[:middle])</span><br><span class="line">    right := mergeSort(data[middle:])</span><br><span class="line">    //合[并]</span><br><span class="line">    <span class="built_in">return</span> merge(left, right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func merge(left, right []int) (result []int) &#123;</span><br><span class="line">    l, r := 0, 0</span><br><span class="line"></span><br><span class="line">    // 注意：[左右]对比，是指左的第一个元素，与右边的第一个元素进行对比，哪个小，就先放到结果的第一位，然后左或右取出了元素的那边的索引进行++</span><br><span class="line">    <span class="keyword">for</span> l &lt; len(left) &amp;&amp; r &lt; len(right) &#123;</span><br><span class="line">        //从小到大排序.</span><br><span class="line">        <span class="keyword">if</span> left[l] &gt; right[r] &#123;</span><br><span class="line">            result = append(result, right[r])</span><br><span class="line">            //因为处理了右边的第r个元素，所以r的指针要向前移动一个单位</span><br><span class="line">            r++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = append(result, left[l])</span><br><span class="line">            //因为处理了左边的第l个元素，所以l的指针要向前移动一个单位</span><br><span class="line">            l++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 比较完后，还要分别将左，右的剩余的元素，追加到结果列的后面(不然就漏咯）。</span><br><span class="line">    result = append(result, left[l:]...)</span><br><span class="line">    result = append(result, right[r:]...)</span><br><span class="line">    <span class="built_in">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><p>假设解决最后的子问题用时为常数c，则对于n个待排序记录来说整个问题的规模为<code>cn</code>。</p>
<p><img src="https://img-blog.csdn.net/20170909101802866?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMzYzMDY0NzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>从这个递归树可以看出，第一层时间代价为cn，第二层时间代价为<code>cn/2+cn/2=cn…..</code>每一层代价都是<code>cn</code>，总共有<code>logn+1</code>层。所以总的时间代价为<code>cn*(logn+1)</code>.时间复杂度是<code>o(nlogn)</code>.</p>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>需要使用辅助数组的长度和待排序的数组相同 ，因此空间复杂度还是<code>O(n)</code></p>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>sort</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>sort</tag>
        <tag>归并排序</tag>
      </tags>
  </entry>
  <entry>
    <title>algorithm-插入排序</title>
    <url>/2020/08/07/algorithm-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="插入排序的思路"><a href="#插入排序的思路" class="headerlink" title="插入排序的思路"></a>插入排序的思路</h3><p>它的基本思想是将一个记录<strong>插入</strong>到已经排好序的有序表中，从而一个新的、记录数增1的有序表。</p>
<p>直接的例子就是玩扑克的时候，想象一下，分牌的时候，大家轮流的从一组牌中抽取最上面的一张，然后将它以某种顺序插入到我们的左手中。比如，我们想要从小到大排列我们的扑克牌。</p>
<p>标准方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertionSort</span><span class="params">(data []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    lo, hi := <span class="number">0</span>, <span class="built_in">len</span>(data) <span class="comment">// 获取数组的长度</span></span><br><span class="line">    <span class="keyword">for</span> i := lo + <span class="number">1</span>; i &lt; hi; i++ &#123; <span class="comment">// </span></span><br><span class="line">        <span class="keyword">for</span> j := i; j &gt; lo &amp;&amp; data[j] &lt; data[j<span class="number">-1</span>]; j-- &#123;</span><br><span class="line">            data[j], data[j<span class="number">-1</span>] = data[j<span class="number">-1</span>], data[j]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这种方法 就是如果后面有一个需要前插操作的数值，找到指定位置之后还会继续和它前面的数值进行比较，针对这一点我们可以优化一下</p>
<p>优化一：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertionSort</span><span class="params">(data []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    lo, hi= <span class="number">0</span>, <span class="built_in">len</span>(data)</span><br><span class="line">    <span class="keyword">for</span> i := lo + <span class="number">1</span>; i &lt; hi; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := i; j &gt; lo; j-- &#123;</span><br><span class="line">            <span class="keyword">if</span>  data[j] &lt; data[j<span class="number">-1</span>]&#123;</span><br><span class="line">                data[j], data[j<span class="number">-1</span>] = data[j<span class="number">-1</span>], data[j]</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><p>在最坏情况下，数组完全逆序，插入第2个元素时要考察前1个元素，插入第3个元素时，要考虑前2个元素，……，插入第N个元素，要考虑前 <code>N - 1</code> 个元素。因此，最坏情况下的比较次数是 <code>1 + 2 + 3 + ... + (N - 1)</code>，等差数列求和，结果为 <code>N^2 / 2</code>，所以最坏情况下的复杂度为 <code>O(N^2)</code>。</p>
<p>最好情况下，数组已经是有序的，每插入一个元素，只需要考查前一个元素，因此最好情况下，插入排序的时间复杂度为<code>O(N)</code>。</p>
<p>平均时间复杂度  <code>(O(N^2)+O(n))/2=O(n^2)</code></p>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>因为没有借助额外的空间 空间浮渣度为<code>O(1)</code></p>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>sort</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>sort</tag>
        <tag>插入排序</tag>
      </tags>
  </entry>
  <entry>
    <title>aws-搭建eks</title>
    <url>/2020/08/26/aws-%E6%90%AD%E5%BB%BAeks/</url>
    <content><![CDATA[<h1 id="安装eks环境"><a href="#安装eks环境" class="headerlink" title="安装eks环境"></a>安装eks环境</h1><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><h3 id="1-1-创建eks-cluster-使用命令行创建-然后控制台会刷新出来"><a href="#1-1-创建eks-cluster-使用命令行创建-然后控制台会刷新出来" class="headerlink" title="1.1 创建eks-cluster [使用命令行创建 然后控制台会刷新出来]"></a>1.1 创建eks-cluster [使用命令行创建 然后控制台会刷新出来]</h3> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">aws eks create-cluster --name richard_test1 --kubernetes-version 1.16 \</span><br><span class="line">          --role-arn arn:aws:iam::xxxx:role/eksctl-eks-ap-1-cluster-ServiceRole-MWM2SUSZU1OQ \</span><br><span class="line">          --resources-vpc-config subnetIds=subnet-xxx,subnet-xxx,endpointPublicAccess=false,endpointPrivateAccess=true \</span><br><span class="line">          --logging &#x27;&#123;&quot;clusterLogging&quot;:[&#123;&quot;types&quot;:[&quot;api&quot;,&quot;audit&quot;,&quot;authenticator&quot;,&quot;controllerManager&quot;,&quot;scheduler&quot;],&quot;enabled&quot;:false&#125;]&#125;&#x27;</span><br></pre></td></tr></table></figure>

<ul>
<li><input disabled="" type="checkbox"> 可以指定 –kubernetes-version   现在1.16已经要过时了 安装之后也需要升级</li>
<li><input disabled="" type="checkbox"> 需要修改name 和子网</li>
<li><input disabled="" type="checkbox"> 在某个跳板机上如果搭建多个cluster 最好在不同的用户下面来搭建</li>
<li><input disabled="" type="checkbox"> 在指定的用户下需要接着在aws configure 中设置region</li>
</ul>
<h3 id="1-2-安装kuberctl-二进制文件"><a href="#1-2-安装kuberctl-二进制文件" class="headerlink" title="1.2 安装kuberctl 二进制文件"></a>1.2 <a href="https://kubernetes.io/docs/tasks/tools/install-kubectl/#install-kubectl-binary-with-curl-on-linux">安装kuberctl 二进制文件</a></h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -LO https://storage.googleapis.com/kubernetes-release/release/`curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt`/bin/linux/arm64/kubectl</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>  然后需要将二进制文件添加到PATH中 详情参照<a href="https://docs.aws.amazon.com/zh_cn/eks/latest/userguide/install-kubectl.html">https://docs.aws.amazon.com/zh_cn/eks/latest/userguide/install-kubectl.html</a> </p>
<h4 id="1-3-安装kubeconfig"><a href="#1-3-安装kubeconfig" class="headerlink" title="1.3 安装kubeconfig"></a>1.3 <a href="https://docs.aws.amazon.com/zh_cn/eks/latest/userguide/create-kubeconfig.html">安装kubeconfig</a></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">aws eks --region region-code update-kubeconfig --name cluster_name</span><br></pre></td></tr></table></figure>

<p>检测配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get svc</span><br><span class="line">NAME         TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">kubernetes   ClusterIP   172.20.0.1   &lt;none&gt;        443/TCP   30m</span><br></pre></td></tr></table></figure>

<p> 注意 如果没有结果 很有可能就是cluster 安全组的问题  </p>
<table>
<thead>
<tr>
<th align="left"><strong>Type</strong></th>
<th align="left"><strong>Protocol</strong></th>
<th align="left"><strong>Port range</strong></th>
<th align="left"><strong>Source</strong></th>
<th align="left"><strong>Description - optional</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">All traffic</td>
<td align="left">All</td>
<td align="left">All</td>
<td align="left">xx.xxx.0.0/16</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">All traffic</td>
<td align="left">All</td>
<td align="left">All</td>
<td align="left">Sg-xxx (eks-cluster-sg-richard_test1-212947049)</td>
<td align="left">-</td>
</tr>
</tbody></table>
<p>xx.xxx.0.0/16 根据子网来设定</p>
<h4 id="1-4-创建-alb-ingress-controller"><a href="#1-4-创建-alb-ingress-controller" class="headerlink" title="1.4 创建 alb ingress controller"></a>1.4 创建 alb ingress controller</h4><p>主要是下面几步</p>
<ol>
<li><p>部署 AWS ALB Ingress 控制器需要的 RBAC Roles 和 RoleBindings：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/kubernetes-sigs/aws-alb-ingress-controller/v1.0.0/docs/examples/rbac-role.yaml </span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>将 AWS ALB Ingress 控制器 YAML 下载到本地文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -sS &quot;https://raw.githubusercontent.com/kubernetes-sigs/aws-alb-ingress-controller/v1.0.0/docs/examples/alb-ingress-controller.yaml&quot; &gt; alb-ingress-controller.yaml</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>编辑 AWS ALB Ingress 控制器 YAML t以包含 Kubernetes（或）Amazon EKS 集群的 clusterName。<br>将 –cluster-name 标记编辑为我们的 Kubernetes（或）Amazon EKS 集群的真实名称。</p>
</li>
<li><p>部署 AWS ALB Ingress 控制器 YAML： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl apply -f alb-ingress-controller.yaml</span><br></pre></td></tr></table></figure>
</li>
<li><p>验证部署成功，并且控制器已经启动：<br>kubectl logs -n kube-system $(kubectl get po -n kube-system | egrep -o alb-ingress[a-zA-Z0-9-]+)</p>
</li>
</ol>
]]></content>
      <categories>
        <category>aws</category>
        <category>eks</category>
      </categories>
      <tags>
        <tag>aws</tag>
        <tag>eks</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s--pod的状态为evicted</title>
    <url>/2020/08/07/beego%20orm%E6%93%8D%E4%BD%9C(%E4%B8%80)/</url>
    <content><![CDATA[<h3 id="遇到问题–k8s–pod的状态为evicted"><a href="#遇到问题–k8s–pod的状态为evicted" class="headerlink" title="遇到问题–k8s–pod的状态为evicted"></a>遇到问题–k8s–pod的状态为evicted</h3><p>eviction，即驱赶的意思，意思是当节点出现异常时，kubernetes将有相应的机制驱赶该节点上的Pod。多见于资源不足时导致的驱赶。</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>排查资源和异常原因，防止新的驱赶产生。使用如下命令删除旧驱赶的遗留</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get pods | grep Evicted | awk &#x27;&#123;print $1&#125;&#x27; | xargs kubectl delete pod</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>charles-https 抓包</title>
    <url>/2020/08/28/charles-https-%E6%8A%93%E5%8C%85/</url>
    <content><![CDATA[<h3 id="1-获取PC的IP地址"><a href="#1-获取PC的IP地址" class="headerlink" title="1. 获取PC的IP地址"></a>1. 获取PC的IP地址</h3><p>在Charles<code>菜单栏 -&gt; Help -&gt; Local IP Address</code>中可以查看PC的IP地址。图示如下：</p>
<img src="/images/charles-https-%E6%8A%93%E5%8C%85/image-20200828161106090.png" alt="image-20200828161106090" style="zoom: 50%;" />



<p>也可以在Mac终端使用命令<code>ifconfig en1</code>查看PC的IP地址。图示如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mfxing  ifconfig en1</span><br><span class="line">en1: flags=8963&lt;UP,BROADCAST,SMART,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500</span><br><span class="line">    options=460&lt;TSO4,TSO6,CHANNEL_IO&gt;</span><br><span class="line">    ether 82:0e:72:47:b8:01</span><br><span class="line">    media: autoselect &lt;full-duplex&gt;</span><br><span class="line">    status: inactive</span><br></pre></td></tr></table></figure>



<h3 id="2-配置iPhone代理"><a href="#2-配置iPhone代理" class="headerlink" title="2. 配置iPhone代理"></a>2. 配置iPhone代理</h3><p>在iPhone的<code>设置 -&gt; 无线局域网 -&gt; 局域网信息(i) -&gt; 配置代理 -&gt; 手动</code>中配置代理，服务器输入框中填写PC的IP地址，端口输入框中填写Charles的代理端口（一般是8888）。图示如下：</p>
<img src="/images/charles-https-%E6%8A%93%E5%8C%85/7dff28a27b45adb7d3fecff3a085b315.jpg" alt="7dff28a27b45adb7d3fecff3a085b315" style="zoom:50%;" />



<p>具体的端口可以从Charles<code>菜单栏 -&gt; Proxy -&gt; Proxy Settings</code>中查看。图示如下：</p>
<img src="/images/charles-https-%E6%8A%93%E5%8C%85/image-20200828161401437.png" alt="image-20200828161401437" style="zoom:33%;" />



<p>iPhone代理配置完成后，Charles会弹出连接提示框，点击<code>Allow</code>之后即可使用Charles对从该iPhone发出的请求进行抓包了。图示如下：<img src="/images/charles-https-%E6%8A%93%E5%8C%85/image-20200828161524821.png" alt="image-20200828161524821"></p>
<h3 id="3-抓包HTTPS请求"><a href="#3-抓包HTTPS请求" class="headerlink" title="3. 抓包HTTPS请求"></a>3. 抓包HTTPS请求</h3><p>在配置iPhone代理完毕后，就可以通过Structure或者Sequence窗口预览HTTP请求的数据了。但由于HTTPS请求被加密过，预览请求时只能预览到乱码数据。要预览到HTTPS请求的数据明文，需要PC和iPhone安装证书授权。</p>
<h4 id="1-PC安装证书"><a href="#1-PC安装证书" class="headerlink" title="1) PC安装证书"></a>1) PC安装证书</h4><p>在Charles<code>菜单栏 -&gt; Help -&gt; SSL Proxying -&gt; Install Charles Root Certificate</code>中可以为PC安装证书，证书可以在Mac的钥匙串中查看。图示如下：</p>
<p><img src="/images/charles-https-%E6%8A%93%E5%8C%85/image-20200828161742347.png" alt="image-20200828161742347"></p>
<p>证书可以在Mac的钥匙串中查看，双击证书，将信任权限设定为<code>始终信任</code>。图示如下：</p>
<img src="/images/charles-https-%E6%8A%93%E5%8C%85/image-20200828161820758.png" alt="image-20200828161820758" style="zoom:33%;" />



<h4 id="2-iPhone安装证书"><a href="#2-iPhone安装证书" class="headerlink" title="2) iPhone安装证书"></a>2) iPhone安装证书</h4><p>在iPhone浏览器中访问<code>http://charlesproxy.com/getssl</code>可以下载证书并安装。此地址一般不会变化，可以在Charles<code>菜单栏 -&gt; Help -&gt; SSL Proxying -&gt; Install Charles Root Certificate on a Mobile Device or Remote Browser</code>中查看最新的官方证书下载地址。图示如下：</p>
<img src="/images/charles-https-%E6%8A%93%E5%8C%85/image-20200828161858697.png" alt="image-20200828161858697" style="zoom:50%;" />



<p>基于iOS的证书信任机制，在安装完成并信任证书后，需要到iPhone<code>设置 -&gt; 关于本机 -&gt; 证书信任设置</code>中启用根证书。图示如下：</p>
<img src="/images/charles-https-%E6%8A%93%E5%8C%85/635269d6c5f07cea0b29a7b859fe35b9.jpg" alt="635269d6c5f07cea0b29a7b859fe35b9" style="zoom:33%;" />



<p>这样，就可以使用Charles中抓包iPhone发出的HTTPS请求并预览明文数据了。</p>
<blockquote>
<p>抓包模拟器上的HTTPS请求需要点击<code>Install Charles Root Certificate in iOS Simulators</code>安装证书。</p>
</blockquote>
<h4 id="3-启动抓包SSL权限"><a href="#3-启动抓包SSL权限" class="headerlink" title="3) 启动抓包SSL权限"></a>3) 启动抓包SSL权限</h4><p>在Charles<code>菜单栏 -&gt; Proxy -&gt; SSL Proxying Settings</code>中勾选<code>Enable SSL Proxying</code>，然后在<code>Locations</code>中添加需要抓包的Host和Port即可。图示如下：</p>
<img src="/images/charles-https-%E6%8A%93%E5%8C%85/image-20200828162130663.png" alt="image-20200828162130663" style="zoom:33%;" />



<p>也可以在抓包界面，右键点击某条/组请求，在弹出的选项列表中点击<code>Enable SSL Proxying</code>启用权限。图示如下：</p>
<img src="/images/charles-https-%E6%8A%93%E5%8C%85/image-20200828162231644.png" alt="image-20200828162231644" style="zoom: 33%;" />





<p>基本的抓取到这里就完事了 </p>
<p>charles 还支持 <code>请求断点</code>、<code>数据修改</code>、<code>请求重发</code>、<code>网速模拟</code></p>
]]></content>
      <categories>
        <category>抓包</category>
      </categories>
      <tags>
        <tag>抓包</tag>
        <tag>charles</tag>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title>curl的使用</title>
    <url>/2020/09/01/curl-%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="查看响应头"><a href="#查看响应头" class="headerlink" title="查看响应头"></a>查看响应头</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> curl -v http://localhost:8080?uid=102 </span><br><span class="line">*   Trying ::1...</span><br><span class="line">* TCP_NODELAY set</span><br><span class="line">* Connected to localhost (::1) port 8080 (#0)</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> GET /?uid=102 HTTP/1.1</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Host: localhost:8080</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> User-Agent: curl/7.64.1</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Accept: */*</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line">&lt; HTTP/1.1 200 OK</span><br><span class="line">&lt; Content-Type: application/json;charset=utf-8</span><br><span class="line">&lt; Date: Mon, 31 Aug 2020 14:07:32 GMT</span><br><span class="line">&lt; Content-Length: 19</span><br><span class="line">&lt; </span><br><span class="line">&#123;&quot;result&quot;:&quot;guest&quot;&#125;</span><br><span class="line">* Connection #0 to host localhost left intact</span><br><span class="line">* Closing connection 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<h2 id="查看请求头"><a href="#查看请求头" class="headerlink" title="查看请求头"></a>查看请求头</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mfxing  curl  http://localhost:8080?uid=102 -i</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json;charset=utf-8</span><br><span class="line">Date: Mon, 31 Aug 2020 14:10:37 GMT</span><br><span class="line">Content-Length: 19</span><br><span class="line"></span><br><span class="line">&#123;&quot;result&quot;:&quot;guest&quot;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>linux</tag>
        <tag>curl</tag>
      </tags>
  </entry>
  <entry>
    <title>curl-请求带用户名和密码</title>
    <url>/2020/09/06/curl-%E8%AF%B7%E6%B1%82%E5%B8%A6%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<h3 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h3><p>我想访问一个需要用户名/密码的URL。我想尝试用 curl 来访问它。现在我正在做一些事情： </p>
<p><a href="http://localhost:9200/">http://localhost:9200/</a>  因为es服务开启安全认证 需要填写用户名和密码</p>
<p>我收到一个错误。我想我需要指定一个用户名和密码以及上述命令。</p>
<h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><ol>
<li><p>使用<code>-u</code>标志来包含用户名，并且curl将提示输入密码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -u username http://example.com</span><br></pre></td></tr></table></figure>
</li>
<li><p>您也可以在命令中包含密码，但您的密码将在bash历史记录中显示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -u username:password http://example.com</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>您也可以通过写入发送用户名：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl http://username:password@api.somesite.com/test/blah?something=123</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>docker-启动elasticsearch</title>
    <url>/2020/09/06/docker-%E5%90%AF%E5%8A%A8elasticsearch-k8s/</url>
    <content><![CDATA[<h3 id="常用kuberctl-命令"><a href="#常用kuberctl-命令" class="headerlink" title="常用kuberctl 命令"></a>常用kuberctl 命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl delete -f es-config-map.yml  # 删除es-config map</span><br><span class="line"></span><br><span class="line">kubectl apply -f es-config-map.yml   # 创建es-config map</span><br><span class="line"></span><br><span class="line">kubectl delete -f es-statefulset.yml  # 删除statefulset</span><br><span class="line"></span><br><span class="line">kubectl apply -f es-statefulset.yml  # 创建statefulset</span><br><span class="line"></span><br><span class="line">kubectl get pod -n es  # 查看es ns的pod</span><br><span class="line"></span><br><span class="line">kubectl logs --previous  # 查看之前的日志</span><br><span class="line"></span><br><span class="line">kubectl get pod --all-namespaces -o wide  # 查看所有pod的信息</span><br><span class="line"></span><br><span class="line">kubectl exec -it es-0 -- bash # 进入es-0 </span><br><span class="line"></span><br><span class="line">kubectl apply -f es-svc-in.yml # 创建service in</span><br><span class="line"></span><br><span class="line">kubectl apply -f es-svc-out.yml # 创建service out</span><br><span class="line"></span><br><span class="line">kubectl describe statefulset elasticsearch-master -n es</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="生成私钥和证书"><a href="#生成私钥和证书" class="headerlink" title="生成私钥和证书"></a>生成私钥和证书</h2><p>首先创建一个docker容器用于执行es命令。执行密钥生成以后，通过docker cp把密钥取出来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">docker exec  docker-esId  &#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;bin&#x2F;elasticsearch-certutil cert -out &#x2F;elastic-certificates.p12 -pass &quot;&quot;</span><br><span class="line"></span><br><span class="line">docker cp docker:&#x2F;elastic-certificates.p12 .&#x2F;</span><br></pre></td></tr></table></figure>

<p>验证</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl pkcs12 -nocerts -nodes -in  .&#x2F;elastic-certificates.p12 -info</span><br></pre></td></tr></table></figure>

<h2 id="配置elastic节点"><a href="#配置elastic节点" class="headerlink" title="配置elastic节点"></a>配置elastic节点</h2><p>将生成的密钥，存成k8s的的secret</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl -n es create secret generic es-keystore --from-file&#x3D;.&#x2F;elastic-certificates.p12</span><br></pre></td></tr></table></figure>

<h2 id="配置es集群-amp-kibana"><a href="#配置es集群-amp-kibana" class="headerlink" title="配置es集群&amp;kibana"></a>配置es集群&amp;kibana</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StatefulSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">elasticsearch</span></span><br><span class="line">    <span class="attr">role:</span> <span class="string">master</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">elasticsearch-master</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">es</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">serviceName:</span> <span class="string">elasticsearch-master</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">elasticsearch</span></span><br><span class="line">      <span class="attr">role:</span> <span class="string">master</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">elasticsearch</span></span><br><span class="line">        <span class="attr">role:</span> <span class="string">master</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">Always</span></span><br><span class="line">      <span class="attr">securityContext:</span></span><br><span class="line">        <span class="attr">fsGroup:</span> <span class="number">1000</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">elasticsearch-master</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">docker.elastic.co/elasticsearch/elasticsearch:7.5.0</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">          <span class="attr">securityContext:</span></span><br><span class="line">            <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">9200</span></span><br><span class="line">              <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">9200</span></span><br><span class="line">              <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">          <span class="attr">env:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cluster.name</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">&quot;es_cluster&quot;</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">node.master</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">node.data</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">&quot;false&quot;</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">discovery.seed_hosts</span> </span><br><span class="line">              <span class="attr">value:</span> <span class="string">&quot;elasticsearch-discovery&quot;</span> </span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cluster.initial_master_nodes</span> </span><br><span class="line">              <span class="attr">value:</span> <span class="string">&quot;elasticsearch-master-0,elasticsearch-master-1&quot;</span> </span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">node.ingest</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">&quot;false&quot;</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ES_JAVA_OPTS</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">&quot;-Xms500m -Xmx500m&quot;</span> </span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">xpack.security.enabled</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">&quot;false&quot;</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">xpack.security.transport.ssl.enabled</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">&quot;false&quot;</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">xpack.security.transport.ssl.verification_mode</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">&quot;certificate&quot;</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">xpack.security.transport.ssl.keystore.path</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">&quot;/usr/share/elasticsearch/config/elastic-certificates.p12&quot;</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">xpack.security.transport.ssl.truststore.path</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">&quot;/usr/share/elasticsearch/config/elastic-certificates.p12&quot;</span>                                                        </span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="comment"># - name: es-persistent-storage</span></span><br><span class="line">            <span class="comment">#   mountPath: /data</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/usr/share/elasticsearch/config/elastic-certificates.p12</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">keystore</span></span><br><span class="line">              <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">              <span class="attr">subPath:</span> <span class="string">elastic-certificates.p12</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">keystore</span></span><br><span class="line">          <span class="attr">secret:</span></span><br><span class="line">            <span class="attr">secretName:</span> <span class="string">es-keystore</span></span><br><span class="line">            <span class="attr">defaultMode:</span> <span class="number">0444</span> </span><br><span class="line">            </span><br><span class="line">              </span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"> <span class="attr">labels:</span></span><br><span class="line">   <span class="attr">app:</span> <span class="string">elasticsearch</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">elasticsearch-discovery</span></span><br><span class="line"> <span class="attr">namespace:</span> <span class="string">es</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"> <span class="attr">ports:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">9300</span></span><br><span class="line">     <span class="attr">targetPort:</span> <span class="number">9300</span></span><br><span class="line"> <span class="attr">selector:</span></span><br><span class="line">   <span class="attr">app:</span> <span class="string">elasticsearch</span></span><br><span class="line">   <span class="attr">role:</span> <span class="string">master</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">elasticsearch-data-service</span></span><br><span class="line"> <span class="attr">namespace:</span> <span class="string">es</span></span><br><span class="line"> <span class="attr">labels:</span></span><br><span class="line">   <span class="attr">app:</span> <span class="string">elasticsearch</span></span><br><span class="line">   <span class="attr">role:</span> <span class="string">data</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"> <span class="attr">ports:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">9200</span></span><br><span class="line">     <span class="attr">name:</span> <span class="string">outer</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">9300</span></span><br><span class="line">     <span class="attr">name:</span> <span class="string">inner</span></span><br><span class="line"> <span class="comment">#clusterIP: None</span></span><br><span class="line"> <span class="attr">selector:</span></span><br><span class="line">   <span class="attr">app:</span> <span class="string">elasticsearch</span></span><br><span class="line">   <span class="attr">role:</span> <span class="string">data</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StatefulSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">elasticsearch</span></span><br><span class="line">    <span class="attr">role:</span> <span class="string">master</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">elasticsearch-data</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">es</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">serviceName:</span> <span class="string">elasticsearch-data</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">elasticsearch</span></span><br><span class="line">      <span class="attr">role:</span> <span class="string">data</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">elasticsearch</span></span><br><span class="line">        <span class="attr">role:</span> <span class="string">data</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">Always</span></span><br><span class="line">      <span class="attr">securityContext:</span></span><br><span class="line">        <span class="attr">fsGroup:</span> <span class="number">1000</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">elasticsearch-data</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">docker.elastic.co/elasticsearch/elasticsearch:7.5.0</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">          <span class="attr">securityContext:</span></span><br><span class="line">            <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">9200</span></span><br><span class="line">              <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">9300</span></span><br><span class="line">              <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">          <span class="attr">env:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cluster.name</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">&quot;es_cluster&quot;</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">node.master</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">&quot;false&quot;</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">node.data</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">discovery.seed_hosts</span> <span class="comment"># </span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">&quot;elasticsearch-discovery&quot;</span> </span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cluster.initial_master_nodes</span> </span><br><span class="line">              <span class="attr">value:</span> <span class="string">&quot;elasticsearch-master-0,elasticsearch-master-1&quot;</span> </span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">node.ingest</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">&quot;false&quot;</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ES_JAVA_OPTS</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">&quot;-Xms500m -Xmx500m&quot;</span> </span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">xpack.security.enabled</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">&quot;false&quot;</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">xpack.security.transport.ssl.enabled</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">&quot;false&quot;</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">xpack.security.transport.ssl.verification_mode</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">&quot;certificate&quot;</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">xpack.security.transport.ssl.keystore.path</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">&quot;/usr/share/elasticsearch/config/elastic-certificates.p12&quot;</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">xpack.security.transport.ssl.truststore.path</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">&quot;/usr/share/elasticsearch/config/elastic-certificates.p12&quot;</span>                                                        </span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="comment"># - name: es-persistent-storage</span></span><br><span class="line">            <span class="comment">#   mountPath: /data</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/usr/share/elasticsearch/config/elastic-certificates.p12</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">keystore</span></span><br><span class="line">              <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">              <span class="attr">subPath:</span> <span class="string">elastic-certificates.p12</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">keystore</span></span><br><span class="line">          <span class="attr">secret:</span></span><br><span class="line">            <span class="attr">secretName:</span> <span class="string">es-keystore</span></span><br><span class="line">            <span class="attr">defaultMode:</span> <span class="number">0444</span> </span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kibana-config</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">es</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">kibana.yml:</span> <span class="string">|</span></span><br><span class="line">    <span class="attr">server.name:</span> <span class="string">kibana</span></span><br><span class="line">    <span class="attr">server.port:</span> <span class="number">5601</span></span><br><span class="line">    <span class="attr">server.host:</span> <span class="string">&quot;0.0.0.0&quot;</span></span><br><span class="line">    <span class="attr">xpack.monitoring.ui.container.elasticsearch.enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">elasticsearch.username:</span> <span class="string">kibana</span></span><br><span class="line">    <span class="attr">elasticsearch.password:</span> <span class="string">changeme</span></span><br><span class="line">    <span class="attr">xpack.security.enabled:</span> <span class="literal">false</span> <span class="comment"># es 改为白金模式是才去改成true</span></span><br><span class="line"><span class="comment"># kubectl apply -f kibana-config.yaml</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kibana</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">es</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kibana</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">LoadBalancer</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">5601</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="string">http</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kibana</span></span><br><span class="line"><span class="comment"># kubectl apply -f kibana-service.yaml</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kibana</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">es</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kibana</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">k8s-app:</span> <span class="string">kibana</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">k8s-app:</span> <span class="string">kibana</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kibana</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">docker.elastic.co/kibana/kibana:7.5.0</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">512Mi</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">512m</span></span><br><span class="line">          <span class="attr">limits:</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">512Mi</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">512m</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ELASTICSEARCH_HOSTS</span></span><br><span class="line">            <span class="attr">value:</span> <span class="string">http://elasticsearch-data-service:9200</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">5601</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">            <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">            <span class="attr">mountPath:</span> <span class="string">/usr/share/kibana/config/kibana.yml</span></span><br><span class="line">            <span class="attr">subPath:</span> <span class="string">kibana.yml</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">        <span class="attr">configMap:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">kibana-config</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>注意: k8s每次apply 如果对应的statefulset有改动都会重新生成一个新的container </p>
<p>部署成功之后 </p>
<ol>
<li><p>进入一个容器里 执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl localhost:9200/_xpack/license  # 查看证书</span><br><span class="line">curl localhost:9200/_cat/nodes  # 查看集群的节点情况</span><br></pre></td></tr></table></figure>
</li>
<li><p>导入证书</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 导入到docker 容器中</span></span><br><span class="line">docker cp ../richard-xing-5a2c6c4f-60bf-4471-8941-1d037364a2e3-v5.json 73c1a7be3e6e:/usr/share/elasticsearch/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 导入证书</span></span><br><span class="line">curl -XPUT -u elastic &#x27;http://localhost:9200/_xpack/license&#x27; -H &quot;Content-Type: application/json&quot; -d @richard-xing-5a2c6c4f-60bf-4471-8941-1d037364a2e3-v5.json</span><br></pre></td></tr></table></figure>
</li>
<li></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>docker-启动elasticsearch</title>
    <url>/2020/09/06/docker-%E5%90%AF%E5%8A%A8elasticsearch/</url>
    <content><![CDATA[<h3 id="准备环境-Set-vm-max-map-count-to-at-least-262144"><a href="#准备环境-Set-vm-max-map-count-to-at-least-262144" class="headerlink" title="准备环境 Set vm.max_map_count to at least 262144"></a>准备环境 Set <code>vm.max_map_count</code> to at least <code>262144</code></h3><ul>
<li><p>Linux</p>
<p>The <code>vm.max_map_count</code> setting should be set permanently in <code>/etc/sysctl.conf</code>:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">grep vm.max_map_count /etc/sysctl.conf</span><br><span class="line">vm.max_map_count=262144</span><br></pre></td></tr></table></figure>

<p>To apply the setting on a live system, run:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sysctl -w vm.max_map_count=262144</span><br></pre></td></tr></table></figure>
</li>
<li><p>macOS with <a href="https://docs.docker.com/docker-for-mac">Docker for Mac</a></p>
</li>
</ul>
<p>The <code>vm.max_map_count</code> setting must be set within the xhyve virtual machine:</p>
<ol>
<li><p>From the command line, run:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">screen ~/Library/Containers/com.docker.docker/Data/vms/0/tty</span><br></pre></td></tr></table></figure>
</li>
<li><p>Press enter and use<code>sysctl</code> to configure <code>vm.max_map_count</code>:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sysctl -w vm.max_map_count=262144</span><br></pre></td></tr></table></figure>
</li>
<li><p>To exit the <code>screen</code> session, type <code>Ctrl a d</code>.</p>
</li>
</ol>
<p>The <code>vm.max_map_count</code> kernel setting must be set to at least <code>262144</code> for production use.</p>
<p>How you set <code>vm.max_map_count</code> depends on your platform:</p>
<p>###docker启动elasticsearch</p>
<ol>
<li><p>pull the image</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull docker.elastic.co/elasticsearch/elasticsearch:7.9.1</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li>starting a single node cluster with docker</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; docker.elastic.co/elasticsearch/elasticsearch:7.9.1 </span><br></pre></td></tr></table></figure>





<p>将自己打包好的支持密码认证、破解之后的es推送到</p>
<ol>
<li>打包镜像</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker commit -a &quot;richard&quot; -m &quot;es 破解&quot; c4823af7ee60 coco2019/elasticsearch-7.5.0:v1 </span><br></pre></td></tr></table></figure>

<ol start="2">
<li>docker push coco2019/elasticsearch-7.5.0:v1</li>
</ol>
<p><img src="/images/docker-%E5%90%AF%E5%8A%A8elasticsearch/image-20200905195257681.png" alt="image-20200905195257681"></p>
<p><code>docker pull coco2019/elasticsearch-7.5.0:v1</code></p>
<ol start="3">
<li><p>执行docker 脚本运行elasticsearch 7.5.0</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line"> --name elasticsearch \</span><br><span class="line"> -v /data/elasticsearch:/usr/share/elasticsearch/data \</span><br><span class="line"> -e &quot;discovery.type=single-node&quot; \</span><br><span class="line"> -e &quot;xpack.security.enabled=true&quot; \</span><br><span class="line"> -e &quot;TZ=Asia/Shanghai&quot; \</span><br><span class="line"> -p 9200:9200 \</span><br><span class="line"> coco2019/elasticsearch-7.5.0:v1</span><br></pre></td></tr></table></figure>

<p>参数含义:</p>
<ul>
<li>-d ： 后台运行</li>
<li>–name 指定容器名称  elasticsearch</li>
<li>-v  docker容器中的/usr/share/elasticsearch/data 绑定宿主机的/data/elasticsearch</li>
<li>-e  设置环境变量 指定运行时的参数</li>
<li>-p 指定端口映射 容器内部端口映射到主机的端口</li>
</ul>
<p>启动之后 通过curl 验证</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl   http://elastic:cJQ98i4M0fPyaVkbw0WT@localhost:9200/</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> &#123;</span></span><br><span class="line">  &quot;name&quot; : &quot;0d8e8ed10863&quot;,</span><br><span class="line">  &quot;cluster_name&quot; : &quot;docker-cluster&quot;,</span><br><span class="line">  &quot;cluster_uuid&quot; : &quot;SY3ncYUgQESnqiwCUDaX3g&quot;,</span><br><span class="line">  &quot;version&quot; : &#123;</span><br><span class="line">    &quot;number&quot; : &quot;7.5.0&quot;,</span><br><span class="line">    &quot;build_flavor&quot; : &quot;default&quot;,</span><br><span class="line">    &quot;build_type&quot; : &quot;docker&quot;,</span><br><span class="line">    &quot;build_hash&quot; : &quot;e9ccaed468e2fac2275a3761849cbee64b39519f&quot;,</span><br><span class="line">    &quot;build_date&quot; : &quot;2019-11-26T01:06:52.518245Z&quot;,</span><br><span class="line">    &quot;build_snapshot&quot; : false,</span><br><span class="line">    &quot;lucene_version&quot; : &quot;8.3.0&quot;,</span><br><span class="line">    &quot;minimum_wire_compatibility_version&quot; : &quot;6.8.0&quot;,</span><br><span class="line">    &quot;minimum_index_compatibility_version&quot; : &quot;6.0.0-beta1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;tagline&quot; : &quot;You Know, for Search&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</li>
</ol>
<h3 id="Starting-a-multi-node-cluster-with-Docker-Compose"><a href="#Starting-a-multi-node-cluster-with-Docker-Compose" class="headerlink" title="Starting a multi-node cluster with Docker Compose"></a>Starting a multi-node cluster with Docker Compose</h3><ol>
<li><p>创建一个network</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker network create --driver bridge --subnet=192.168.236.0/16 --gateway=192.168.1.1 mynet</span><br></pre></td></tr></table></figure>

<p>查看网络信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker network inspect mynet</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">[</span></span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;mynet&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;daab682103e90baea3f6c07496819793e555306fd314f241a237a96a62a266aa&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2020-09-07T13:02:16.715965648Z&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;192.168.0.0/16&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;192.168.1.1&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Attachable&quot;: false,</span><br><span class="line">        &quot;Ingress&quot;: false,</span><br><span class="line">        &quot;ConfigFrom&quot;: &#123;</span><br><span class="line">            &quot;Network&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ConfigOnly&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>以后使用 –network=mynet –ip=192.168.1.x 指定ip </p>
</li>
<li><p>准备3个master节点</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for port in $(seq 1 3);\</span><br><span class="line">do \</span><br><span class="line">mkdir -p /Users/mengfanxing_g/elk/mydata/elasticsearch/master-$&#123;port&#125;/config</span><br><span class="line">mkdir -p /Users/mengfanxing_g/elk/mydata/elasticsearch/master-$&#123;port&#125;/data</span><br><span class="line">chmod -R 777 /Users/mengfanxing_g/elk/mydata/elasticsearch/master-$&#123;port&#125;</span><br><span class="line">cat &lt;&lt; EOF &gt; /Users/mengfanxing_g/elk/mydata/elasticsearch/master-$&#123;port&#125;/config/elasticsearch.yml</span><br><span class="line">cluster.name: my-es # 集群的名称 同一个集群改值必须设置成相同的</span><br><span class="line">node.name: es-mater-$&#123;port&#125; #改节点的名字</span><br><span class="line">node.master: true #该节点有机会成为master节点</span><br><span class="line">node.data: false # 该节点可以存储数据</span><br><span class="line">network.host: 0.0.0.0</span><br><span class="line">http.host: 0.0.0.0 # 所有http均可访问</span><br><span class="line">http.port: 920$&#123;port&#125;</span><br><span class="line">transport.tcp.port: 930$&#123;port&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">discovery.zen.mininum_master_nodes:2 <span class="comment">#设置这个参数来保证集权中的节点可有知道其它N个有master资格的节点。官方推荐（N/2)+1</span></span></span><br><span class="line">discovery.zen.ping_timeout: 10s # 设置集群自动发现其它节点时 ping连接的超时时间</span><br><span class="line">discovery.seed_hosts: [&quot;192.168.1.1:9301&quot;,&quot;192.168.1.1:9302&quot;,&quot;192.168.1.1:9303&quot;] #设置集群中master节点的初始列表，可以通过这些节点来自动发现其它新加入集群节点，es7的新增配置</span><br><span class="line">cluster.initial_master_nodes: [&quot;192.168.1.1&quot;] #新集群初始时的候选主节点，es的新增配置</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">docker run --name elasticsearch-node-$&#123;port&#125;  \</span><br><span class="line">-p 920$&#123;port&#125;:920$&#123;port&#125; -p 930$&#123;port&#125;:930$&#123;port&#125; \</span><br><span class="line">--network=mynet --ip 192.168.236.$&#123;port&#125; \</span><br><span class="line">-e ES_JAVA_OPTS=&quot;-Xms300m -Xmx300m&quot; \</span><br><span class="line">-e &quot;xpack.security.enabled=false&quot; \</span><br><span class="line">-v /Users/mengfanxing_g/elk/mydata/elasticsearch/master-$&#123;port&#125;/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml \</span><br><span class="line">-v /Users/mengfanxing_g/elk/mydata/elasticsearch/master-$&#123;port&#125;/data:/usr/share/elasticsearch/data \</span><br><span class="line">-v /Users/mengfanxing_g/elk/mydata/elasticsearch/master-$&#123;port&#125;/plugins:/usr/share/elasticsearch/plugins \</span><br><span class="line">-d docker.elastic.co/elasticsearch/elasticsearch:7.5.0 </span><br><span class="line">done </span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>docker-启动kibana</title>
    <url>/2020/09/06/docker-%E5%90%AF%E5%8A%A8kibana/</url>
    <content><![CDATA[<p>执行脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line"> --name kibana \</span><br><span class="line"> --link esnode1:elasticsearch \</span><br><span class="line"> -e &quot;ELASTICSEARCH_USERNAME=elastic&quot; \</span><br><span class="line"> -e &quot;ELASTICSEARCH_PASSWORD=cJQ98i4M0fPyaVkbw0WT&quot; \</span><br><span class="line"> -e &quot;TZ=Asia/Shanghai&quot; \</span><br><span class="line"> -p 5601:5601 \</span><br><span class="line"> kibana:7.5.0</span><br></pre></td></tr></table></figure>



]]></content>
  </entry>
  <entry>
    <title>docker-常用命令</title>
    <url>/2020/09/05/docker-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>1.停用全部运行中的容器:<br><code>docker stop $(docker ps -q)</code></p>
<p>2.删除全部容器：<br><code>docker rm $(docker ps -aq)</code></p>
<p>3.一条命令实现停用并删除容器：<br><code>docker stop (docker ps -q) &amp; docker rm(docker ps -q) &amp; docker rm(docker ps -aq)</code></p>
<p>4、删除所有镜像<br>docker rmi <code>docker images -q</code></p>
<p>5、按条件删除镜像<br>// 没有打标签<br>docker rmi <code>docker images -q | awk &#39;/^&lt;none&gt;/ &#123; print $3 &#125;&#39;</code></p>
<p>//　镜像名包含关键字<br>docker rmi –force <code>docker images | grep doss-api | awk &#39;&#123;print $3&#125;&#39;</code> //其中doss-api为关键字</p>
]]></content>
  </entry>
  <entry>
    <title>docker-常用命令及相关参数</title>
    <url>/2020/09/06/docker-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<p><strong>docker run ：</strong>创建一个新的容器并运行一个命令</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure>

<p>OPTIONS说明：</p>
<ul>
<li><strong>-a stdin:</strong> 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；</li>
<li><strong>-d:</strong> 后台运行容器，并返回容器ID；</li>
<li><strong>-i:</strong> 以交互模式运行容器，通常与 -t 同时使用；</li>
<li><strong>-P:</strong> 随机端口映射，容器内部端口<strong>随机</strong>映射到主机的端口</li>
<li><strong>-p:</strong> 指定端口映射，格式为：<strong>主机(宿主)端口:容器端口</strong></li>
<li><strong>-t:</strong> 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</li>
<li><strong>–name=”nginx-lb”:</strong> 为容器指定一个名称；</li>
<li><strong>–dns 8.8.8.8:</strong> 指定容器使用的DNS服务器，默认和宿主一致；</li>
<li><strong>–dns-search example.com:</strong> 指定容器DNS搜索域名，默认和宿主一致；</li>
<li><strong>-h “mars”:</strong> 指定容器的hostname；</li>
<li><strong>-e username=”ritchie”:</strong> 设置环境变量；</li>
<li><strong>–env-file=[]:</strong> 从指定文件读入环境变量；</li>
<li><strong>–cpuset=”0-2” or –cpuset=”0,1,2”:</strong> 绑定容器到指定CPU运行；</li>
<li>**-m :**设置容器使用内存最大值；</li>
<li><strong>–net=”bridge”:</strong> 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；</li>
<li><strong>–link=[]:</strong> 添加链接到另一个容器；</li>
<li><strong>–expose=[]:</strong> 开放一个端口或一组端口；</li>
<li><strong>–volume , -v:</strong> 绑定一个卷</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>使用docker镜像nginx:latest以后台模式启动一个容器,并将容器命名为mynginx。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name mynginx -d nginx:latest</span><br></pre></td></tr></table></figure>

<p>使用镜像nginx:latest以后台模式启动一个容器,并将容器的80端口映射到主机随机端口。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -P -d nginx:latest</span><br></pre></td></tr></table></figure>

<p>使用镜像 nginx:latest，以后台模式启动一个容器,将容器的 80 端口映射到主机的 80 端口,主机的目录 /data 映射到容器的 /data。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -p 80:80 -v /data:/data -d nginx:latest</span><br></pre></td></tr></table></figure>

<p>绑定容器的 8080 端口，并将其映射到本地主机 127.0.0.1 的 80 端口上。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -p 127.0.0.1:80:8080/tcp ubuntu bash</span></span><br></pre></td></tr></table></figure>

<p>使用镜像nginx:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker run -it nginx:latest /bin/bash</span><br><span class="line">root@b8573233d675:/# </span><br></pre></td></tr></table></figure>



<p>参数拓展：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Usage: docker run [OPTIONS] IMAGE [COMMAND] [ARG...]    </span><br><span class="line"><span class="number">02.</span>  </span><br><span class="line"><span class="number">03.</span>  -d, --detach=<span class="literal">false</span>         指定容器运行于前台还是后台，默认为<span class="literal">false</span>     </span><br><span class="line"><span class="number">04.</span>  -i, --interactive=<span class="literal">false</span>   打开STDIN，用于控制台交互    </span><br><span class="line"><span class="number">05.</span>  -t, --tty=<span class="literal">false</span>            分配tty设备，该可以支持终端登录，默认为<span class="literal">false</span>    </span><br><span class="line"><span class="number">06.</span>  -u, --user=<span class="string">&quot;&quot;</span>              指定容器的用户    </span><br><span class="line"><span class="number">07.</span>  -a, --attach=[]            登录容器（必须是以docker run -d启动的容器）  </span><br><span class="line"><span class="number">08.</span>  -w, --workdir=<span class="string">&quot;&quot;</span>           指定容器的工作目录   </span><br><span class="line"><span class="number">09.</span>  -c, --cpu-shares=<span class="number">0</span>        设置容器CPU权重，在CPU共享场景使用    </span><br><span class="line"><span class="number">10.</span>  -e, --env=[]               指定环境变量，容器中可以使用该环境变量    </span><br><span class="line"><span class="number">11.</span>  -m, --memory=<span class="string">&quot;&quot;</span>            指定容器的内存上限    </span><br><span class="line"><span class="number">12.</span>  -P, --publish-all=<span class="literal">false</span>    指定容器暴露的端口    </span><br><span class="line"><span class="number">13.</span>  -p, --publish=[]           指定容器暴露的端口   </span><br><span class="line"><span class="number">14.</span>  -h, --hostname=<span class="string">&quot;&quot;</span>          指定容器的主机名    </span><br><span class="line"><span class="number">15.</span>  -v, --volume=[]            给容器挂载存储卷，挂载到容器的某个目录    </span><br><span class="line"><span class="number">16.</span>  --volumes-<span class="keyword">from</span>=[]          给容器挂载其他容器上的卷，挂载到容器的某个目录  </span><br><span class="line"><span class="number">17.</span>  --cap-<span class="keyword">add</span>=[]               添加权限，权限清单详见：http:<span class="comment">//linux.die.net/man/7/capabilities    </span></span><br><span class="line"><span class="number">18.</span>  --cap-drop=[]              删除权限，权限清单详见：http:<span class="comment">//linux.die.net/man/7/capabilities    </span></span><br><span class="line"><span class="number">19.</span>  --cidfile=<span class="string">&quot;&quot;</span>               运行容器后，在指定文件中写入容器PID值，一种典型的监控系统用法    </span><br><span class="line"><span class="number">20.</span>  --cpuset=<span class="string">&quot;&quot;</span>                设置容器可以使用哪些CPU，此参数可以用来容器独占CPU    </span><br><span class="line"><span class="number">21.</span>  --device=[]                添加主机设备给容器，相当于设备直通    </span><br><span class="line"><span class="number">22.</span>  --dns=[]                   指定容器的dns服务器    </span><br><span class="line"><span class="number">23.</span>  --dns-search=[]            指定容器的dns搜索域名，写入到容器的/etc/resolv.conf文件    </span><br><span class="line"><span class="number">24.</span>  --entrypoint=<span class="string">&quot;&quot;</span>            覆盖image的入口点    </span><br><span class="line"><span class="number">25.</span>  --env-file=[]              指定环境变量文件，文件格式为每行一个环境变量    </span><br><span class="line"><span class="number">26.</span>  --expose=[]                指定容器暴露的端口，即修改镜像的暴露端口    </span><br><span class="line"><span class="number">27.</span>  --link=[]                  指定容器间的关联，使用其他容器的IP、env等信息    </span><br><span class="line"><span class="number">28.</span>  --lxc-conf=[]              指定容器的配置文件，只有在指定--exec-driver=lxc时使用    </span><br><span class="line"><span class="number">29.</span>  --name=<span class="string">&quot;&quot;</span>                  指定容器名字，后续可以通过名字进行容器管理，links特性需要使用名字    </span><br><span class="line"><span class="number">30.</span>  --net=<span class="string">&quot;bridge&quot;</span>             容器网络设置:  </span><br><span class="line"><span class="number">31.</span>                                bridge 使用docker daemon指定的网桥       </span><br><span class="line"><span class="number">32.</span>                                host    <span class="comment">//容器使用主机的网络    </span></span><br><span class="line"><span class="number">33.</span>                                container:NAME_or_ID  &gt;<span class="comment">//使用其他容器的网路，共享IP和PORT等网络资源    </span></span><br><span class="line"><span class="number">34.</span>                                none 容器使用自己的网络（类似--net=bridge），但是不进行配置   </span><br><span class="line"><span class="number">35.</span>  --privileged=<span class="literal">false</span>         指定容器是否为特权容器，特权容器拥有所有的capabilities    </span><br><span class="line"><span class="number">36.</span>  --restart=<span class="string">&quot;no&quot;</span>             指定容器停止后的重启策略:  </span><br><span class="line"><span class="number">37.</span>                                no：容器退出时不重启    </span><br><span class="line"><span class="number">38.</span>                                <span class="keyword">on</span>-failure：容器故障退出（返回值非零）时重启   </span><br><span class="line"><span class="number">39.</span>                                always：容器退出时总是重启    </span><br><span class="line"><span class="number">40.</span>  --rm=<span class="literal">false</span>                 指定容器停止后自动删除容器(不支持以docker run -d启动的容器)    </span><br><span class="line"><span class="number">41.</span>  --sig-proxy=<span class="literal">true</span>           设置由代理接受并处理信号，但是SIGCHLD、SIGSTOP和SIGKILL不能被代理    </span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>elasticsearch-7.5.0白金版破解</title>
    <url>/2020/08/19/elasticsearch-7-5-0%E7%A0%B4%E8%A7%A3/</url>
    <content><![CDATA[<p>下载elasticsearch 7.5.0版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.5.0-darwin-x86_64.tar.gz</span><br></pre></td></tr></table></figure>

<p>解压</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf elasticsearch-7.5.0-darwin-x86_64.tar.gz</span><br></pre></td></tr></table></figure>

<h3 id="破解过程："><a href="#破解过程：" class="headerlink" title="破解过程："></a>破解过程：</h3><p>注意：<code>/Users/mengfanxing_g/elk/</code>是我本机路径，你在操作时应该修改成你的路径。</p>
<p>1，将 <code>/Users/mengfanxing_g/elk/elasticsearch-7.5.0/modules/x-pack-core/</code>目录下的<code>x-pack-core-7.5.0.jar</code>文件赋值一份，</p>
<p>2，手动创建<code>XPackBuild.java</code>和<code>LicenseVerifier.java</code>两个文件，</p>
<ul>
<li><p><code>LicenseVerifier.java</code>内容为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.elasticsearch.xpack.core;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.common.SuppressForbidden;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.common.io.PathUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.URISyntaxException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Path;</span><br><span class="line"><span class="keyword">import</span> java.util.jar.JarInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.jar.Manifest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XPackBuild</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> XPackBuild CURRENT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        CURRENT = <span class="keyword">new</span> XPackBuild(<span class="string">&quot;Unknown&quot;</span>, <span class="string">&quot;Unknown&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns path to xpack codebase path</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressForbidden(reason = &quot;looks up path of xpack.jar directly&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Path <span class="title">getElasticsearchCodebase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        URL url = XPackBuild.class.getProtectionDomain().getCodeSource().getLocation();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> PathUtils.get(url.toURI());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (URISyntaxException bogus) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(bogus);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String shortHash;</span><br><span class="line">    <span class="keyword">private</span> String date;</span><br><span class="line"></span><br><span class="line">    XPackBuild(String shortHash, String date) &#123;</span><br><span class="line">        <span class="keyword">this</span>.shortHash = shortHash;</span><br><span class="line">        <span class="keyword">this</span>.date = date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">shortHash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> shortHash;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">date</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> date;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>LicenseVerifier.java</code>文件的内容为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package org.elasticsearch.license;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Responsible for verifying signed licenses</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class LicenseVerifier &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * verifies the license content with the signature using the packaged</span><br><span class="line">     * public key</span><br><span class="line">     * @param license to verify</span><br><span class="line">     * @return true if valid, false otherwise</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static boolean verifyLicense(final License license, byte[] publicKeyData) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static boolean verifyLicense(final License license) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>3 使用javac 编译这两个java文件，需要引入import的依赖，使用-cp参数，需要依赖原本的<code>x-pack-core-7.5.0.jar</code>，<code>lucene-core-8.3.0.jar</code>，<code>elasticsearch-7.5.0.jar</code>，<code>elasticsearch-core-7.5.0.jar</code>这四个jar包,对应的文件都在安装目录，有的在lib目录下，有的在modules目录下。编译命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javac -cp &quot;&#x2F;Users&#x2F;mengfanxing_g&#x2F;elk&#x2F;elasticsearch-7.5.0&#x2F;modules&#x2F;x-pack-core&#x2F;x-pack-core-7.5.0.jar:&#x2F;Users&#x2F;mengfanxing_g&#x2F;elk&#x2F;elasticsearch-7.5.0&#x2F;lib&#x2F;lucene-core-8.3.0.jar:&#x2F;Users&#x2F;mengfanxing_g&#x2F;elk&#x2F;elasticsearch-7.5.0&#x2F;lib&#x2F;elasticsearch-7.5.0.jar:&#x2F;Users&#x2F;mengfanxing_g&#x2F;elk&#x2F;elasticsearch-7.5.0&#x2F;lib&#x2F;elasticsearch-core-7.5.0.jar&quot;  &#x2F;Users&#x2F;mengfanxing_g&#x2F;richard&#x2F;blog&#x2F;XingServer&#x2F;tmp&#x2F;XPackBuild.java</span><br><span class="line"></span><br><span class="line">javac -cp &quot;&#x2F;Users&#x2F;mengfanxing_g&#x2F;elk&#x2F;elasticsearch-7.5.0&#x2F;modules&#x2F;x-pack-core&#x2F;x-pack-core-7.5.0.jar:&#x2F;Users&#x2F;mengfanxing_g&#x2F;elk&#x2F;elasticsearch-7.5.0&#x2F;lib&#x2F;lucene-core-8.3.0.jar:&#x2F;Users&#x2F;mengfanxing_g&#x2F;elk&#x2F;elasticsearch-7.5.0&#x2F;lib&#x2F;elasticsearch-7.5.0.jar:&#x2F;Users&#x2F;mengfanxing_g&#x2F;elk&#x2F;elasticsearch-7.5.0&#x2F;lib&#x2F;elasticsearch-core-7.5.0.jar&quot;  &#x2F;Users&#x2F;mengfanxing_g&#x2F;richard&#x2F;blog&#x2F;XingServer&#x2F;tmp&#x2F;LicenseVerifier.java</span><br></pre></td></tr></table></figure>

<p>然后就会在桌面产生对应的class文件。</p>
<p>查询需要替换的文件在jar中的位置 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jar tvf *****.jar | grep &#123;fileName&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4786 Tue Nov 26 01:06:36 CST 2019 org&#x2F;elasticsearch&#x2F;license&#x2F;LicenseVerifier.class</span><br></pre></td></tr></table></figure>

<p>二、将文件解压到当前目录(以及文件所在目录)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; jar xvf ****.jar &#123;filePath&#125;</span><br></pre></td></tr></table></figure>

<p>三、替换新生成的文件夹中的文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; jar uvf ***.jar &#123;filePath&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jar uvf x-pack-core-7.5.0.jar org/elasticsearch/license/LicenseVerifier.class</span><br><span class="line">正在添加: org/elasticsearch/license/LicenseVerifier.class(输入 = 410) (输出 = 246)(压缩了 40%</span><br></pre></td></tr></table></figure>

<p>XPackBuild 同理</p>
<p>4，更新许可证</p>
<p>官方申请地址： <a href="https://register.elastic.co/marvel_register">https://register.elastic.co/marvel_register</a></p>
<p>公司地址什么课以随便填写，邮箱要填好，然后收到邮件，进行文件下载。 下载下来，修改里面的内容，主要是把 “basic” 改为 “platinum” 即白金版，”expiry_date_in_millis” 这个时间戳改大点，就够用了。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;license&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;uid&quot;</span>: <span class="string">&quot;5a2c6c4f-60bf-4471-8941-1d037364a2e3&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;platinum&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;issue_date_in_millis&quot;</span>: <span class="number">1597881600000</span>,</span><br><span class="line">    <span class="attr">&quot;expiry_date_in_millis&quot;</span>: <span class="number">2524582861000</span>,</span><br><span class="line">    <span class="attr">&quot;max_nodes&quot;</span>: <span class="number">9999</span>,</span><br><span class="line">    <span class="attr">&quot;issued_to&quot;</span>: <span class="string">&quot;richard xing (xiong)&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;issuer&quot;</span>: <span class="string">&quot;Web Form&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;signature&quot;</span>: <span class="string">&quot;AAAAAwAAAA3unQmrSr8HfvmG9XG6AAABmC9ZN0hjZDBGYnVyRXpCOW5Bb3FjZDAxOWpSbTVoMVZwUzRxVk1PSmkxaktJRVl5MUYvUWh3bHZVUTllbXNPbzBUemtnbWpBbmlWRmRZb25KNFlBR2x0TXc2K2p1Y1VtMG1UQU9TRGZVSGRwaEJGUjE3bXd3LzRqZ05iLzRteWFNekdxRGpIYlFwYkJiNUs0U1hTVlJKNVlXekMrSlVUdFIvV0FNeWdOYnlESDc3MWhlY3hSQmdKSjJ2ZTcvYlBFOHhPQlV3ZHdDQ0tHcG5uOElCaDJ4K1hob29xSG85N0kvTWV3THhlQk9NL01VMFRjNDZpZEVXeUtUMXIyMlIveFpJUkk2WUdveEZaME9XWitGUi9WNTZVQW1FMG1DenhZU0ZmeXlZakVEMjZFT2NvOWxpZGlqVmlHNC8rWVVUYzMwRGVySHpIdURzKzFiRDl4TmM1TUp2VTBOUlJZUlAyV0ZVL2kvVk10L0NsbXNFYVZwT3NSU082dFNNa2prQ0ZsclZ4NTltbU1CVE5lR09Bck93V2J1Y3c9PQAAAQBfvTGssbXzXV+UDVggDncuYFQH+8rxwxt4J8H7KuhOAlYUnysaGKz+Agoh+vZOTKm0Uyo9Fl+6dn46RN9k4lHCW8UPby3M+arpH+g2dNzXASlmku+SQUI0MO1zKJ4FjVYGqjlzKyJ54fYAtW+B6i/R8saLp4lnmW+jvC7tAUehgZFF2jxF3Z+D4bHgGS+w005J4B0M36ViG86wa4Lmq2p9vgq6ZBw7mCZpazBPQpwLJTuNDCGCcCF3wN/lh9WjCsjOBbC5Qk0Zv9EgFebZZl0tYU5/klJxqxJTMt1b16ajJEC6hKzlCPMl0A1SIi7uz1aXZK9jdrg9S3ovfL3/sAb4&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;start_date_in_millis&quot;</span>: <span class="number">1597881600000</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在导入license 之前需要</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">xpack.security.enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>然后执行 导入json文件 因为还没设置elastic 用户名密码  直接回车</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -XPUT -u elastic &#x27;http://localhost:9200/_xpack/license&#x27; -H &quot;Content-Type: application/json&quot; -d @richard-xing-5a2c6c4f-60bf-4471-8941-1d037364a2e3-v5.json</span><br><span class="line">&#123;&quot;acknowledged&quot;:true,&quot;license_status&quot;:&quot;valid&quot;&#125;%</span><br></pre></td></tr></table></figure>

<p>然后elasticsearch 添加对xpack的支持 然后 kibana上才能展示出security的模块，然后重新启动</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">xpack.security.enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>然后在另一个窗口 执行，会自动生成相应用户名的密码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bin/elasticsearch-setup-passwords auto</span><br><span class="line">future versions of Elasticsearch will require Java 11; your Java version from [/Library/Java/JavaVirtualMachines/jdk1.8.0_172.jdk/Contents/Home/jre] does not meet this requirement</span><br><span class="line">Initiating the setup of passwords for reserved users elastic,apm_system,kibana,logstash_system,beats_system,remote_monitoring_user.</span><br><span class="line">The passwords will be randomly generated and printed to the console.</span><br><span class="line">Please confirm that you would like to continue [y/N]y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Changed password for user apm_system</span><br><span class="line">PASSWORD apm_system = 9zmSk88HiUQpy9f7PubZ</span><br><span class="line"></span><br><span class="line">Changed password for user kibana</span><br><span class="line">PASSWORD kibana = xppkoLkpaaanyVgV5kte</span><br><span class="line"></span><br><span class="line">Changed password for user logstash_system</span><br><span class="line">PASSWORD logstash_system = 7z9kX3eVrwMoOWGRm5Lj</span><br><span class="line"></span><br><span class="line">Changed password for user beats_system</span><br><span class="line">PASSWORD beats_system = 2GfWlbqa7s9azHZCuqeO</span><br><span class="line"></span><br><span class="line">Changed password for user remote_monitoring_user</span><br><span class="line">PASSWORD remote_monitoring_user = IPiR8ELc0Bwells0OXV4</span><br><span class="line"></span><br><span class="line">Changed password for user elastic</span><br><span class="line">PASSWORD elastic = cJQ98i4M0fPyaVkbw0WT</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>elasticsearch-忘记密码</title>
    <url>/2020/09/19/elasticsearch-%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<h3 id="忘记密码"><a href="#忘记密码" class="headerlink" title="忘记密码"></a>忘记密码</h3><p><strong>重置elasticsearch的超级管理员密码</strong></p>
<p>按照下述步骤创建本地超级账户，然后使用api接口本地超级账户重置elastic账户的密码</p>
<p>(1) 停止elasticsearch服务<br>(2) 确保你的配置文件中支持本地账户认证支持，如果你使用的是xpack的默认配置则无需做特殊修改；如果你配置了其他认证方式则需要确保配置本地认证方式在ES_HOME/config/elasticsearch.yml中；<br>(3) 使用命令ES_HOME/bin/x-pack/users创建一个基于本地问价认证的超级管理员</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;x-pack&#x2F;users useradd my_admin -p my_password -r superuser</span><br></pre></td></tr></table></figure>

<p>(4) 启动elasticsearch服务<br>(5) 通过api重置elastic超级管理员的密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -u my_admin -XPUT &#39;http:&#x2F;&#x2F;localhost:9200&#x2F;_xpack&#x2F;security&#x2F;user&#x2F;elastic&#x2F;_password?pretty&#39; -H &#39;Content-Type: application&#x2F;json&#39; -d&#39;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;password&quot; : &quot;new_password&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>‘<br>(6) 校验下密码是否重置成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -u elastic &#39;http:&#x2F;&#x2F;localhost:9200&#x2F;_xpack&#x2F;security&#x2F;_authenticate?pretty&#39;</span><br></pre></td></tr></table></figure>

<p>(7) 如果你确定后续不再使用本地认证则可将elasticsearch.yml文件中的本地文件认证方式删除掉；</p>
]]></content>
  </entry>
  <entry>
    <title>flink学习笔记一 学习目标</title>
    <url>/2020/12/27/flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%20%E5%AD%A6%E4%B9%A0%E7%9B%AE%E6%A0%87/</url>
    <content><![CDATA[<h3 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h3><ol>
<li>对flink做下整体的介绍了解，</li>
<li>写一个wordcount做一个快速上手</li>
<li>做一个部署运行</li>
<li>了解运行Ⅹ的架构和任务调度原理</li>
<li>了解Flink里边各类api的用法，主要就是datastream api ，source 、transform 、sink三大部分</li>
<li>窗口window相关的操作</li>
<li>时间语义和watermark</li>
<li>底层的api使用方法</li>
<li>状态编程和容错机制</li>
<li>更加高级的api与sql</li>
<li>cep相关的内容</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>flink学习笔记三：快速上手</title>
    <url>/2020/12/28/flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89%EF%BC%9A%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</url>
    <content><![CDATA[<h3 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h3><ol>
<li><p><strong>创建一个pom工程</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">  ~ Copyright (C) 2020 Baidu, Inc. All Rights Reserved.</span><br><span class="line">  --&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;</span><br><span class="line">         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.richard.flink&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;FlinkTutorial&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.flink&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;flink-scala_2.12&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.10.1&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.flink&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;flink-streaming-scala_2.12&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.10.1&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line"></span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;net.alchim31.maven&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;scala-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;version&gt;3.4.6&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;!-- 声明绑定到 maven 的 compile 阶段 --&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;compile&lt;&#x2F;goal&gt;</span><br><span class="line">                        &lt;&#x2F;goals&gt;</span><br><span class="line">                    &lt;&#x2F;execution&gt;</span><br><span class="line">                &lt;&#x2F;executions&gt;</span><br><span class="line">            &lt;&#x2F;plugin&gt;</span><br><span class="line"></span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-assembly-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;version&gt;3.0.0&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;descriptorRefs&gt;</span><br><span class="line">                        &lt;descriptorRef&gt;jar-with-dependencies&lt;&#x2F;descriptorRef&gt;</span><br><span class="line">                    &lt;&#x2F;descriptorRefs&gt;</span><br><span class="line">                &lt;&#x2F;configuration&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;id&gt;make-assembly&lt;&#x2F;id&gt;</span><br><span class="line">                        &lt;phase&gt;package&lt;&#x2F;phase&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;single&lt;&#x2F;goal&gt;</span><br><span class="line">                        &lt;&#x2F;goals&gt;</span><br><span class="line">                    &lt;&#x2F;execution&gt;</span><br><span class="line">                &lt;&#x2F;executions&gt;</span><br><span class="line">            &lt;&#x2F;plugin&gt;</span><br><span class="line">        &lt;&#x2F;plugins&gt;</span><br><span class="line">    &lt;&#x2F;build&gt;</span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写一个批处理程序 wordCount</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.api.scala._</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (C) 2020 Baidu, Inc. All Rights Reserved.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">WordCount</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 创建执行环境</span></span><br><span class="line">    <span class="keyword">val</span> env = <span class="type">ExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    <span class="comment">// 从文件中读取数据</span></span><br><span class="line">    <span class="keyword">val</span> inputPath = <span class="string">&quot;/Users/mengfanxing_g/duserver/FlinkTutorial/src/main/resources/hello.txt&quot;</span></span><br><span class="line">    <span class="keyword">val</span> inputDS: <span class="type">DataSet</span>[<span class="type">String</span>] = env.readTextFile(inputPath)</span><br><span class="line">    <span class="comment">// 分词之后，对单词进行 groupby 分组，然后用 sum 进行聚合</span></span><br><span class="line">    <span class="keyword">val</span> wordCountDS: <span class="type">AggregateDataSet</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = inputDS.flatMap(_.split(<span class="string">&quot; &quot;</span>)).map((_, <span class="number">1</span>)).groupBy(<span class="number">0</span>).sum(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 打印输出</span></span><br><span class="line">    wordCountDS.print()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写hello的内容</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">hello</span><br><span class="line">scala</span><br><span class="line">hello Flink</span><br><span class="line">How are you</span><br><span class="line">I fine thank you</span><br><span class="line">And you</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>运行输出结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">(How,1)</span><br><span class="line">(I,1)</span><br><span class="line">(are,1)</span><br><span class="line">(scala,1)</span><br><span class="line">(thank,1)</span><br><span class="line">(you,3)</span><br><span class="line">(And,1)</span><br><span class="line">(fine,1)</span><br><span class="line">(Flink,1)</span><br><span class="line">(hello,2)</span><br><span class="line"></span><br><span class="line">Process finished with <span class="built_in">exit</span> code 0</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="5">
<li><p>编写一个流处理程序 StreamWordCount</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.utils.<span class="type">ParameterTool</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala._</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (C) 2020 Baidu, Inc. All Rights Reserved.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">StreamWordCount</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从外部命令获取参数</span></span><br><span class="line">    <span class="keyword">val</span> params: <span class="type">ParameterTool</span> = <span class="type">ParameterTool</span>.fromArgs(args)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> host :<span class="type">String</span> = params.get(<span class="string">&quot;host&quot;</span>)</span><br><span class="line"></span><br><span class="line">    println(host)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> port :<span class="type">Int</span> = params.getInt(<span class="string">&quot;port&quot;</span>)</span><br><span class="line">    println(port)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建流处理环境</span></span><br><span class="line">    <span class="keyword">val</span> env: <span class="type">StreamExecutionEnvironment</span> = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收socket 文本流</span></span><br><span class="line">    <span class="keyword">val</span> textDstream:<span class="type">DataStream</span>[<span class="type">String</span>] = env.socketTextStream(host,port)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// flatMap 和 Map 需要引用的隐式转换</span></span><br><span class="line">    <span class="keyword">val</span> dataStream: <span class="type">DataStream</span>[(<span class="type">String</span>,<span class="type">Int</span>)] = textDstream</span><br><span class="line">      .flatMap(_.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">      .filter(_.nonEmpty)</span><br><span class="line">      .map((_,<span class="number">1</span>))</span><br><span class="line">      .keyBy(<span class="number">0</span>)</span><br><span class="line">      .sum(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    dataStream.print()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动executor ， 执行任务</span></span><br><span class="line">    env.execute(<span class="string">&quot;socket stream word count&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑idea的Program arguments:  –host localhost –port 7777</p>
</li>
<li><p>启动nc </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mfxing  nc -lk 7777</span><br><span class="line">hello Flink</span><br><span class="line">hello Scala</span><br></pre></td></tr></table></figure>

<p>程序输出结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">SLF4J: See http:&#x2F;&#x2F;www.slf4j.org&#x2F;codes.html#StaticLoggerBinder for further details.</span><br><span class="line">2&gt; (hello,1)</span><br><span class="line">4&gt; (Flink,1)</span><br><span class="line">4&gt; (Scala,1)</span><br><span class="line">2&gt; (hello,2)</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>flink学习笔记二：Flink简介</title>
    <url>/2020/12/28/flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C%EF%BC%9AFlink%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h3 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h3><ol>
<li><h4 id="Flink是什么"><a href="#Flink是什么" class="headerlink" title="Flink是什么"></a>Flink是什么</h4><ol>
<li>Apache Flink 是一个框架和分布式处理引擎，用于对无界和有界数据流进行有 状态计算。Flink 被设计在所有常见的集群环境中运行，以内存执行速度和任意规模 来执行计算。</li>
<li>Flink 项目的理念是:“Apache Flink 是为分布式、高性能、随时可用以及准确的流处理应用程序打造的开源流处理框架”。</li>
</ol>
</li>
<li><h4 id="为什么要用Flink"><a href="#为什么要用Flink" class="headerlink" title="为什么要用Flink"></a>为什么要用Flink</h4><ol>
<li>流数据更真实的反应我们的生活方式</li>
<li>传统的数据框架是基于有限的数据集的</li>
<li>我们的目标<ol>
<li>低延迟</li>
<li>高吞吐</li>
<li>结果的准确性和良好的容错性</li>
</ol>
</li>
<li>哪些行业需要处理流数据<ol>
<li>电商行业和市场营销<ol>
<li>数据报表、广告投放、业务流程需要</li>
</ol>
</li>
<li>物联网（IOT）<ol>
<li>传感器实时数据采集和显示、实时报警、交通运输业</li>
</ol>
</li>
<li>电信业<ol>
<li>基站流量调配</li>
</ol>
</li>
<li>银行和金融业<ol>
<li>实时结算和通知推送，实时检测和异常行为 </li>
</ol>
</li>
</ol>
</li>
</ol>
<p>ps: gps的信息就是流式数据，金融中的交易数据，服务器的日志</p>
</li>
<li><h4 id="流处理的发展和转变"><a href="#流处理的发展和转变" class="headerlink" title="流处理的发展和转变"></a>流处理的发展和转变</h4><ol>
<li>传统数据处理架构<ol>
<li><img src="/images/flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C%EF%BC%9AFlink%E7%AE%80%E4%BB%8B/image-20201228144234884.png" alt="image-20201228144234884" style="zoom:50%;" /><img src="/images/flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C%EF%BC%9AFlink%E7%AE%80%E4%BB%8B/image-20201228144600428.png" alt="image-20201228144600428"></li>
<li><img src="/images/flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C%EF%BC%9AFlink%E7%AE%80%E4%BB%8B/image-20201228144624819.png" alt="image-20201228144624819" style="zoom:50%;" /></li>
<li><img src="/images/flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C%EF%BC%9AFlink%E7%AE%80%E4%BB%8B/image-20201228145047007.png" alt="image-20201228145047007" style="zoom:50%;" /><img src="/images/flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C%EF%BC%9AFlink%E7%AE%80%E4%BB%8B/image-20201228145311986.png" alt="image-20201228145311986"></li>
<li><img src="/images/flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C%EF%BC%9AFlink%E7%AE%80%E4%BB%8B/image-20201228145338461.png" alt="image-20201228145338461" style="zoom:50%;" /><img src="/images/flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C%EF%BC%9AFlink%E7%AE%80%E4%BB%8B/image-20201228145536693.png" alt="image-20201228145536693"></li>
<li><img src="/images/flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C%EF%BC%9AFlink%E7%AE%80%E4%BB%8B/image-20201228145556588.png" alt="image-20201228145556588" style="zoom:50%;" />
</li>
</ol>
</li>
</ol>
</li>
<li><h4 id="Flink的主要特点"><a href="#Flink的主要特点" class="headerlink" title="Flink的主要特点"></a>Flink的主要特点</h4><ol>
<li><p>事件驱动（Eveny-driven）</p>
<ol>
<li><img src="/images/flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C%EF%BC%9AFlink%E7%AE%80%E4%BB%8B/image-20201228145907225.png" alt="image-20201228145907225" style="zoom:50%;" />
</li>
<li><p>基于流的世界观</p>
<ol>
<li>在Flink的世界观中，一切都是流组成的，离线数据是有界的流，实时数据是一个没有界限的流；这就是所谓的有界流和无界流<img src="/images/flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C%EF%BC%9AFlink%E7%AE%80%E4%BB%8B/image-20201228150125877.png" alt="image-20201228150125877" style="zoom:50%;" /></li>
</ol>
</li>
<li><p>分层API</p>
<ol>
<li><p>越顶层越抽象，表达含义越简明，使用越方便</p>
</li>
<li><p>越底层越具体，表达能力越丰富，使用越灵活</p>
<p><img src="/images/flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C%EF%BC%9AFlink%E7%AE%80%E4%BB%8B/image-20201228150350452.png" alt="image-20201228150350452"></p>
</li>
</ol>
</li>
<li><p>Flink的其他特定</p>
<ol>
<li>支持事件时间（event-time）和处理时间（processing-time）语义</li>
<li>精确一次（exactly-once）的状态一致性保证</li>
<li>低延迟，每秒处理数百万个时间，毫秒级延迟</li>
<li>与众多常用存储系统的链接</li>
<li>高可用动态扩展，实现7<em>24小时全天候运行</em></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><h4 id="Flink-Vs-Spark-streaming"><a href="#Flink-Vs-Spark-streaming" class="headerlink" title="Flink Vs Spark streaming"></a>Flink Vs Spark streaming</h4><ol>
<li><p>流（stream）和微批（micro-batching）</p>
<img src="/images/flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C%EF%BC%9AFlink%E7%AE%80%E4%BB%8B/image-20201228151003997.png" alt="image-20201228151003997" style="zoom: 50%;" />
</li>
<li><p>数据模型</p>
<ul>
<li>sprark 采用的是RDD模型，spark streaming的DStream实际上也就是一组组小批数据的RDD的集合</li>
<li>Flink基本数据模型是数据流，以及事件（Event）序列</li>
</ul>
</li>
<li><p>运行时架构</p>
<ul>
<li>spark是批计算，将DAG划分为不同的stage，一个完成后才可以计算下一个</li>
<li>Flink是标准的流执行模式，一个事件在一个节点处理完后可以直接发往下一个节点进行处理</li>
</ul>
</li>
</ol>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>flink学习笔记五：运行时架构</title>
    <url>/2020/12/29/flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94%EF%BC%9A%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h3 id="运行时架构"><a href="#运行时架构" class="headerlink" title="运行时架构"></a>运行时架构</h3><ol>
<li><h4 id="Flink运行时组件"><a href="#Flink运行时组件" class="headerlink" title="Flink运行时组件"></a>Flink运行时组件</h4><ol>
<li><img src="/images/flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94%EF%BC%9A%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9E%B6%E6%9E%84/image-20201230142923266.png" alt="image-20201230142923266" style="zoom:50%;" />
</li>
</ol>
</li>
<li><h4 id="任务提交流程"><a href="#任务提交流程" class="headerlink" title="任务提交流程"></a>任务提交流程</h4><ol>
<li><img src="/images/flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94%EF%BC%9A%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9E%B6%E6%9E%84/image-20201230144136573.png" alt="image-20201230144136573"></li>
</ol>
</li>
<li><h4 id="任务调度原理"><a href="#任务调度原理" class="headerlink" title="任务调度原理"></a>任务调度原理</h4><img src="/images/flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94%EF%BC%9A%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9E%B6%E6%9E%84/image-20201230145253536.png" alt="image-20201230145253536" style="zoom: 33%;" />

</li>
</ol>
<p><strong>是否合并任务链的小技巧：</strong></p>
<ol>
<li>​    disableChaining() 取消合并</li>
<li>.startNewCHain() 开启一个新的任务链  </li>
<li>.slotSharingSolt(“name”)    独享一个slot </li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>flink学习笔记六：Flink流处理APi</title>
    <url>/2020/12/31/flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AD%EF%BC%9AFlink%E6%B5%81%E5%A4%84%E7%90%86APi/</url>
    <content><![CDATA[<h3 id="Flink流处理APi"><a href="#Flink流处理APi" class="headerlink" title="Flink流处理APi"></a>Flink流处理APi</h3><ol>
<li><h4 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h4><ol>
<li><p><strong>getExecutionEnvironment</strong></p>
<p>创建一个执行环境，表示当前执行程序的上下文。 如果程序是独立调用的，则 此方法返回本地执行环境;如果从命令行客户端调用程序以提交到集群，则此方法 返回此集群的执行环境，也就是说，getExecutionEnvironment 会根据查询运行的方 式决定返回什么样的运行环境，是最常用的一种创建执行环境的方式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val env: ExecutionEnvironment &#x3D; ExecutionEnvironment.getExecutionEnvironment</span><br><span class="line"></span><br><span class="line">val env &#x3D; StreamExecutionEnvironment.getExecutionEnvironment 如果没有设置并行度，会以 flink-conf.yaml 中的配置为准，默认是 1。</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>createLocalEnvironment</strong></p>
<p>返回本地执行环境，需要在调用时指定默认的并行度。</p>
<p>val env = StreamExecutionEnvironment.createLocalEnvironment(1)</p>
</li>
<li><p><strong>createRemoteEnvironment</strong></p>
<p>返回集群执行环境，将 Jar 提交到远程服务器。需要在调用时指定 JobManager</p>
<p>的 IP 和端口号，并指定要在集群中运行的 Jar 包。</p>
<p>val env = ExecutionEnvironment.createRemoteEnvironment(“jobmanage-hostname”, 6123,”YOURPATH//wordcount.jar”)</p>
</li>
</ol>
</li>
<li><h4 id="source"><a href="#source" class="headerlink" title="source"></a>source</h4><ol>
<li>从集合读取数据</li>
<li>从文件读取数据</li>
<li>以 <strong>kafka</strong> 消息队列的数据作为来源</li>
<li>自定义 Source</li>
</ol>
</li>
<li><h4 id="Transform-转换算子"><a href="#Transform-转换算子" class="headerlink" title="Transform  转换算子"></a><strong>Transform</strong>  转换算子</h4><p>在Spark中，算子分为转换算子和行动算子，转换算子的作用可以通过算子方法的调用将一个RDD转换另外一个RDD，Flink中也存在同样的操作，可以将一个数据流转换为其他的数据流。</p>
<p><strong>转换过程中，数据流的类型也会发生变化，那么到底Flink支持什么样的数据类型呢，其实我们常用的数据类型，Flink都是支持的。比如：Long, String, Integer, Int, 元组，样例类，List, Map等。</strong></p>
<ol>
<li><h5 id="map"><a href="#map" class="headerlink" title="map"></a>map</h5><ol>
<li>映射：将数据流中的数据进行转换, 形成新的数据流，消费一个元素并产出一个元素</li>
<li>参数：Scala匿名函数或MapFunction</li>
<li>返回：DataStream</li>
</ol>
</li>
<li><h5 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h5><ol>
<li><p>扁平映射：将数据流中的整体拆分成一个一个的个体使用，消费一个元素并产生零到多个元素</p>
</li>
<li><p>参数：Scala匿名函数或FlatMapFunction</p>
</li>
<li><p>返回：DataStream</p>
<p><img src="/images/flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AD%EF%BC%9AFlink%E6%B5%81%E5%A4%84%E7%90%86APi/java6-1598922850.png" alt="Flink从入门到入土"></p>
</li>
</ol>
</li>
<li><h5 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h5><ol>
<li>过滤：根据指定的规则将满足条件（true）的数据保留，不满足条件(false)的数据丢弃</li>
<li>参数：Scala匿名函数或FilterFunction</li>
<li>返回：DataStream</li>
</ol>
</li>
<li><h5 id="KeyBy"><a href="#KeyBy" class="headerlink" title="KeyBy"></a>KeyBy</h5><p>​    在Spark中有一个GroupBy的算子，用于根据指定的规则将数据进行分组，在flink中也有类似的功能，那就是keyBy，根据指定的key对数据进行分流</p>
<ol>
<li>分流：根据指定的Key将元素发送到不同的分区，相同的Key会被分到一个分区（这里分区指的就是下游算子多个并行节点的其中一个）。keyBy()是通过哈希来分区的</li>
</ol>
<p><img src="/images/flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AD%EF%BC%9AFlink%E6%B5%81%E5%A4%84%E7%90%86APi/java5-1598922850.png" alt="Flink从入门到入土"></p>
<ol start="2">
<li><p>参数：Scala匿名函数或POJO属性或元组索引，不能使用数组</p>
</li>
<li><p>返回：KeyedStream</p>
<img src="/images/flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AD%EF%BC%9AFlink%E6%B5%81%E5%A4%84%E7%90%86APi/java0-1598922850.png" alt="Flink从入门到入土"  />
</li>
</ol>
</li>
<li><h5 id="滚动聚合算子Rolling-Aggregation"><a href="#滚动聚合算子Rolling-Aggregation" class="headerlink" title="滚动聚合算子Rolling Aggregation"></a>滚动聚合算子Rolling Aggregation</h5><ol>
<li><p>这些算子可以针对KeyedStream的每一个支流做聚合。执行完成后，会将聚合的结果合成一个流返回，所以结果都是DataStream</p>
<p>sum()</p>
<p><img src="/images/flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AD%EF%BC%9AFlink%E6%B5%81%E5%A4%84%E7%90%86APi/java5-1598922850-3-20201231162508066.png" alt="Flink从入门到入土"></p>
<p>min()</p>
<p><img src="/images/flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AD%EF%BC%9AFlink%E6%B5%81%E5%A4%84%E7%90%86APi/java5-1598922851.png" alt="Flink从入门到入土"></p>
<p>max()</p>
<p><img src="/images/flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AD%EF%BC%9AFlink%E6%B5%81%E5%A4%84%E7%90%86APi/java6-1598922851.png" alt="Flink从入门到入土"></p>
</li>
<li><h5 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h5><ol>
<li><p>一个分组数据流的聚合操作，合并当前的元素和上次聚合的结果，产生一个新的值，返回的流中包含每一次聚合的结果，而不是只返回最后一次聚合的最终结果。</p>
<p><img src="/images/flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AD%EF%BC%9AFlink%E6%B5%81%E5%A4%84%E7%90%86APi/java6-1598922851-1.png" alt="Flink从入门到入土">    </p>
</li>
</ol>
</li>
<li><h5 id="Split-和Select"><a href="#Split-和Select" class="headerlink" title="Split 和Select"></a>Split 和Select</h5><ol>
<li><p>在某些情况下，我们需要将数据流根据某些特征拆分成两个或者多个数据流，给不同数据流增加标记以便于从流中取出。</p>
<p><img src="/images/flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AD%EF%BC%9AFlink%E6%B5%81%E5%A4%84%E7%90%86APi/java10-1598922850-1.png" alt="Flink从入门到入土"></p>
</li>
<li><p>将数据流进行切分后，如何从流中将不同的标记取出呢，这时就需要使用select算子了。</p>
<p><img src="/images/flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AD%EF%BC%9AFlink%E6%B5%81%E5%A4%84%E7%90%86APi/java8-1598922850.png" alt="Flink从入门到入土"></p>
</li>
</ol>
</li>
<li><h5 id="Connect和CoMap"><a href="#Connect和CoMap" class="headerlink" title="Connect和CoMap"></a>Connect和CoMap</h5><ol>
<li><p><strong>DataStream,DataStream</strong> → <strong>ConnectedStreams</strong>:连接两个保持他们类型的数</p>
<p>据流，两个数据流被 Connect 之后，只是被放在了一个同一个流中，内部依然保持 各自的数据和形式不发生任何变化，两个流相互独立。</p>
<p><img src="/images/flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AD%EF%BC%9AFlink%E6%B5%81%E5%A4%84%E7%90%86APi/image-20201231165542283.png" alt="image-20201231165542283"></p>
</li>
<li><p>在某些情况下，我们需要将两个不同来源的数据流进行连接，实现数据匹配，比如订单支付和第三方交易信息，这两个信息的数据就来自于不同数据源，连接后，将订单支付和第三方交易信息进行对账，此时，才能算真正的支付完成。</p>
<p>Flink中的connect算子可以连接两个保持他们类型的数据流，两个数据流被Connect之后，只是被放在了一个同一个流中，内部依然保持各自的数据和形式不发生任何变化，两个流相互独立。</p>
<p>​    <img src="/images/flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AD%EF%BC%9AFlink%E6%B5%81%E5%A4%84%E7%90%86APi/java9-1598922850-1-20201231165603345.png" alt="Flink从入门到入土"></p>
</li>
</ol>
</li>
<li><h5 id="union"><a href="#union" class="headerlink" title="union"></a>union</h5><ol>
<li><p>对两个或者两个以上的DataStream进行union操作，产生一个包含所有DataStream元素的新DataStream</p>
<p><img src="/images/flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AD%EF%BC%9AFlink%E6%B5%81%E5%A4%84%E7%90%86APi/java3-1598922850.png" alt="Flink从入门到入土"></p>
</li>
<li><p>connect与 union 区别：</p>
<ol>
<li>union之前两个流的类型必须是一样，connect可以不一样</li>
<li>connect只能操作两个流，union可以操作多个。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><h4 id="实现-UDF-函数——更细粒度的控制流"><a href="#实现-UDF-函数——更细粒度的控制流" class="headerlink" title="实现 UDF 函数——更细粒度的控制流"></a>实现 UDF 函数——更细粒度的控制流</h4><ol>
<li><p>函数类(<strong>Function Classes</strong>)Flink 暴露了所有 udf 函数的接口(实现方式为接口或者抽象类)。例如 MapFunction, FilterFunction, ProcessFunction 等等。</p>
</li>
<li><p>匿名函数(<strong>Lambda Functions</strong>)</p>
</li>
<li><p>富函数(<strong>Rich Functions</strong>)</p>
<p>“富函数”是 DataStream API 提供的一个函数类的接口，所有 Flink 函数类都 有其 Rich 版本。它与常规函数的不同在于，可以获取运行环境的上下文，并拥有一 些生命周期方法，所以可以实现更复杂的功能。</p>
<ul>
<li>RichMapFunction</li>
<li>RichFlatMapFunction</li>
<li>RichFilterFunction</li>
<li>…​</li>
<li>Rich Function 有一个生命周期的概念。典型的生命周期方法有:<ul>
<li>open()方法是 rich function 的初始化方法，当一个算子例如 map 或者 filter被调用之前 open()会被调用。</li>
<li>close()方法是生命周期中的最后一个调用的方法，做一些清理工作。</li>
<li>getRuntimeContext()方法提供了函数的 RuntimeContext 的一些信息，例如函</li>
</ul>
</li>
</ul>
<p>数执行的并行度，任务的名字，以及 state 状态</p>
</li>
</ol>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>git-打tag</title>
    <url>/2020/09/04/git-%E6%89%93tag/</url>
    <content><![CDATA[<ol>
<li><p>先执行commit 保存数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit  -m &quot;注释&quot;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>添加tag 标签&amp;注释</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git tag -a 版本号 -m &quot;注释&quot;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>推送数据到远端 origin</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li><p>将tag推送到远程 origin</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin master --tags</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看 所有tag</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git tag -l</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>go-性能调优-字符串</title>
    <url>/2020/08/05/go-%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>#goloang 性能调优</p>
<h2 id="字符串性能测试"><a href="#字符串性能测试" class="headerlink" title="字符串性能测试"></a>字符串性能测试</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package concat_string</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;bytes&quot;</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;strconv&quot;</span><br><span class="line">    &quot;strings&quot;</span><br><span class="line">    &quot;testing&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const numbers &#x3D; 100</span><br><span class="line"></span><br><span class="line">func BenchmarkSprintf(b *testing.B) &#123;</span><br><span class="line">    b.ResetTimer()</span><br><span class="line">    for idx :&#x3D; 0; idx &lt; b.N; idx++ &#123;</span><br><span class="line">        var s string</span><br><span class="line">        for i :&#x3D; 0; i &lt; numbers; i++ &#123;</span><br><span class="line">            s &#x3D; fmt.Sprintf(&quot;%v%v&quot;, s, i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    b.StopTimer()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func BenchmarkStringBuilder(b *testing.B) &#123;</span><br><span class="line">    b.ResetTimer()</span><br><span class="line">    for idx :&#x3D; 0; idx &lt; b.N; idx++ &#123;</span><br><span class="line">        var builder strings.Builder</span><br><span class="line">        for i :&#x3D; 0; i &lt; numbers; i++ &#123;</span><br><span class="line">            builder.WriteString(strconv.Itoa(i))</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        _ &#x3D; builder.String()</span><br><span class="line">    &#125;</span><br><span class="line">    b.StopTimer()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func BenchmarkBytesBuf(b *testing.B) &#123;</span><br><span class="line">    b.ResetTimer()</span><br><span class="line">    for idx :&#x3D; 0; idx &lt; b.N; idx++ &#123;</span><br><span class="line">        var buf bytes.Buffer</span><br><span class="line">        for i :&#x3D; 0; i &lt; numbers; i++ &#123;</span><br><span class="line">            buf.WriteString(strconv.Itoa(i))</span><br><span class="line">        &#125;</span><br><span class="line">        _ &#x3D; buf.String()</span><br><span class="line">    &#125;</span><br><span class="line">    b.StopTimer()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func BenchmarkStringAdd(b *testing.B) &#123;</span><br><span class="line">    b.ResetTimer()</span><br><span class="line">    for idx :&#x3D; 0; idx &lt; b.N; idx++ &#123;</span><br><span class="line">        var s string</span><br><span class="line">        for i :&#x3D; 0; i &lt; numbers; i++ &#123;</span><br><span class="line">            s +&#x3D; strconv.Itoa(i)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    b.StopTimer()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行  go test -bench=. -run=none<br><br>output：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mfxing  go test -bench&#x3D;. -run&#x3D;none </span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: go.doglobal.net&#x2F;duapps&#x2F;do-feed&#x2F;service</span><br><span class="line">BenchmarkSprintf-4                100000             17347 ns&#x2F;op</span><br><span class="line">BenchmarkStringBuilder-4         2000000               899 ns&#x2F;op</span><br><span class="line">BenchmarkBytesBuf-4              1000000              1225 ns&#x2F;op</span><br><span class="line">BenchmarkStringAdd-4              300000              5683 ns&#x2F;op</span><br><span class="line">PASS</span><br><span class="line">ok      go.doglobal.net&#x2F;duapps&#x2F;do-feed&#x2F;service  7.630s</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><b>从结果可以看出 StringBuilder是最快的 899 ns/op， bytes.buffer次之，string += 拼的方式性较差，fmt.Sprintf()的方式性能最差是17347 ns/op。</p>
<p>接下来我们分析下为什么fmt.Sprintf()性能较stringbuilder 的性能差了这么多，通过 -cpuprofile profile.out的参数 将内存分配的信息输出到profile.out中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mfxing  go test -bench&#x3D;. -benchmem -cpuprofile profile.out</span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: go.doglobal.net&#x2F;duapps&#x2F;do-feed&#x2F;service</span><br><span class="line">BenchmarkSprintf-4                100000             19934 ns&#x2F;op           12180 B&#x2F;op        297 allocs&#x2F;op</span><br><span class="line">BenchmarkStringBuilder-4         2000000               914 ns&#x2F;op             504 B&#x2F;op          6 allocs&#x2F;op</span><br><span class="line">BenchmarkBytesBuf-4              1000000              1318 ns&#x2F;op             688 B&#x2F;op          4 allocs&#x2F;op</span><br><span class="line">BenchmarkStringAdd-4              200000              6383 ns&#x2F;op            9776 B&#x2F;op         99 allocs&#x2F;op</span><br><span class="line">PASS</span><br><span class="line">ok      go.doglobal.net&#x2F;duapps&#x2F;do-feed&#x2F;service  7.767s</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><b> 从结果我们可以看出 stringbuilder和bytes.buffer内存分配次数相差不多分别为6次和4次，string 拼接的方式 将近是buffer和builder的25倍，而fmt.sprintf()的方式，每次内存分配次数达到近300次</p>
<p>我们可以借助go tool pprof 来查看下程序代码的详细执行时间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go tool pprof profile.out</span><br><span class="line">mfxing  go tool pprof profile.out</span><br><span class="line">Type: cpu</span><br><span class="line">Time: Sep 16, 2019 at 1:55pm (CST)</span><br><span class="line">Duration: 7.74s, Total samples &#x3D; 7.72s (99.72%)</span><br><span class="line">Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">查看下fmt.springf</span><br><span class="line">(pprof) list BenchmarkSprintf的执行情况</span><br><span class="line">Total: 7.72s</span><br><span class="line">ROUTINE &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; go.doglobal.net&#x2F;duapps&#x2F;do-feed&#x2F;service.BenchmarkSprintf in &#x2F;Users&#x2F;mengfanxing_g&#x2F;godev&#x2F;src&#x2F;go.doglobal.net&#x2F;duapps&#x2F;do-feed&#x2F;service&#x2F;contact_string_test.go</span><br><span class="line">      10ms      910ms (flat, cum) 11.79% of Total</span><br><span class="line">         .          .     13:func BenchmarkSprintf(b *testing.B) &#123;</span><br><span class="line">         .          .     14:   b.ResetTimer()</span><br><span class="line">         .          .     15:   for idx :&#x3D; 0; idx &lt; b.N; idx++ &#123;</span><br><span class="line">         .          .     16:           var s string</span><br><span class="line">         .          .     17:           for i :&#x3D; 0; i &lt; numbers; i++ &#123;</span><br><span class="line">      10ms      910ms     18:                   s &#x3D; fmt.Sprintf(&quot;%v%v&quot;, s, i)</span><br><span class="line">         .          .     19:           &#125;</span><br><span class="line">         .          .     20:   &#125;</span><br><span class="line">         .          .     21:   b.StopTimer()</span><br><span class="line">         .          .     22:&#125;</span><br><span class="line">         .          .     23:</span><br><span class="line">(pprof) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">查看下字符串拼接的执行情况</span><br><span class="line"></span><br><span class="line">ROUTINE &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; go.doglobal.net&#x2F;duapps&#x2F;do-feed&#x2F;service.BenchmarkStringAdd in &#x2F;Users&#x2F;mengfanxing_g&#x2F;godev&#x2F;src&#x2F;go.doglobal.net&#x2F;duapps&#x2F;do-feed&#x2F;service&#x2F;contact_string_test.go</span><br><span class="line">      20ms      410ms (flat, cum)  5.31% of Total</span><br><span class="line">         .          .     49:func BenchmarkStringAdd(b *testing.B) &#123;</span><br><span class="line">         .          .     50:   b.ResetTimer()</span><br><span class="line">         .          .     51:   for idx :&#x3D; 0; idx &lt; b.N; idx++ &#123;</span><br><span class="line">         .          .     52:           var s string</span><br><span class="line">         .          .     53:           for i :&#x3D; 0; i &lt; numbers; i++ &#123;</span><br><span class="line">      20ms      410ms     54:                   s +&#x3D; strconv.Itoa(i)</span><br><span class="line">         .          .     55:           &#125;</span><br><span class="line">         .          .     56:</span><br><span class="line">         .          .     57:   &#125;</span><br><span class="line">         .          .     58:   b.StopTimer()</span><br><span class="line">         .          .     59:&#125;</span><br><span class="line">(pprof) </span><br><span class="line"></span><br><span class="line">查看下bytes.buffer的执行情况</span><br><span class="line">(pprof) list BenchmarkBytesBuf</span><br><span class="line">ROUTINE &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; go.doglobal.net&#x2F;duapps&#x2F;do-feed&#x2F;service.BenchmarkBytesBuf in &#x2F;Users&#x2F;mengfanxing_g&#x2F;godev&#x2F;src&#x2F;go.doglobal.net&#x2F;duapps&#x2F;do-feed&#x2F;service&#x2F;contact_string_test.go</span><br><span class="line">      20ms      360ms (flat, cum)  4.66% of Total</span><br><span class="line">         .          .     36:</span><br><span class="line">         .          .     37:func BenchmarkBytesBuf(b *testing.B) &#123;</span><br><span class="line">         .          .     38:   b.ResetTimer()</span><br><span class="line">         .          .     39:   for idx :&#x3D; 0; idx &lt; b.N; idx++ &#123;</span><br><span class="line">         .          .     40:           var buf bytes.Buffer</span><br><span class="line">      10ms       10ms     41:           for i :&#x3D; 0; i &lt; numbers; i++ &#123;</span><br><span class="line">      10ms      320ms     42:                   buf.WriteString(strconv.Itoa(i))</span><br><span class="line">         .          .     43:           &#125;</span><br><span class="line">         .       30ms     44:           _ &#x3D; buf.String()</span><br><span class="line">         .          .     45:   &#125;</span><br><span class="line">         .          .     46:   b.StopTimer()</span><br><span class="line">         .          .     47:&#125;</span><br><span class="line">         .          .     48:</span><br><span class="line">         .          .     49:func BenchmarkStringAdd(b *testing.B) &#123;</span><br><span class="line">(pprof) </span><br><span class="line"></span><br><span class="line">查看下bytes.buffer的执行情况</span><br><span class="line">(pprof) list BenchmarkStringBuilder</span><br><span class="line">ROUTINE &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; go.doglobal.net&#x2F;duapps&#x2F;do-feed&#x2F;service.BenchmarkStringBuilder in &#x2F;Users&#x2F;mengfanxing_g&#x2F;godev&#x2F;src&#x2F;go.doglobal.net&#x2F;duapps&#x2F;do-feed&#x2F;service&#x2F;contact_string_test.go</span><br><span class="line">      50ms      750ms (flat, cum)  9.72% of Total</span><br><span class="line">         .          .     21:   b.StopTimer()</span><br><span class="line">         .          .     22:&#125;</span><br><span class="line">         .          .     23:</span><br><span class="line">         .          .     24:func BenchmarkStringBuilder(b *testing.B) &#123;</span><br><span class="line">         .          .     25:   b.ResetTimer()</span><br><span class="line">      20ms       20ms     26:   for idx :&#x3D; 0; idx &lt; b.N; idx++ &#123;</span><br><span class="line">         .          .     27:           var builder strings.Builder</span><br><span class="line">      10ms       10ms     28:           for i :&#x3D; 0; i &lt; numbers; i++ &#123;</span><br><span class="line">      20ms      720ms     29:                   builder.WriteString(strconv.Itoa(i))</span><br><span class="line">         .          .     30:</span><br><span class="line">         .          .     31:           &#125;</span><br><span class="line">         .          .     32:           _ &#x3D; builder.String()</span><br><span class="line">         .          .     33:   &#125;</span><br><span class="line">         .          .     34:   b.StopTimer()</span><br><span class="line">(pprof) </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在 Golang 1.10 以前，你可以使用bytes.Buffer来优化：一定程度上避免上面每进行一次拼接操作就重新申请新的内存空间存放中间字符串的问题。但这里依然有一个小问题： byte.String() 会有一次 []byte -&gt; string 类型转换。而这个操作是会进行一次内存分配和内容拷贝的。<br><br>如果你现在已经在使用 golang 1.10, 那么你还有一个更好的选择：strings.Builder<br><br> 原理解析关键代码摘选如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Builder struct &#123;</span><br><span class="line">    addr *Builder &#x2F;&#x2F; of receiver, to detect copies by value</span><br><span class="line">    buf  []byte &#x2F;&#x2F; 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Write appends the contents of p to b&#39;s buffer.</span><br><span class="line">&#x2F;&#x2F; Write always returns len(p), nil.</span><br><span class="line">func (b *Builder) Write(p []byte) (int, error) &#123;</span><br><span class="line">    b.copyCheck()</span><br><span class="line">    b.buf &#x3D; append(b.buf, p...) &#x2F;&#x2F; 2</span><br><span class="line">    return len(p), nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; String returns the accumulated string.</span><br><span class="line">func (b *Builder) String() string &#123;</span><br><span class="line">    return *(*string)(unsafe.Pointer(&amp;b.buf))  &#x2F;&#x2F; 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (b *Builder) copyCheck() &#123;</span><br><span class="line">    if b.addr &#x3D;&#x3D; nil &#123;</span><br><span class="line">        &#x2F;&#x2F; 4</span><br><span class="line">        &#x2F;&#x2F; This hack works around a failing of Go&#39;s escape analysis</span><br><span class="line">        &#x2F;&#x2F; that was causing b to escape and be heap allocated.</span><br><span class="line">        &#x2F;&#x2F; See issue 23382.</span><br><span class="line">        &#x2F;&#x2F; TODO: once issue 7921 is fixed, this should be reverted to</span><br><span class="line">        &#x2F;&#x2F; just &quot;b.addr &#x3D; b&quot;.</span><br><span class="line">        b.addr &#x3D; (*Builder)(noescape(unsafe.Pointer(b)))</span><br><span class="line">    &#125; else if b.addr !&#x3D; b &#123;</span><br><span class="line">        panic(&quot;strings: illegal use of non-zero Builder copied by value&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>1、与byte.Buffer思路类似，既然 string 在构建过程中会不断的被销毁重建，那么就尽量避免这个问题，底层使用一个 buf []byte 来存放字符串的内容。</li>
<li>2、对于写操作，就是简单的将byte写入到 buf 即可。</li>
<li>3、为了解决bytes.Buffer.String()存在的[]byte -&gt; string类型转换和内存拷贝问题，这里使用了一个unsafe.Pointer的存指针转换操作，实现了直接将buf []byte转换为 string类型，同时避免了内存充分配的问题</li>
</ul>
<p>结论：<br></p>
<ul>
<li>golang中的string类型也是只读且不可变的。因此，这种拼接字符串的方式会导致大量的string创建、销毁和内存分配。如果你拼接的字符串比较多的话，这显然不是一个正确的姿势。</li>
<li>fmt.springf() 内部使用 []byte 实现，不像直接运算符这种会产生很多临时的字符串，但是内部的逻辑比较复杂，有很多额外的判断，还用到了 interface</li>
<li>go1.10之前推荐使用buffer 、go1.10以后推荐使用builder</li>
</ul>
]]></content>
      <categories>
        <category>go</category>
        <category>性能调优</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go-语法糖原理-多重赋值</title>
    <url>/2020/08/05/go-%E8%AF%AD%E6%B3%95%E7%B3%96%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a:=<span class="number">1</span></span><br><span class="line">    b:=<span class="number">2</span></span><br><span class="line">    a,b=b,a</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们用dlv来看下编译之后的语句是什么样的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dlv debug basic/copy_value_multi.go</span><br><span class="line">Type &#x27;help&#x27; for list of commands.</span><br><span class="line">(dlv) b main.main</span><br><span class="line">Breakpoint 1 set at 0x105e7e0 for main.main() ./basic/copy_value_multi.go:3</span><br><span class="line">(dlv) r</span><br><span class="line">Process restarted with PID 19097</span><br><span class="line">(dlv) c</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> main.main() ./basic/copy_value_multi.go:3 (hits goroutine(1):1 total:1) (PC: 0x105e7e0)</span></span><br><span class="line">     1: package main</span><br><span class="line">     2: </span><br><span class="line">=&gt;   3: func main()&#123;</span><br><span class="line">     4:         a:=1</span><br><span class="line">     5:         b:=2</span><br><span class="line">     6:         a,b=b,a</span><br><span class="line">     7: </span><br><span class="line">     8: &#125;</span><br><span class="line">(dlv) disassemble</span><br><span class="line">TEXT main.main(SB) /Users/mengfanxing_g/godev/src/Richard/basic/copy_value_multi.go</span><br><span class="line">=&gt;      copy_value_multi.go:3   0x105e7e0*      4883ec20                sub rsp, 0x20</span><br><span class="line">        copy_value_multi.go:3   0x105e7e4       48896c2418              mov qword ptr [rsp+0x18], rbp</span><br><span class="line">        copy_value_multi.go:3   0x105e7e9       488d6c2418              lea rbp, ptr [rsp+0x18]</span><br><span class="line">        copy_value_multi.go:4   0x105e7ee       48c744240801000000      mov qword ptr [rsp+0x8], 0x1</span><br><span class="line">        // a:=1</span><br><span class="line">        copy_value_multi.go:5   0x105e7f7       48c7042402000000        mov qword ptr [rsp], 0x2</span><br><span class="line">        // b:=2</span><br><span class="line">        copy_value_multi.go:6   0x105e7ff       488b442408              mov rax, qword ptr [rsp+0x8]</span><br><span class="line">        copy_value_multi.go:6   0x105e804       4889442410              mov qword ptr [rsp+0x10], rax</span><br><span class="line">        // temp:=a</span><br><span class="line">        copy_value_multi.go:6   0x105e809       488b0424                mov rax, qword ptr [rsp]</span><br><span class="line">        copy_value_multi.go:6   0x105e80d       4889442408              mov qword ptr [rsp+0x8], rax</span><br><span class="line">        // a=b</span><br><span class="line">        copy_value_multi.go:6   0x105e812       488b442410              mov rax, qword ptr [rsp+0x10]</span><br><span class="line">        copy_value_multi.go:6   0x105e817       48890424                mov qword ptr [rsp], rax</span><br><span class="line">        // b=temp</span><br><span class="line">        copy_value_multi.go:8   0x105e81b       488b6c2418              mov rbp, qword ptr [rsp+0x18]</span><br><span class="line">        &lt;autogenerated&gt;:1       0x105e820       4883c420                add rsp, 0x20</span><br><span class="line">        &lt;autogenerated&gt;:1       0x105e824       c3                      ret</span><br><span class="line">(dlv) </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所以我们可以看出 其实是<code>编译器</code>在栈上创建了一个临时变量<code>temp</code> 然后按顺序交换其他各个变量的值</p>
]]></content>
      <categories>
        <category>go</category>
        <category>原理实现</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>golang 基础(一)</title>
    <url>/2020/08/05/golang-%E5%9F%BA%E7%A1%80-%E4%B8%80/</url>
    <content><![CDATA[<h1 id="golang-基础"><a href="#golang-基础" class="headerlink" title="golang 基础"></a>golang 基础</h1><h2 id="1-package"><a href="#1-package" class="headerlink" title="1.package"></a>1.package</h2><p>举个例子 如果Go安装再/usr/local/go ,并且环境变量GOPATH设置为 /home/myproject:/home/mylibraries,编译器就会按照下面的顺序查找net/http包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/local/go/src/pkg/net/http          &lt;--------------- 这是标准库源</span><br><span class="line"></span><br><span class="line">/home/myproject/src/net/http            &lt;--------------- 这是代码所在的位置</span><br><span class="line"></span><br><span class="line">/home/mylibraries/src/net/http          &lt;--------------- 这是代码所在的位置</span><br></pre></td></tr></table></figure>



<p>一旦编译器找到一个满足import 语句的包，就停止进一步查找， 有一件重要的事需要记住，编译器会首先在Go的安装目录查找，然后才会按顺序查找GOPATH变量里列出的目录。</p>
<p>如果编译器查遍gopath也没找到要导入的包，我们可以通过go get来修正这种错误，</p>
<p>go get具有递归特性，这个命令会扫描某个包的原码树，获取能找到的所有依赖包，并将包的原码保存在gopath指向的路径里与url匹配的目录里</p>
<h2 id="2-array-数组"><a href="#2-array-数组" class="headerlink" title="2.array 数组"></a>2.array 数组</h2><p>数组是一个长度固定的数据类型、用于存储一段具有相同数据类型的元素的连续块 、 元素可以是内置类型 也可以是某种结构类型</p>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul>
<li>容易计算索引、快速迭代所有元素</li>
<li>cpu能把正在使用的数据缓存更加持久</li>
<li>每个元素都会返回需要在内存中移动的距离</li>
<li>读取速度O(1)</li>
</ul>
<h3 id="使用-（声明和初始化）"><a href="#使用-（声明和初始化）" class="headerlink" title="使用 （声明和初始化）"></a>使用 （声明和初始化）</h3><ul>
<li>var array [5]int</li>
<li>array:=[5]int{10,20,30,40,50}</li>
<li>array:=[…]int{10,20,30}</li>
<li>array:=[5]int{1:10,2:20}</li>
</ul>
<h3 id="数组的复制"><a href="#数组的复制" class="headerlink" title="数组的复制"></a>数组的复制</h3><p>只有数组变量的类型包含数组的长度和每个元素的类型、只有这两部分相同的数组，才是类型相同的数组，才能相互赋值。</p>
<p>值拷贝 而不是地址拷贝</p>
<h3 id="多维数组同单个数组"><a href="#多维数组同单个数组" class="headerlink" title="多维数组同单个数组"></a>多维数组同单个数组</h3><h3 id="函数间的传递"><a href="#函数间的传递" class="headerlink" title="函数间的传递"></a>函数间的传递</h3><p>// 声明一个8MB的数组 int 8byte 800w 字节 8MB var arr [1e6] int</p>
<ul>
<li><p>值传递 foo（array [1e6]int） 每次调用这个函数，都必须在栈上分配8MB的内存</p>
</li>
<li><p>指针传递 foo（array *[1e6]int） foo函数接受一个指向100万个整型数组的指针 foo(&amp;arr)</p>
<p>这个操作会更有效的利用内存、性能也会更好，但是因为传递的是指针、所以如果改变指针指向的值，会改变共享的内存、 slice会更好的处理这个问题</p>
</li>
</ul>
<h2 id="3-slice"><a href="#3-slice" class="headerlink" title="3.slice"></a>3.slice</h2><p>切片是一种数据结构、这种数据结构能够便于使用和管理各种集合</p>
<h3 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h3><p>切片有三个字段的数据结构</p>
<ul>
<li>指向底层数组的指针</li>
<li>切片访问的元素的个数（切片的长度）</li>
<li>切片允许增长到的元素个数（容量）</li>
</ul>
<h3 id="切片的使用"><a href="#切片的使用" class="headerlink" title="切片的使用"></a>切片的使用</h3><ul>
<li><p>使用make</p>
<ul>
<li>使用一个长度声明一个字符串的切片</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个字符串切片 长度和容量都是5</span></span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">string</span>,<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用长度和容量声明整型切片</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个整型切片 长度为3个元素 容量为5个元素</span></span><br><span class="line">slice :=<span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">3</span>,<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>注：容量小于切片会报错</p>
</li>
</ul>
</li>
<li><p>使用字面量</p>
<ul>
<li><p>通过切片字面量来声明切片</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个字符串切片，长度和容量都是3</span></span><br><span class="line">slice:=[]<span class="keyword">string</span>&#123;<span class="string">&quot;red&quot;</span>.<span class="string">&quot;yellow&quot;</span>,<span class="string">&quot;green&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用索引声明切片</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">声明一个字符串切片、第<span class="number">100</span>个元素为空串</span><br><span class="line">slice:= []<span class="keyword">string</span>&#123;<span class="number">99</span>:<span class="string">&quot;&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>使用三个索引创建切片</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将第三个元素切片，并限制容量</span></span><br><span class="line"><span class="comment">// 其长度为 1 个元素，容量为 2 个元素 </span></span><br><span class="line">slice := source[<span class="number">2</span>:<span class="number">3</span>:<span class="number">4</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>切片和数组声明的不同点在于 []中有指定数字的或者… 为数组,剩余视为切片</p>
<h3 id="nil切片-表示空集合或者空切片很有用"><a href="#nil切片-表示空集合或者空切片很有用" class="headerlink" title="nil切片 (表示空集合或者空切片很有用)"></a>nil切片 (表示空集合或者空切片很有用)</h3><ul>
<li><p>创建nil切片</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个nil 整型切片</span></span><br><span class="line"><span class="keyword">var</span> slice []<span class="keyword">int</span></span><br><span class="line"><span class="comment">// slice的长度和容量都是0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>声明空切片</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个空的整型切片</span></span><br><span class="line">slice :=<span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment">// 使用字面量创建空的整型切片</span></span><br><span class="line">slice:=[]<span class="keyword">int</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="切片赋值和创建新的切片"><a href="#切片赋值和创建新的切片" class="headerlink" title="切片赋值和创建新的切片"></a>切片赋值和创建新的切片</h3><ul>
<li><p>赋值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">使用[]操作符修改某个元素的值</span><br><span class="line">slice := []<span class="keyword">string</span>&#123;<span class="string">&quot;red&quot;</span>,<span class="string">&quot;yellow&quot;</span>&#125;</span><br><span class="line">修改索引为<span class="number">1</span>的元素的值</span><br><span class="line">slice[<span class="number">1</span>]=<span class="string">&quot;black&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用切片创建切片 使用切片创建新的切片 会将底层数组切出一部分 ，新的切片无法可能无法访问全部的底层数组</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个整型数组、长度和容量都是5</span></span><br><span class="line">slice :=[]<span class="keyword">int</span>&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新的切片通过slice,长度是2 容量是4</span></span><br><span class="line">sliceNew:=slice[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"><span class="comment">// 修改 newSlice 索引为 1 的元素</span></span><br><span class="line"><span class="comment">// 同时也修改了原来的 slice 的索引为 2 的元素</span></span><br><span class="line">newSlice[<span class="number">1</span>] = <span class="number">35</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><img src="/images/image-20200325214011116.png" alt="image-20200325213325010"></p>
<h3 id="计算长度和容量"><a href="#计算长度和容量" class="headerlink" title="计算长度和容量"></a>计算长度和容量</h3><ul>
<li><p>对底层数组容量是k的切片slice[i:j] 或容量是5的slice[1:3]来说 </p>
<p>长度: j-i  或 3-1 = 2</p>
<p>容量:k-i 或 5-1 = 4</p>
</li>
<li><p>对于 slice[i:j:k] 或 [2:3:4]</p>
<p>长度: j – i 或 3 - 2 = 1<br>容量: k – i 或 4 - 2 = 2</p>
</li>
</ul>
<h3 id="修改切片内容可能会导致修改原来slice中的元素"><a href="#修改切片内容可能会导致修改原来slice中的元素" class="headerlink" title="修改切片内容可能会导致修改原来slice中的元素"></a>修改切片内容可能会导致修改原来slice中的元素</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个整型切片</span></span><br><span class="line"><span class="comment">// 其长度和容量都是 5 个元素</span></span><br><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;</span><br><span class="line"><span class="comment">// 创建一个新切片</span></span><br><span class="line"><span class="comment">// 其长度是 2 个元素，容量是 4 个元素</span></span><br><span class="line">newSlice := slice[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="append"><a href="#append" class="headerlink" title="append"></a>append</h3><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p> append 也是一个可变参数的函数。这意味着可以在一次调用传递多个追加的值。 </p>
<p>如果使用…运算符，可以将一个切片的所有元素追加到另一个切片里 </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建两个切片，并分别用两个整数进行初始化 </span></span><br><span class="line">s1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">s2 := []<span class="keyword">int</span>&#123;<span class="number">3</span>, <span class="number">4</span>&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 将两个切片追加在一起，并显示结果</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, <span class="built_in">append</span>(s1, s2...)) </span><br><span class="line">Output:</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<h4 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h4><p>append 会首先使用可用容量。一旦没有可用容量，会分配一个<br>新的底层数组。这导致很容易忘记切片间正在共享同一个底层数组</p>
<p>因为slice依赖其底层的array，修改slice本质是修改array，而array又是有大小限制，当超过slice的容量，即数组越界的时候，需要通过动态规划的方式创建一个新的数组块。把原有的数据复制到新数组，这个新的array则为slice新的底层依赖。</p>
<h4 id="扩容的规则"><a href="#扩容的规则" class="headerlink" title="扩容的规则"></a>扩容的规则</h4><p>函数 append 会智能地处理底层数组的容量增长。在切片的容量小于 1000 个元素时，总是<br>会成倍地增加容量。一旦元素个数超过 1000，容量的增长因子会设为 1.25，也就是会每次增加 25%<br>的容量。随着语言的演化，这种增长算法可能会有所改变</p>
<h4 id="设置容量和长度一致的好处"><a href="#设置容量和长度一致的好处" class="headerlink" title="设置容量和长度一致的好处"></a>设置容量和长度一致的好处</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建字符串切片</span></span><br><span class="line"><span class="comment">// 其长度和容量都是 5 个元素</span></span><br><span class="line">source := []<span class="keyword">string</span>&#123;<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Plum&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Grape&quot;</span>&#125;</span><br><span class="line"><span class="comment">// 对第三个元素做切片，并限制容量 // 其长度和容量都是 1 个元素 </span></span><br><span class="line">slice := source[<span class="number">2</span>:<span class="number">3</span>:<span class="number">3</span>]</span><br><span class="line"><span class="comment">// 向 slice 追加新字符串</span></span><br><span class="line">slice = <span class="built_in">append</span>(slice, <span class="string">&quot;Kiwi&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>如果在创建切片时设置切片的容量和长度一样，就可以强制让新切片的第一个 append 操作<br>创建新的底层数组，与原有的底层数组分离。新切片与原有的底层数组分离后，可以安全地进行<br>后续修改</p>
<p><img src="/images/image-20200325213325010.png" alt="image-20200325213325010"></p>
<h3 id="切片的遍历"><a href="#切片的遍历" class="headerlink" title="切片的遍历"></a>切片的遍历</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个整型切片</span></span><br><span class="line"><span class="comment">// 其长度和容量都是 4 个元素</span></span><br><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="range"><a href="#range" class="headerlink" title="range"></a>range</h5><p>使用空白标识符(下划线)来忽略索引值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 迭代每个元素，并显示其值</span></span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> slice &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Value: %d\n&quot;</span>, value) &#125;</span><br></pre></td></tr></table></figure>

<h5 id="for"><a href="#for" class="headerlink" title="for"></a>for</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从第三个元素开始迭代每个元素</span></span><br><span class="line"><span class="keyword">for</span> index := <span class="number">2</span>; index &lt; <span class="built_in">len</span>(slice); index++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Index: %d Value: %d\n&quot;</span>, index, slice[index]) &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="函数间切片的传递"><a href="#函数间切片的传递" class="headerlink" title="函数间切片的传递"></a>函数间切片的传递</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分配包含 100 万个整型值的切片 </span></span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">1e6</span>)</span><br><span class="line"><span class="comment">// 将 slice 传递到函数 foo slice = foo(slice) </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数 foo 接收一个整型切片，并返回这个切片</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(sliceFoo []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123; </span><br><span class="line">  ... </span><br><span class="line">  <span class="keyword">return</span> slice</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span> <span class="params">(s *[]<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">  (*s)[<span class="number">0</span>] = </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="值传递-副本拷贝"><a href="#值传递-副本拷贝" class="headerlink" title="值传递(副本拷贝)"></a>值传递(副本拷贝)</h5><pre><code>函数foo接收的是sliceFoo 是  slice的一个值拷贝，两个切片指向的地址都同一个底层数组，foo函数返回的是sliceFoo 有可能和slice的值不一样</code></pre>
<h5 id="地址传递"><a href="#地址传递" class="headerlink" title="地址传递"></a>地址传递</h5><p>   函数modify接收s是指向int数组的一个指针，当对s进行修改的同时，修改的就是底层数组的数据</p>
<h2 id="4-映射Map"><a href="#4-映射Map" class="headerlink" title="4 映射Map"></a>4 映射Map</h2><p>含义：映射是一种数据结构，用于存储一系列无序的键值对，只有能够比较的类型才能作为key的类型，所以例如切片、函数、map类型是不能作为map的key，而且map是非线程安全的，如果多goroutine中需要自己维护线程安全</p>
<h3 id="内部实现-1"><a href="#内部实现-1" class="headerlink" title="内部实现"></a>内部实现</h3><p>无序的原因是因为映射使用了散列表，</p>
<p>解决hash冲突的办法有1、开放地址法，2、拉链法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    count     <span class="keyword">int</span></span><br><span class="line">    flags     <span class="keyword">uint8</span></span><br><span class="line">    B         <span class="keyword">uint8</span></span><br><span class="line">    noverflow <span class="keyword">uint16</span></span><br><span class="line">    hash0     <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line">    buckets    unsafe.Pointer</span><br><span class="line">    oldbuckets unsafe.Pointer</span><br><span class="line">    nevacuate  <span class="keyword">uintptr</span></span><br><span class="line"></span><br><span class="line">    extra *mapextra</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li><code>count</code> 表示当前哈希表中的元素数量；</li>
<li><code>B</code> 表示当前哈希表持有的 <code>buckets</code> 数量，但是因为哈希表中桶的数量都 2 的倍数，所以该字段会存储对数，也就是 <code>len(buckets) == 2^B</code>；</li>
<li><code>hash0</code> 是哈希的种子，它能为哈希函数的结果引入随机性，这个值在创建哈希表时确定，并在调用哈希函数时作为参数传入；</li>
<li><code>oldbuckets</code> 是哈希在扩容时用于保存之前 <code>buckets</code> 的字段，它的大小是当前 <code>buckets</code> 的一半；</li>
</ol>
<p><img src="/images/2019-12-30-15777168478811-hmap-and-buckets.png" alt="hmap-and-buckets"></p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>golang开发技巧-实现抽象类</title>
    <url>/2020/10/14/golang%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7-%E5%AE%9E%E7%8E%B0%E6%8A%BD%E8%B1%A1%E7%B1%BB/</url>
    <content><![CDATA[<p>本文介绍了一种通过 struct 和 interface 来在 golang 中实现抽象类的方式。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 Java 这种面向对象的语言中，抽象类和接口是我们经常会运用到的 2 种对抽象概念进行定义的机制。在 golang 中，没有类和继承的概念。golang 中有结构体（struct），和面向对象语言中的类相似。golang 中也有接口（interface），接口可以定义一组不含有具体实现的方法，其提供了一种方式来说明对象的行为。</p>
<p>然而，在某些情况下，我们需要使用抽象类继承，来帮助我们写出更优雅的代码。可是在 golang 中又没有抽象类的概念，本文将介绍一种通过 struct 和 interface 来在 golang 中实现抽象类的方法。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>首先，我们会用 Java 语言作为示例，来看看如何在面向对象语言中实现抽象类。接着换 golang 语言，通过 struct 和 interface 来实现抽象类，完成相同的功能。</p>
<h4 id="面向对象语言中抽象类的实现"><a href="#面向对象语言中抽象类的实现" class="headerlink" title="面向对象语言中抽象类的实现"></a>面向对象语言中抽象类的实现</h4><p>假设我们需要实现下面这样的几个类（使用 Java 为例）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Game</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name() + <span class="string">&quot; is awesome!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dota</span> <span class="keyword">extends</span> <span class="title">Game</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Dota&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LOL</span> <span class="keyword">extends</span> <span class="title">Game</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;LOL&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们定义了 Game 抽象类，在此类中定义了 <code>public abstract String name();</code> 一个抽象方法和 <code>public void play()</code> 这样一个公开方法。然后我们定义了 <code>Dota</code> 和 <code>LOL</code> 2个类去继承 <code>Game</code>，并各自实现了 <code>public String name()</code>。</p>
<p>接下来让我们看看如何在 golang 中实现抽象类。</p>
<h4 id="golang-中实现抽象类的方式"><a href="#golang-中实现抽象类的方式" class="headerlink" title="golang 中实现抽象类的方式"></a>golang 中实现抽象类的方式</h4><ul>
<li>定义 interface</li>
</ul>
<p>首先，我们需要将抽象方法定义在 interface 中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> IGame <span class="keyword">interface</span> &#123;</span><br><span class="line">    Name() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>定义”父类”</li>
</ul>
<p>然后，我们需要使用 struct 实现公共方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Game <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Game)</span> <span class="title">play</span><span class="params">(game IGame)</span></span> &#123;</span><br><span class="line">    fmt.Printf(fmt.Sprintf(<span class="string">&quot;%s is awesome!&quot;</span>, game.Name()))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是重点，我们将 <code>game IGame</code> 传了进来。这样我们便可以调用”子类”的方法来获取名字。<strong>从而间接地实现了在公共方法中调用不同”子类”的实现的抽象方法。</strong></p>
<ul>
<li>定义”子类”</li>
</ul>
<p>接着，我们再定义”Dota”和”LOL”这 2 个 struct 即可。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Dota <span class="keyword">struct</span> &#123;</span><br><span class="line">    Game</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dota)</span> <span class="title">Name</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Dota&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LOL <span class="keyword">struct</span> &#123;</span><br><span class="line">    Game</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LOL)</span> <span class="title">Name</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;LOL&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>大功告成</li>
</ul>
<p>现在，在初始化”Dota”和”LOL”结构体后，便可以调用 <code>func (g *Game) play(game IGame)</code> 方法了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">dota := &amp;Dota&#123;&#125;</span><br><span class="line">dota.play(dota)</span><br><span class="line"></span><br><span class="line">lol := &amp;LOL&#123;&#125;</span><br><span class="line">lol.play(lol)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">//Dota is awesome!</span></span><br><span class="line"><span class="comment">//LOL is awesome!</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文通过 struct 和 interface 的组合，提供了一种思路，间接实现了面向对象语言中的抽象类继承的模式。旨在提供一种思路，希望能帮助到需要的同学，欢迎讨论 :)</p>
]]></content>
  </entry>
  <entry>
    <title>golang技术准备</title>
    <url>/2020/10/13/golang%E6%8A%80%E6%9C%AF%E5%87%86%E5%A4%87/</url>
    <content><![CDATA[<p>golang技术准备</p>
<ol>
<li>数据结构与算法</li>
<li>设计模式  </li>
<li>golang基本知识&amp;底层实现原理</li>
<li>中间件 redis、mq、mysql、mangodb、memcache、dynamodb </li>
<li>线程和携程 </li>
<li>golang和java的对比</li>
<li>mysql分库分表 深入理解索引 二叉树 红黑树</li>
<li>docker&amp;k8s的使用  </li>
<li>CI/CD 的使用</li>
<li>gRPC&amp;go-kit&amp;goMicro的使用 </li>
<li>项目经验 </li>
<li>带团队经验</li>
</ol>
<p>1、设计模式 23种 预计23个小时</p>
<p>2、数据结构与算法 200道题 200个小时</p>
<p>3、golang基本知识&amp;底层实现原理 50个小时</p>
<p>​         <a href="https://tiancaiamao.gitbooks.io/go-internals/content/zh/06.2.html">https://tiancaiamao.gitbooks.io/go-internals/content/zh/06.2.html</a></p>
<p>​        <a href="https://mubu.com/doc/explore/23357">https://mubu.com/doc/explore/23357</a></p>
<p>​    <a href="https://mubu.com/doc/explore/23447">https://mubu.com/doc/explore/23447</a></p>
<p><a href="https://adolphlwq.xyz/blog/#/go/basics">https://adolphlwq.xyz/blog/#/go/basics</a></p>
<p><strong><a href="https://www.processon.com/view/link/5a9ba4c8e4b0a9d22eb3bdf0#map">https://www.processon.com/view/link/5a9ba4c8e4b0a9d22eb3bdf0#map</a></strong></p>
<ol start="4">
<li>中间件 redis、mq、mysql、mangodb、memcache、dynamodb  20个小时</li>
<li>2个小时</li>
<li>1个小时</li>
<li>10个小时</li>
<li>5个小时</li>
</ol>
<p>预计300个小时 每天工作 2个小时 回家2个小时  预计75d  3个月</p>
<p>规划 </p>
<p>每天任务 </p>
<p>1个设计模式  </p>
<p>1个leetcode</p>
<p>1个go的底层知识</p>
<p>1 个 mysql或者redis原理</p>
<p>在过去的几年中，Go语言的发展是惊人的，并且吸引了很多由其他语言（Python、PHP、Ruby）转向Go语言的跨语言学习者。 Go语言太容易实现并发了，以至于它在很多地方被不正确的使用了。</p>
]]></content>
  </entry>
  <entry>
    <title>golang源码学习之interface的底层实现</title>
    <url>/2020/11/22/golang%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B9%8Binterface%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h3 id="interface的底层实现"><a href="#interface的底层实现" class="headerlink" title="interface的底层实现"></a>interface的底层实现</h3><p>在golang中，interface也是一个结构体，记录了2个指针：</p>
<ul>
<li>指针1，指向该变量的类型</li>
<li>指针2，指向该变量的value</li>
</ul>
<p>_type<code>可以认为是Go语言中所有类型的公共描述，Go语言中几乎所有的数据结构都可以抽象成</code>_type<code>，是所有类型的表现，可以说是万能类型， </code>data`是指向具体数据的指针。 </p>
]]></content>
  </entry>
  <entry>
    <title>golang源码学习之如何判断一个channel已关闭</title>
    <url>/2020/11/21/golang%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AAchannel%E5%B7%B2%E5%85%B3%E9%97%AD/</url>
    <content><![CDATA[<h3 id="如何判断一个channel已经关闭"><a href="#如何判断一个channel已经关闭" class="headerlink" title="如何判断一个channel已经关闭"></a>如何判断一个channel已经关闭</h3><ol>
<li><p>从channel中读取数据</p>
<ol>
<li>第二个字段为true时 证明channel可能没关闭、也可能已经关闭了、不能证明什么</li>
<li>第二个字段为false时，可以证明channel中已经没有残留数据、且已经关闭</li>
</ol>
</li>
<li><p>如果channel c已经被关闭,继续往它发送数据会导致<code>panic: send on closed channel</code>:</p>
<p>但是从这个关闭的channel中不但可以读取出已发送的数据，还可以不断的读取零值:</p>
</li>
<li><p>如果通过<code>range</code>读取，channel关闭后for循环会跳出：</p>
</li>
<li><p>可以直接读取channel结构hchan的closed字段，但问题chan.go没有开放这样的api，所以我们要用reflect这个黑科技了。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// xiaorui.cc  https://blog.csdn.net/cyb_17302190874/article/details/106771295</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isChanClosed</span><span class="params">(ch <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> reflect.TypeOf(ch).Kind() != reflect.Chan &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;only channels!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    cptr := *(*<span class="keyword">uintptr</span>)(unsafe.Pointer(</span><br><span class="line">        unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;ch)) + unsafe.Sizeof(<span class="keyword">uint</span>(<span class="number">0</span>))),</span><br><span class="line">    ))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this function will return true if chan.closed &gt; 0</span></span><br><span class="line">    <span class="comment">// see hchan on https://github.com/golang/go/blob/master/src/runtime/chan.go</span></span><br><span class="line">    <span class="comment">// type hchan struct &#123;</span></span><br><span class="line">    <span class="comment">// qcount   uint           // total data in the queue</span></span><br><span class="line">    <span class="comment">// dataqsiz uint           // size of the circular queue</span></span><br><span class="line">    <span class="comment">// buf      unsafe.Pointer // points to an array of dataqsiz elements</span></span><br><span class="line">    <span class="comment">// elemsize uint16</span></span><br><span class="line">    <span class="comment">// closed   uint32</span></span><br><span class="line">    <span class="comment">// **</span></span><br><span class="line"></span><br><span class="line">    cptr += unsafe.Sizeof(<span class="keyword">uint</span>(<span class="number">0</span>))*<span class="number">2</span></span><br><span class="line">    cptr += unsafe.Sizeof(unsafe.Pointer(<span class="keyword">uintptr</span>(<span class="number">0</span>)))</span><br><span class="line">    cptr += unsafe.Sizeof(<span class="keyword">uint16</span>(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> *(*<span class="keyword">uint32</span>)(unsafe.Pointer(cptr)) &gt; <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>配合一个context或者一个变量来做。就拿context来说，那么select不仅可以读取数据chan，且同事监听&lt;- context.Done() , 当context.Done()有事件，直接退出就ok了。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 转自https://blog.csdn.net/cyb_17302190874/article/details/106771295</span></span><br><span class="line"> ...</span><br><span class="line">    ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">    <span class="built_in">close</span>(c)</span><br><span class="line">    cancel()</span><br><span class="line">exit:</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> data, ok := &lt;-c:</span><br><span class="line">            fmt.Println(data, ok)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            <span class="keyword">break</span> exit</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     ...</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>golang设计模式之单例模式</title>
    <url>/2020/10/13/golang%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>在过去的几年中，Go语言的发展是惊人的，并且吸引了很多由其他语言（Python、PHP、Ruby）转向Go语言的跨语言学习者。 Go语言太容易实现并发了，以至于它在很多地方被不正确的使用了。</p>
<h2 id="Go语言中的单例模式"><a href="#Go语言中的单例模式" class="headerlink" title="Go语言中的单例模式"></a>Go语言中的单例模式</h2><p>在过去的几年中，Go语言的发展是惊人的，并且吸引了很多由其他语言（Python、PHP、Ruby）转向Go语言的跨语言学习者。</p>
<p>在过去的很长时间里，很多开发人员和初创公司都习惯使用Python、PHP或Ruby快速开发功能强大的系统，并且大多数情况下都不需要担心内部事务如何工作，也不需要担心线程安全性和并发性。直到最近几年，多线程高并发的系统开始流行起来，我们现在不仅需要快速开发功能强大的系统，而且还要保证被开发的系统能够足够快速运行。（我们真是太难了☺️）</p>
<p>对于被Go语言天生支持并发的特性吸引来的跨语言学习者来说，我觉着掌握Go语言的语法并不是最难的，最难的是突破既有的思维定势，真正理解并发和使用并发来解决实际问题。</p>
<p>Go语言太容易实现并发了，以至于它在很多地方被不正确的使用了。</p>
<h3 id="常见的错误"><a href="#常见的错误" class="headerlink" title="常见的错误"></a>常见的错误</h3><p>有一些错误是很常见的，比如不考虑并发安全的单例模式。就像下面的示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> singleton <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance *singleton</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span> *<span class="title">singleton</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> instance == <span class="literal">nil</span> &#123;</span><br><span class="line">        instance = &amp;singleton&#123;&#125;   <span class="comment">// 不是并发安全的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述情况下，多个goroutine可以执行第一个检查，并且它们都将创建该<code>singleton</code>类型的实例并相互覆盖。无法保证它将在此处返回哪个实例，并且对该实例的其他进一步操作可能与开发人员的期望不一致。</p>
<p>不好的原因是，如果有代码保留了对该单例实例的引用，则可能存在具有不同状态的该类型的多个实例，从而产生潜在的不同代码行为。这也成为调试过程中的一个噩梦，并且很难发现该错误，因为在调试时，由于运行时暂停而没有出现任何错误，这使非并发安全执行的可能性降到了最低，并且很容易隐藏开发人员的问题。</p>
<h3 id="激进的加锁"><a href="#激进的加锁" class="headerlink" title="激进的加锁"></a>激进的加锁</h3><p>也有很多对这种并发安全问题的糟糕解决方案。使用下面的代码确实能解决并发安全问题，但会带来其他潜在的严重问题，通过加锁把对该函数的并发调用变成了串行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mu Sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span> *<span class="title">singleton</span></span> &#123;</span><br><span class="line">    mu.Lock()                    <span class="comment">// 如果实例存在没有必要加锁</span></span><br><span class="line">    <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> instance == <span class="literal">nil</span> &#123;</span><br><span class="line">        instance = &amp;singleton&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们可以看到在创建单例实例之前通过引入<code>Sync.Mutex</code>和获取Lock来解决并发安全问题。问题是我们在这里执行了过多的锁定，即使我们不需要这样做，在实例已经创建的情况下，我们应该简单地返回缓存的单例实例。在高度并发的代码基础上，这可能会产生瓶颈，因为一次只有一个goroutine可以获得单例实例。</p>
<p>因此，这不是最佳方法。我们必须考虑其他解决方案。</p>
<h3 id="Check-Lock-Check模式"><a href="#Check-Lock-Check模式" class="headerlink" title="Check-Lock-Check模式"></a>Check-Lock-Check模式</h3><p>在C ++和其他语言中，确保最小程度的锁定并且仍然是并发安全的最佳和最安全的方法是在获取锁定时利用众所周知的<code>Check-Lock-Check</code>模式。该模式的伪代码表示如下。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> check() &#123;</span><br><span class="line">    lock() &#123;</span><br><span class="line">        <span class="keyword">if</span> check() &#123;</span><br><span class="line">            <span class="comment">// 在这里执行加锁安全的代码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该模式背后的思想是，你应该首先进行检查，以最小化任何主动锁定，因为IF语句的开销要比加锁小。其次，我们希望等待并获取互斥锁，这样在同一时刻在那个块中只有一个执行。但是，在第一次检查和获取互斥锁之间，可能有其他goroutine获取了锁，因此，我们需要在锁的内部再次进行检查，以避免用另一个实例覆盖了实例。</p>
<p>如果将这种模式应用于我们的<code>GetInstance()</code>方法，我们会写出类似下面的代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span> *<span class="title">singleton</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> instance == <span class="literal">nil</span> &#123;     <span class="comment">// 不太完美 因为这里不是完全原子的</span></span><br><span class="line">        mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> instance == <span class="literal">nil</span> &#123;</span><br><span class="line">            instance = &amp;singleton&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过使用<code>sync/atomic</code>这个包，我们可以原子化加载并设置一个标志，该标志表明我们是否已初始化实例。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> initialized <span class="keyword">uint32</span></span><br><span class="line">... <span class="comment">// 此处省略</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span> *<span class="title">singleton</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> atomic.LoadUInt32(&amp;initialized) == <span class="number">1</span> &#123;  <span class="comment">// 原子操作 </span></span><br><span class="line">            <span class="keyword">return</span> instance</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> initialized == <span class="number">0</span> &#123;</span><br><span class="line">         instance = &amp;singleton&#123;&#125;</span><br><span class="line">         atomic.StoreUint32(&amp;initialized, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是……这看起来有点繁琐了，我们其实可以通过研究Go语言和标准库如何实现goroutine同步来做得更好。</p>
<h3 id="Go语言惯用的单例模式"><a href="#Go语言惯用的单例模式" class="headerlink" title="Go语言惯用的单例模式"></a>Go语言惯用的单例模式</h3><p>我们希望利用Go惯用的方式来实现这个单例模式。我们在标准库<code>sync</code>中找到了<code>Once</code>类型。它能保证某个操作仅且只执行一次。下面是来自Go标准库的源码（部分注释有删改）。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Once is an object that will perform exactly one action.</span></span><br><span class="line"><span class="keyword">type</span> Once <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// done indicates whether the action has been performed.</span></span><br><span class="line">    <span class="comment">// It is first in the struct because it is used in the hot path.</span></span><br><span class="line">    <span class="comment">// The hot path is inlined at every call site.</span></span><br><span class="line">    <span class="comment">// Placing done first allows more compact instructions on some architectures (amd64/x86),</span></span><br><span class="line">    <span class="comment">// and fewer instructions (to calculate offset) on other architectures.</span></span><br><span class="line">    done <span class="keyword">uint32</span></span><br><span class="line">    m    Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">Do</span><span class="params">(f <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> atomic.LoadUint32(&amp;o.done) == <span class="number">0</span> &#123; <span class="comment">// check</span></span><br><span class="line">        <span class="comment">// Outlined slow-path to allow inlining of the fast-path.</span></span><br><span class="line">        o.doSlow(f)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">doSlow</span><span class="params">(f <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">    o.m.Lock()                          <span class="comment">// lock</span></span><br><span class="line">    <span class="keyword">defer</span> o.m.Unlock()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> o.done == <span class="number">0</span> &#123;                    <span class="comment">// check</span></span><br><span class="line">        <span class="keyword">defer</span> atomic.StoreUint32(&amp;o.done, <span class="number">1</span>)</span><br><span class="line">        f()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这说明我们可以借助这个实现只执行一次某个函数/方法，<code>once.Do()</code>的用法如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 在这里执行安全的初始化</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>下面就是单例实现的完整代码，该实现利用<code>sync.Once</code>类型去同步对<code>GetInstance()</code>的访问，并确保我们的类型仅被初始化一次。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> singleton <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance *singleton</span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span> *<span class="title">singleton</span></span> &#123;</span><br><span class="line">    once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        instance = &amp;singleton&#123;&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，使用<code>sync.Once</code>包是安全地实现此目标的首选方式，类似于Objective-C和Swift（Cocoa）实现<code>dispatch_once</code>方法来执行类似的初始化。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>当涉及到并发和并行代码时，需要对代码进行更仔细的检查。始终让你的团队成员执行代码审查，因为这样的事情很容易就会被发现。</p>
<p>所有刚转到Go语言的新开发人员都必须真正了解并发安全性如何工作以更好地改进其代码。即使Go语言本身通过允许你在对并发性知识知之甚少的情况下设计并发代码，也完成了许多繁重的工作。在某些情况下，单纯的依靠语言特性也无能为力，你仍然需要在开发代码时应用最佳实践。</p>
<p>翻译自<a href="http://marcio.io/2015/07/singleton-pattern-in-go/%EF%BC%8C%E8%80%83%E8%99%91%E5%88%B0%E5%8F%AF%E8%AF%BB%E6%80%A7%E9%83%A8%E5%88%86%E5%86%85%E5%AE%B9%E6%9C%89%E4%BF%AE%E6%94%B9%E3%80%82">http://marcio.io/2015/07/singleton-pattern-in-go/，考虑到可读性部分内容有修改。</a></p>
]]></content>
  </entry>
  <entry>
    <title>golang设计模式之原型模式.md </title>
    <url>/2020/10/15/golang%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>wiki:原型模式是创建型模式的一种，其特点在于通过“复制”一个已经存在的实例来返回新的实例,而不是新建实例。被复制的实例就是我们所称的“原型”，这个原型是可定制的。原型模式多用于创建复杂的或者耗时的实例，因为这种情况下，复制一个已经存在的实例使程序运行更高效；或者创建值相等，只是命名不一样的同类数据。</p>
</blockquote>
<p>这是一个十分简单的设计模式,可以看做是其他语言中的克隆方法，例如 <code>JAVA</code>/<code>PHP</code> 中都有相关方法，从一个内存中已经存在的对象中，拷贝出一个一模一样的对象来，针对复杂对象或比较大的对象，要比使用各种设计模式<code>new</code>出来的对象要快的多,</p>
<p>而且原型模式很少单独使用，一般与其他对象结合使用。</p>
<h3 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h3><ol>
<li><p>创建一个结构体</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  &#x2F;&#x2F; 示例结构体</span><br><span class="line">  type Example struct &#123;</span><br><span class="line">      Content string</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加克隆方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  func (e *Example) Clone() *Example &#123;</span><br><span class="line">      res :&#x3D; *e</span><br><span class="line">      return &amp;res</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>我们仅仅一行代码就完成了值的拷贝，使用 <code>*指针</code>，直接获取了一个拷贝的值，然后将这个拷贝的值得指针返回，原理请阅读下面的扩展阅读。</p>
</li>
<li><p>编写主代码</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   func main() &#123;</span><br><span class="line">       r1 :&#x3D; new(Example)</span><br><span class="line">       r1.Content &#x3D; &quot;this is example 1&quot;</span><br><span class="line">       r2 :&#x3D; r1.Clone()</span><br><span class="line">       r2.Content &#x3D; &quot;this is example 2&quot;</span><br><span class="line">   </span><br><span class="line">       fmt.Println(r1)</span><br><span class="line">       fmt.Println(r2)</span><br><span class="line">   </span><br><span class="line">   &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="扩展阅读-深拷贝与浅拷贝"><a href="#扩展阅读-深拷贝与浅拷贝" class="headerlink" title="扩展阅读: 深拷贝与浅拷贝"></a>扩展阅读: 深拷贝与浅拷贝</h3><p><code>go</code> 语言中的传递都是值传递，传递一个对象，就会把对象拷贝一份传入函数中，传递一个指针，就会把指针拷贝一份传入进去。</p>
<p>赋值的时候也是这样，<code>res:=*e</code> 就会把传递的 <code>Example</code> 对象拷贝一份，如果是 <code>res:=e</code> 的话，那么拷贝的就是对象的指针了.</p>
<p>而深拷贝和浅拷贝也可以这样理解，深拷贝就是拷贝整个对象，浅拷贝就是拷贝对象指针。</p>
<p>对于深度拷贝，<code>go</code>和其他语言还经常使用序列化后反序列化的形式进行拷贝:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> func deepCopy(dst, src interface&#123;&#125;) error &#123;</span><br><span class="line">     var buf bytes.Buffer</span><br><span class="line">     if err :&#x3D; gob.NewEncoder(&amp;buf).Encode(src); err !&#x3D; nil &#123;</span><br><span class="line">         return err</span><br><span class="line">     &#125;</span><br><span class="line">     return gob.NewDecoder(bytes.NewBuffer(buf.Bytes())).Decode(dst)</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>实际上<code>gob</code>包序列化的时候也是用到了 <code>reflect</code>包来实现拷贝的</p>
<p><strong>注意:</strong> golang完全是按值传递，所以如果深度拷贝的对象中包含有指针的话，那么深度拷贝后，这些指针也会相同，会导致部分数据共享，要注意这一点.</p>
]]></content>
  </entry>
  <entry>
    <title>golang设计模式之工厂方法模式</title>
    <url>/2020/10/13/golang%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="golang设计模式之工厂方法模式"><a href="#golang设计模式之工厂方法模式" class="headerlink" title="golang设计模式之工厂方法模式"></a>golang设计模式之工厂方法模式</h1><h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><blockquote>
<p>wiki: 工厂方法模式（英语：Factory method pattern）是一种实现了“工厂”概念的面向对象设计模式。就像其他创建型模式一样，它也是处理在不指定对象具体类型的情况下创建对象的问题。工厂方法模式的实质是“定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。”</p>
</blockquote>
<p>上面是 维基百科 中对工厂方法的定义，唯一的一个工厂控制着 所有产品的实例化，而 <code>工厂方法</code> 中包括一个工厂接口，我们可以动态的实现多种工厂，达到扩展的目的</p>
<ul>
<li>简单工厂需要:<ol>
<li>工厂结构体</li>
<li>产品接口</li>
<li>产品结构体</li>
</ol>
</li>
<li>工厂方法需要:<ol>
<li>工厂接口</li>
<li>工厂结构体</li>
<li>产品接口</li>
<li>产品结构体</li>
</ol>
</li>
</ul>
<p>在 <code>简单工厂</code> 中，依赖于唯一的工厂对象，如果我们需要实例化一个产品，那么就要向工厂中传入一个参数获取对应对象，如果要增加一种产品，就要在工厂中修改创建产品的函数，耦合性过高 ，而在 <code>工厂方法</code> 中，依赖工厂接口，我们可以通过实现工厂接口，创建多种工厂，将对象创建由一个对象负责所有具体类的实例化，变成由一群子类来负责对具体类的实例化，将过程解耦。</p>
<p>下面用代码实现：</p>
<p>例如，我们现在有一个产品需要被创建，那么先构建工厂接口和产品接口</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 工厂接口</span></span><br><span class="line"> <span class="keyword">type</span> FactoryInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">       CreateProduct(t <span class="keyword">string</span>) ProductInterface</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 产品接口</span></span><br><span class="line"><span class="keyword">type</span> ProductInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">    Intro()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后实现这两个接口: 工厂结构体和产品结构体</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建工厂结构体并实现工厂接口</span></span><br><span class="line"><span class="keyword">type</span> Factory1 <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f Factory1)</span> <span class="title">CreateProduct</span><span class="params">(t <span class="keyword">string</span>)</span> <span class="title">ProductInterface</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> t &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;product1&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> Product1&#123;&#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建产品1并实现产品接口</span></span><br><span class="line"><span class="keyword">type</span> Product1 <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Product1)</span> <span class="title">Intro</span><span class="params">()</span></span> &#123;</span><br><span class="line"> fmt.Println(<span class="string">&quot;this is product 1&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样在使用的时候，就可以让子类来选择实例化哪种产品:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建工厂</span></span><br><span class="line">    f := <span class="built_in">new</span>(Factory1)</span><br><span class="line"></span><br><span class="line">    p := f.CreateProduct(<span class="string">&quot;product1&quot;</span>)</span><br><span class="line">    p.Intro()  <span class="comment">// output:  this is product 1.</span></span><br></pre></td></tr></table></figure>

<p>或许上面的代码看起来并不容易懂，因为我们只有一种产品，不能看出来它的好处，在网上我看到了一个卖包子的例子，我觉得很贴切，在这我就用go实现一下,辅助理解:</p>
<p>栗子: 我现在想在我的老家齐齐哈尔开一家包子店，卖猪肉馅和三鲜馅两种馅料的包子，那么我们使用简单工厂模式应该怎样实现呢？</p>
<ul>
<li><p>简单工厂模式实现:</p>
<ol>
<li><p>创建工厂结构体（包子店）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 工厂类(包子店)</span></span><br><span class="line"><span class="keyword">type</span> BunShop <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建产品接口(包子类的接口)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Bun <span class="keyword">interface</span> &#123;</span><br><span class="line">    create()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现产品（2种包子）</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> PigMeatBuns <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p PigMeatBuns)</span> <span class="title">create</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;猪肉馅包子&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> SamSunStuffingBuns <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s SamSunStuffingBuns)</span> <span class="title">create</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;三鲜馅包子&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>为工厂添加生产包子的方法</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b BunShop)</span> <span class="title">Generate</span><span class="params">(t <span class="keyword">string</span>)</span> <span class="title">Bun</span></span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> t &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;pig&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> PigMeatBuns&#123;&#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;3s&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> SamSunStuffingBuns&#123;&#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>这样一个简单工厂模式就完成了:</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">factory := <span class="built_in">new</span>(BunShop)</span><br><span class="line">b := factory.Generate(<span class="string">&quot;pig&quot;</span>)</span><br><span class="line">b.create() <span class="comment">// output: 猪肉馅包子</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>可是如果生意做的不错，我想要在广东开一家分店该怎么办呢？依旧是两种包子，但是为了符合当地人的口味，一定会有所差别，难道要一步一步的修改工厂类吗？</p>
<p>这样工厂方法模式就派上用场了…</p>
<ol>
<li><p>添加工厂接口(包子店的接口)和产品接口(包子接口)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> BunShopInterface <span class="keyword">interface</span>&#123;</span><br><span class="line">   Generate(t <span class="keyword">string</span>) Bun</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">type</span> Bun <span class="keyword">interface</span> &#123;</span><br><span class="line">   create()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建工厂结构体和产品结构体（具体包子店和具体包子）</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> QSPigMeatBuns <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> GDPigMeatBuns <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> QSSamSunStuffingBuns <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> GDSamSunStuffingBuns <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现产品接口...  这里就不写了</span></span><br><span class="line"><span class="comment">// CODE ...</span></span><br></pre></td></tr></table></figure>

<ol>
<li>创建对应的工厂（齐市包子店和广东包子店）</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> QSBunShop <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GDBunShop <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(qs QSBunShop)</span> <span class="title">Generate</span><span class="params">(t <span class="keyword">string</span>)</span> <span class="title">Bun</span></span> &#123;</span><br><span class="line">   <span class="keyword">switch</span> t &#123;</span><br><span class="line">       <span class="keyword">case</span> <span class="string">&quot;pig&quot;</span>:</span><br><span class="line">         <span class="keyword">return</span> QSPigMeatBuns&#123;&#125;</span><br><span class="line">       <span class="keyword">case</span> <span class="string">&quot;3s&quot;</span>:</span><br><span class="line">         <span class="keyword">return</span> QSSamSunStuffingBuns&#123;&#125;</span><br><span class="line">       <span class="keyword">default</span>:</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(gd QSBunShop)</span> <span class="title">Generate</span><span class="params">(t <span class="keyword">string</span>)</span> <span class="title">Bun</span></span> &#123;</span><br><span class="line">     <span class="keyword">switch</span> t &#123;</span><br><span class="line">       <span class="keyword">case</span> <span class="string">&quot;pig&quot;</span>:</span><br><span class="line">         <span class="keyword">return</span> GDPigMeatBuns&#123;&#125;</span><br><span class="line">       <span class="keyword">case</span> <span class="string">&quot;3s&quot;</span>:</span><br><span class="line">         <span class="keyword">return</span> GDSamSunStuffingBuns&#123;&#125;</span><br><span class="line">       <span class="keyword">default</span>:</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">       &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>这样，就完成了工厂方法模式</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b Bun</span><br><span class="line"><span class="comment">// 卖呀卖呀卖包子...</span></span><br><span class="line">QSFactory := <span class="built_in">new</span>(QSBunShop)</span><br><span class="line">b = QSFactory.Generate(<span class="string">&quot;pig&quot;</span>)  <span class="comment">// 传入猪肉馅的参数，会返回齐市包子铺的猪肉馅包子</span></span><br><span class="line">b.create()</span><br><span class="line"></span><br><span class="line">GDFactory := <span class="built_in">new</span>(GDBunShop)</span><br><span class="line">b = GDFactory.Generate(<span class="string">&quot;pig&quot;</span>) <span class="comment">// 同样传入猪肉馅的参数，会返回广东包子铺的猪肉馅包子</span></span><br><span class="line">b.create()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>go中没有继承，实际上可以以组合的方式达到继承的目的</p>
</blockquote>
<p>简单工厂模式和工厂方法模式看起来很相似，本质区别就在于，如果在包子店中直接创建包子产品，是依赖具体包子店的，扩展性、弹性、可维护性都较差，而如果将实例化的代码抽象出来，不再依赖具体包子店，而是依赖于抽象的包子接口，使对象的实现从使用中解耦，这样就拥有很强的扩展性了，也可以称为 『依赖倒置原则』</p>
<p>工厂方法模式的优缺点</p>
<ul>
<li>优点:<ol>
<li>符合“开闭”原则，具有很强的的扩展性、弹性和可维护性。修改时只需要添加对应的工厂类即可</li>
<li>使用了依赖倒置原则，依赖抽象而不是具体，使用（客户）和实现（具体类）松耦合</li>
<li>客户只需要知道所需产品的具体工厂，而无须知道具体工厂的创建产品的过程，甚至不需要知道具体产品的类名。</li>
</ol>
</li>
<li>缺点:<ol>
<li>每增加一个产品时，都需要一个具体类和一个具体创建者，使得类的个数成倍增加，导致系统类数目过多，复杂性增加</li>
<li>对简单工厂，增加功能修改的是工厂类；对工厂方法，增加功能修改的是产品类。</li>
</ol>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>golang设计模式之建造者模式</title>
    <url>/2020/10/14/golang%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><p>建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</p>
<p><strong>主要解决：</strong>主要解决在软件系统中，有时候面临着”一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。</p>
<p><strong>何时使用：</strong>一些基本部件不会变，而其组合经常变化的时候。</p>
<p><strong>如何解决：</strong>将变与不变分离开。</p>
<p><strong>关键代码：</strong>建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。</p>
<p><strong>应用实例：</strong> 1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的”套餐”。 2、JAVA 中的 StringBuilder。</p>
<p><strong>优点：</strong> 1、建造者独立，易扩展。 2、便于控制细节风险。</p>
<p><strong>缺点：</strong> 1、产品必须有共同点，范围有限制。 2、如内部变化复杂，会有很多的建造类。</p>
<p><strong>使用场景：</strong> 1、需要生成的对象具有复杂的内部结构。 2、需要生成的对象内部属性本身相互依赖。</p>
<p><strong>注意事项：</strong>与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们假设一个快餐店的商业案例，其中，一个典型的套餐可以是一个汉堡（Burger）和一杯冷饮（Cold drink）。汉堡（Burger）可以是素食汉堡（Veg Burger）或鸡肉汉堡（Chicken Burger），它们是包在纸盒中。冷饮（Cold drink）可以是可口可乐（coke）或百事可乐（pepsi），它们是装在瓶子中。</p>
<p>我们将创建一个表示食物条目（比如汉堡和冷饮）的 <em>Item</em> 接口和实现 <em>Item</em> 接口的实体类，以及一个表示食物包装的 <em>Packing</em> 接口和实现 <em>Packing</em> 接口的实体类，汉堡是包在纸盒中，冷饮是装在瓶子中。</p>
<p>然后我们创建一个 <em>Meal</em> 类，带有 <em>Item</em> 的 <em>ArrayList</em> 和一个通过结合 <em>Item</em> 来创建不同类型的 <em>Meal</em> 对象的 <em>MealBuilder</em>。<em>BuilderPatternDemo</em>，我们的演示类使用 <em>MealBuilder</em> 来创建一个 <em>Meal</em>。</p>
<p><img src="/images/golang%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/builder_pattern_uml_diagram.jpg" alt="建造者模式的 UML 图"></p>
<h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤 1"></a>步骤 1</h3><p>创建一个表示食物条目和食物包装的接口。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Item <span class="keyword">interface</span> &#123;</span><br><span class="line">   GetName() <span class="keyword">string</span></span><br><span class="line">   GetPacking() Packing</span><br><span class="line">   GetPrice() <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Packing <span class="keyword">interface</span> &#123;</span><br><span class="line">    GetPack() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤 2"></a>步骤 2</h3><p>创建实现 Packing 接口的实体类。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Wrapper <span class="keyword">struct</span> &#123;</span><br><span class="line">    Pack <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Wrapper)</span> <span class="title">GetPack</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Wrapper&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Bottle <span class="keyword">struct</span> &#123;</span><br><span class="line">    Pack <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Bottle)</span> <span class="title">GetPack</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Bottle&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤 3"></a>步骤 3</h3><p>创建实现 Item 接口的抽象类，该类提供了默认的功能。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Burger <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Burger)</span> <span class="title">GetPacking</span><span class="params">(item Item)</span> <span class="title">Packing</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item.GetPacking()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Burger)</span> <span class="title">GetPrice</span><span class="params">(item Item)</span><span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item.GetPrice()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Burger)</span> <span class="title">GetName</span><span class="params">(item Item)</span><span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item.GetName()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ColdDrink <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *ColdDrink)</span> <span class="title">GetPacking</span><span class="params">(item Item)</span> <span class="title">Packing</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item.GetPacking()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *ColdDrink)</span> <span class="title">GetPrice</span><span class="params">(item Item)</span><span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item.GetPrice()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *ColdDrink)</span> <span class="title">GetName</span><span class="params">(item Item)</span><span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item.GetName()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤 4"></a>步骤 4</h3><p>创建扩展了 Burger 和 ColdDrink 的实体类。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ChickenBurger <span class="keyword">struct</span> &#123;</span><br><span class="line">    Burger</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *ChickenBurger)</span> <span class="title">GetPrice</span><span class="params">()</span> <span class="title">float64</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">50.5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(this *ChickenBurger)</span> <span class="title">GetName</span><span class="params">()</span><span class="title">string</span></span>  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Chicken Burger&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *ChickenBurger)</span> <span class="title">GetPacking</span><span class="params">()</span> <span class="title">Packing</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">new</span>(Wrapper)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> VegBurger <span class="keyword">struct</span> &#123;</span><br><span class="line">    Burger</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *VegBurger)</span> <span class="title">GetPrice</span><span class="params">()</span> <span class="title">float64</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">25.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(this *VegBurger)</span> <span class="title">GetName</span><span class="params">()</span><span class="title">string</span></span>  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Veg Burger&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *VegBurger)</span> <span class="title">GetPacking</span><span class="params">()</span> <span class="title">Packing</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">new</span>(Wrapper)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Coke <span class="keyword">struct</span> &#123;</span><br><span class="line">    ColdDrink</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Coke)</span> <span class="title">GetPrice</span><span class="params">()</span> <span class="title">float64</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">30.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(this *Coke)</span> <span class="title">GetName</span><span class="params">()</span><span class="title">string</span></span>  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Coke&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Coke)</span> <span class="title">GetPacking</span><span class="params">()</span> <span class="title">Packing</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">new</span>(Bottle)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Pepsi <span class="keyword">struct</span> &#123;</span><br><span class="line">    ColdDrink</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Pepsi)</span> <span class="title">GetPrice</span><span class="params">()</span> <span class="title">float64</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">35.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(this *Pepsi)</span> <span class="title">GetName</span><span class="params">()</span><span class="title">string</span></span>  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Pepsi&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Pepsi)</span> <span class="title">GetPacking</span><span class="params">()</span> <span class="title">Packing</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">new</span>(Bottle)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="步骤-5"><a href="#步骤-5" class="headerlink" title="步骤 5"></a>步骤 5</h3><p>创建一个 Meal 类，带有上面定义的 Item 对象。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Meal <span class="keyword">struct</span> &#123;</span><br><span class="line">    Items []Item</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Meal)</span> <span class="title">AddItem</span><span class="params">(item Item)</span></span> &#123;</span><br><span class="line">    this.Items = <span class="built_in">append</span>(this.Items, item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Meal)</span> <span class="title">GetCost</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> cost <span class="keyword">float64</span></span><br><span class="line">    <span class="keyword">for</span> _, item := <span class="keyword">range</span> this.Items &#123;</span><br><span class="line">        cost += item.GetPrice()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cost</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Meal)</span> <span class="title">ShowItems</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, item := <span class="keyword">range</span> this.Items &#123;</span><br><span class="line">        fmt.Print(<span class="string">&quot;Item : &quot;</span> + item.GetName())</span><br><span class="line">        fmt.Print(<span class="string">&quot;, Packing : &quot;</span> + item.GetPacking().GetPack())</span><br><span class="line">        fmt.Println(<span class="string">&quot;, Price : &quot;</span> + fmt.Sprintf(<span class="string">&quot;%f&quot;</span>, item.GetPrice()))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="步骤-6"><a href="#步骤-6" class="headerlink" title="步骤 6"></a>步骤 6</h3><p>创建一个 MealBuilder 类，实际的 builder 类负责创建 Meal 对象。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetPrepareNonVegMea</span><span class="params">()</span> <span class="title">Meal</span></span> &#123;</span><br><span class="line">    meal := <span class="built_in">new</span>(Meal)</span><br><span class="line">    meal.AddItem(<span class="built_in">new</span>(ChickenBurger))</span><br><span class="line">    meal.AddItem(<span class="built_in">new</span>(Pepsi))</span><br><span class="line">    <span class="keyword">return</span> *meal</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetPrepareVegMeal</span><span class="params">()</span> <span class="title">Meal</span></span> &#123;</span><br><span class="line">    meal := <span class="built_in">new</span>(Meal)</span><br><span class="line">    meal.AddItem(<span class="built_in">new</span>(VegBurger))</span><br><span class="line">    meal.AddItem(<span class="built_in">new</span>(Coke))</span><br><span class="line">    <span class="keyword">return</span> *meal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="步骤-7"><a href="#步骤-7" class="headerlink" title="步骤 7"></a>步骤 7</h3><p>BuiderPatternDemo 使用 MealBuider 来演示建造者模式（Builder Pattern）。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    nonVegMeal := meal.GetPrepareNonVegMea()</span><br><span class="line">    fmt.Println(<span class="string">&quot;\\n\\nNon-Veg Meal&quot;</span>)</span><br><span class="line">    nonVegMeal.ShowItems()</span><br><span class="line">    fmt.Println(<span class="string">&quot;Total Cost: &quot;</span> + fmt.Sprintf(<span class="string">&quot;%f&quot;</span>, nonVegMeal.GetCost()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    VegMeal := meal.GetPrepareVegMeal()</span><br><span class="line">    fmt.Println(<span class="string">&quot;\\n\\nVegMeal Meal&quot;</span>)</span><br><span class="line">    VegMeal.ShowItems()</span><br><span class="line">    fmt.Println(<span class="string">&quot;Total Cost: &quot;</span> + fmt.Sprintf(<span class="string">&quot;%f&quot;</span>, VegMeal.GetCost()))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="步骤-8"><a href="#步骤-8" class="headerlink" title="步骤 8"></a>步骤 8</h3><p>执行程序，输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">\n\nNon-Veg Meal</span><br><span class="line">Item : Chicken Burger, Packing : Wrapper, Price : 50.500000</span><br><span class="line">Item : Pepsi, Packing : Bottle, Price : 35.000000</span><br><span class="line">Total Cost: 85.500000</span><br><span class="line">\n\nVegMeal Meal</span><br><span class="line">Item : Veg Burger, Packing : Wrapper, Price : 25.000000</span><br><span class="line">Item : Coke, Packing : Bottle, Price : 30.000000</span><br><span class="line">Total Cost: 55.000000</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>grep 去注释和空行</title>
    <url>/2020/10/20/grep-%E5%8E%BB%E6%B3%A8%E9%87%8A%E5%92%8C%E7%A9%BA%E8%A1%8C/</url>
    <content><![CDATA[<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">grep <span class="literal">-v</span> ^<span class="comment"># /etc/vsftpd/vsftpd.conf |grep -v ^$</span></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>interview-go</title>
    <url>/2020/11/04/interview-go/</url>
    <content><![CDATA[<h4 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h4><h4 id="go基础"><a href="#go基础" class="headerlink" title="go基础"></a>go基础</h4><ol>
<li><p>说说go的优点</p>
<ol>
<li>go的性能是Python的35倍</li>
<li>性能 （因为golang是机器代码） 编译后的文件可以直接放在机器上执行</li>
<li>开发的过程中 无效的字段或者包名引用 会强制提醒错误，有fmt 统一代码的格式</li>
<li>并发支持  channel和goroutine的性能很出色，可以非常方便的启动一个协程，很容易的生出数百万个goroutine</li>
<li>内置运行时gc，是通过三色法来对垃圾进行回收，可以满足大多数关于垃圾收集的请求</li>
<li>简单易学，非常容易上手</li>
<li>可以返回多个值，虽然java也支持（最多支持三个）</li>
<li>非常节省内存 1.12之前一个goroutinue的内存大概占用2kb，而一个java线程默认是2mb，1.17之后已经改为8kb了</li>
<li>接口的实现非常方便，可以通过内嵌struct来实现继承</li>
<li>if…;… {} 可以将变量的作用域放在if内 很棒</li>
<li>单元测试和并发测试都很方便</li>
</ol>
<p>缺点是</p>
<ol>
<li>缺乏框架、 没有像java那种开发小项目使用springboot springcloud 这种比较成熟的框架、不过对于goweb开发 有beego 、gin等、对于分布式有gomicro、gokit，</li>
<li>错误处理，经常要对错误进行判断 </li>
<li>使用的用法很多坑，比如slice传递的是引用不是副本 ，如果调用的func 不会对slice进行修改传递本身是没问题，如果需要修改就需要考虑使用copy（src，dest）来进行， 如果知道要slice要存储的空间是多少，在初始化的时候要使用 make([]int，nums)来声明，防止在append过程中会发生扩容操作。<br>nil切片、空切片、零切片的区别，var str []int 这种是nil切片 ，序列化之后是null，var str = []int{} 这种是空切片，序列化之后是[] 空数组，领切片就是 make([]int,10) 初始化之后 底层数组存储的数据都是0，官方不推荐创建空切片、也不推荐nil切片和nil进行对比</li>
<li>map中struct的单个字段 是非法的，因为map中的元素是不能寻址的</li>
</ol>
</li>
<li><p>谈谈golang的csp模型</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>interview-golang GC</title>
    <url>/2020/11/04/interview-golang-GC/</url>
    <content><![CDATA[<p>过去一般采用两种办法：</p>
<ul>
<li>内存泄露检测工具。这种工具的原理一般是静态代码扫描，通过扫描程序检测可能出现内存泄露的代码段。然而检测工具难免有疏漏和不足，只能起到辅助作用。</li>
<li>智能指针。这是 c++ 中引入的自动内存管理方法，通过拥有自动内存管理功能的指针对象来引用对象，是程序员不用太关注内存的释放，而达到内存自动释放的目的。这种方法是采用最广泛的做法，但是对程序开发者有一定的学习成本（并非语言层面的原生支持），而且一旦有忘记使用的场景依然无法避免内存泄露。</li>
</ul>
<p>为了解决这个问题，后来开发出来的几乎所有新语言（java，python，php等等）都引入了语言层面的自动内存管理 – 也就是语言的使用者只用关注内存的申请而不必关心内存的释放，内存释放由虚拟机（virtual machine）或运行时（runtime）来自动进行管理。而这种对不再使用的内存资源进行自动回收的行为就被称为垃圾回收。</p>
<p>常用的垃圾回收的方法:</p>
<ul>
<li>引用计数（reference counting）</li>
</ul>
<p>这是最简单的一种垃圾回收算法，和之前提到的智能指针异曲同工。对每个对象维护一个引用计数，当引用该对象的对象被销毁或更新时被引用对象的引用计数自动减一，当被引用对象被创建或被赋值给其他对象时引用计数自动加一。当引用计数为0时则立即回收对象。</p>
<p>这种方法的优点是实现简单，并且内存的回收很及时。这种算法在内存比较紧张和实时性比较高的系统中使用的比较广泛，如ios cocoa框架，php，python等。</p>
<p>但是简单引用计数算法也有明显的缺点：</p>
<ol>
<li>频繁更新引用计数降低了性能。</li>
</ol>
<p>一种简单的解决方法就是编译器将相邻的引用计数更新操作合并到一次更新；还有一种方法是针对频繁发生的临时变量引用不进行计数，而是在引用达到0时通过扫描堆栈确认是否还有临时对象引用而决定是否释放。等等还有很多其他方法，具体可以参考这里。</p>
<ol>
<li>循环引用。</li>
</ol>
<p>当对象间发生循环引用时引用链中的对象都无法得到释放。最明显的解决办法是避免产生循环引用，如cocoa引入了strong指针和weak指针两种指针类型。或者系统检测循环引用并主动打破循环链。当然这也增加了垃圾回收的复杂度。</p>
<ul>
<li>标记-清除（mark and sweep）</li>
</ul>
<p>标记-清除（mark and sweep）分为两步，标记从根变量开始迭代得遍历所有被引用的对象，对能够通过应用遍历访问到的对象都进行标记为“被引用”；标记完成后进行清除操作，对没有标记过的内存进行回收（回收同时可能伴有碎片整理操作）。这种方法解决了引用计数的不足，但是也有比较明显的问题：每次启动垃圾回收都会暂停当前所有的正常代码执行，回收是系统响应能力大大降低！当然后续也出现了很多mark&amp;sweep算法的变种（如三色标记法）优化了这个问题。</p>
<ul>
<li>分代搜集（generation）</li>
</ul>
<p>java的jvm 就使用的分代回收的思路。在面向对象编程语言中，绝大多数对象的生命周期都非常短。分代收集的基本思想是，将堆划分为两个或多个称为代（generation）的空间。新创建的对象存放在称为新生代（young generation）中（一般来说，新生代的大小会比 老年代小很多），随着垃圾回收的重复执行，生命周期较长的对象会被提升（promotion）到老年代中（这里用到了一个分类的思路，这个是也是科学思考的一个基本思路）。</p>
<p>因此，新生代垃圾回收和老年代垃圾回收两种不同的垃圾回收方式应运而生，分别用于对各自空间中的对象执行垃圾回收。新生代垃圾回收的速度非常快，比老年代快几个数量级，即使新生代垃圾回收的频率更高，执行效率也仍然比老年代垃圾回收强，这是因为大多数对象的生命周期都很短，根本无需提升到老年代。</p>
<p>Golang GC 时会发生什么?</p>
<p>Golang 1.5后，采取的是“非分代的、非移动的、并发的、三色的”标记清除垃圾回收算法。</p>
<p>golang 中的 gc 基本上是标记清除的过程：</p>
<p><a href="https://github.com/KeKe-Li/For-learning-Go-Tutorial/blob/master/src/images/2.jpg"><img src="/images/interview-golang-GC/2.jpg" alt="img"></a></p>
<p>gc的过程一共分为四个阶段：</p>
<ol>
<li>栈扫描（开始时STW）</li>
<li>第一次标记（并发）</li>
<li>第二次标记（STW）</li>
<li>清除（并发）</li>
</ol>
<p>整个进程空间里申请每个对象占据的内存可以视为一个图，初始状态下每个内存对象都是白色标记。</p>
<ol>
<li>先STW，做一些准备工作，比如 enable write barrier。然后取消STW，将扫描任务作为多个并发的goroutine立即入队给调度器，进而被CPU处理</li>
<li>第一轮先扫描root对象，包括全局指针和 goroutine 栈上的指针，标记为灰色放入队列</li>
<li>第二轮将第一步队列中的对象引用的对象置为灰色加入队列，一个对象引用的所有对象都置灰并加入队列后，这个对象才能置为黑色并从队列之中取出。循环往复，最后队列为空时，整个图剩下的白色内存空间即不可到达的对象，即没有被引用的对象；</li>
<li>第三轮再次STW，将第二轮过程中新增对象申请的内存进行标记（灰色），这里使用了write barrier（写屏障）去记录</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>interview-golang常见的并发模型</title>
    <url>/2020/11/03/interview-golang%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>常见的并发模型：</p>
<ol>
<li><p>channel</p>
<p>无缓冲的通道通常指通道的大小为0，也就是说，这种类型的通道再接收之前没有能力保存任何值，它要求发送goroutinue和接收goroutinue同时准备好，才可以完成发送和接收</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;start working&quot;</span>)</span><br><span class="line">        time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">        ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    &lt;-ch</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;finished&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当主 goroutine 运行到 &lt;-ch 接受 channel 的值的时候，如果该 channel 中没有数据，就会一直阻塞等待，直到有值。 这样就可以简单实现并发控制</p>
</li>
<li><p>sync.waitGroup</p>
<p>Goroutine是异步执行的，有的时候为了防止在结束mian函数的时候结束掉Goroutine，所以需要同步等待，这个时候就需要用 WaitGroup了，在 sync 包中，提供了 WaitGroup ，它会等待它收集的所有 goroutine 任务全部完成。在WaitGroup里主要有三个方法:</p>
<ul>
<li>Add, 可以添加或减少 goroutine的数量.</li>
<li>Done, 相当于Add(-1).</li>
<li>Wait, 执行后会堵塞主线程，直到WaitGroup 里的值减至0.</li>
</ul>
<p>在主 goroutine 中 Add(delta int) 索要等待goroutine 的数量。 在每一个 goroutine 完成后 Done() 表示这一个goroutine 已经完成，当所有的 goroutine 都完成后，在主 goroutine 中 WaitGroup 返回</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">var</span> urls = []<span class="keyword">string</span>&#123;</span><br><span class="line">        <span class="string">&quot;http://www.golang.org/&quot;</span>,</span><br><span class="line">        <span class="string">&quot;http://www.google.com/&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, url := <span class="keyword">range</span> urls &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(url <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            http.Get(url)</span><br><span class="line">        &#125;(url)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line">在Golang官网中对于WaitGroup介绍是A WaitGroup must not be copied after first use,在 WaitGroup 第一次使用后，不能被拷贝</span><br><span class="line"></span><br><span class="line">应用示例:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(wg sync.WaitGroup, i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;i:%d&quot;</span>, i)</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;(wg, i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">&quot;exit&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">运行:</span><br><span class="line"></span><br><span class="line">i:<span class="number">1i</span>:<span class="number">3i</span>:<span class="number">2i</span>:<span class="number">0i</span>:<span class="number">4</span>fatal error: all goroutines are asleep - deadlock!</span><br><span class="line"></span><br><span class="line">goroutine <span class="number">1</span> [semacquire]:</span><br><span class="line">sync.runtime_Semacquire(<span class="number">0xc000094018</span>)</span><br><span class="line">        /home/keke/soft/<span class="keyword">go</span>/src/runtime/sema.<span class="keyword">go</span>:<span class="number">56</span> +<span class="number">0x39</span></span><br><span class="line">sync.(*WaitGroup).Wait(<span class="number">0xc000094010</span>)</span><br><span class="line">        /home/keke/soft/<span class="keyword">go</span>/src/sync/waitgroup.<span class="keyword">go</span>:<span class="number">130</span> +<span class="number">0x64</span></span><br><span class="line">main.main()</span><br><span class="line">        /home/keke/<span class="keyword">go</span>/Test/wait.<span class="keyword">go</span>:<span class="number">17</span> +<span class="number">0xab</span></span><br><span class="line">exit status <span class="number">2</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li>context</li>
</ol>
<p>通常,在一些简单场景下使用 channel 和 WaitGroup 已经足够了，但是当面临一些复杂多变的网络并发场景下 channel 和 WaitGroup 显得有些力不从心了。 比如一个网络请求 Request，每个 Request 都需要开启一个 goroutine 做一些事情，这些 goroutine 又可能会开启其他的 goroutine，比如数据库和RPC服务。 所以我们需要一种可以跟踪 goroutine 的方案，才可以达到控制他们的目的，这就是Go语言为我们提供的 Context，称之为上下文非常贴切，它就是goroutine 的上下文。 它是包括一个程序的运行环境、现场和快照等。每个程序要运行时，都需要知道当前程序的运行状态，通常Go 将这些封装在一个 Context 里，再将它传给要执行的 goroutine 。</p>
<p>context 包主要是用来处理多个 goroutine 之间共享数据，及多个 goroutine 的管理。</p>
<p>context 包的核心是 struct Context，接口声明如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A Context carries a deadline, cancelation signal, and request-scoped values</span></span><br><span class="line"><span class="comment">// across API boundaries. Its methods are safe for simultaneous use by multiple</span></span><br><span class="line"><span class="comment">// goroutines.</span></span><br><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Done returns a channel that is closed when this `Context` is canceled</span></span><br><span class="line">    <span class="comment">// or times out.</span></span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Err indicates why this Context was canceled, after the Done channel</span></span><br><span class="line">    <span class="comment">// is closed.</span></span><br><span class="line">    Err() error</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Deadline returns the time when this Context will be canceled, if any.</span></span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Value returns the value associated with key or nil if none.</span></span><br><span class="line">    Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Done() 返回一个只能接受数据的channel类型，当该context关闭或者超时时间到了的时候，该channel就会有一个取消信号</p>
<p>E rr() 在Done() 之后，返回context 取消的原因。</p>
<p>Deadline() 设置该context cancel的时间点</p>
<p>Value() 方法允许 Context 对象携带request作用域的数据，该数据必须是线程安全的。</p>
<p>Context 对象是线程安全的，你可以把一个 Context 对象传递给任意个数的 gorotuine，对它执行 取消 操作时，所有 goroutine 都会接收到取消信号。</p>
<p>一个 Context 不能拥有 Cancel 方法，同时我们也只能 Done channel 接收数据。 其中的原因是一致的：接收取消信号的函数和发送信号的函数通常不是一个。 典型的场景是：父操作为子操作操作启动 goroutine，子操作也就不能取消父操作。</p>
]]></content>
  </entry>
  <entry>
    <title>interview-tcp 三次握手、四次挥手</title>
    <url>/2020/10/30/interview-tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E3%80%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
    <content><![CDATA[<ol>
<li>请画出三次握手和四次挥手的示意图</li>
<li>为什么连接的时候是三次握手？</li>
<li>什么是半连接队列？</li>
<li>ISN(Initial Sequence Number)是固定的吗？</li>
<li>三次握手过程中可以携带数据吗？</li>
<li>如果第三次握手丢失了，客户端服务端会如何处理？</li>
<li>SYN攻击是什么？</li>
<li>挥手为什么需要四次？</li>
<li>四次挥手释放连接时，等待2MSL的意义?</li>
</ol>
<p><img src="/images/interview-tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E3%80%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/v2-67515121626493be9b645be76534007f_r.jpg" alt="preview"></p>
<h2 id="1-三次握手"><a href="#1-三次握手" class="headerlink" title="1. 三次握手"></a>1. 三次握手</h2><p>三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。</p>
<p>刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。</p>
<p>进行三次握手：</p>
<p>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN©。此时客户端处于 SYN_SEND 状态。</p>
<p>首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。</p>
<p>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。</p>
<p>在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y。</p>
<p>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。</p>
<p>确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。</p>
<p>发送第一个SYN的一端将执行主动打开（active open），接收这个SYN并发回下一个SYN的另一端执行被动打开（passive open）。</p>
<p>在socket编程中，客户端执行connect()时，将触发三次握手。</p>
<p><img src="/images/interview-tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E3%80%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/v2-2a54823bd63e16674874aa46a67c6c72_720w.jpg" alt="img"></p>
<p><strong>1.1 为什么需要三次握手，两次不行吗？</strong></p>
<p>弄清这个问题，我们需要先弄明白三次握手的目的是什么，能不能只用两次握手来达到同样的目的。</p>
<p>第一次握手：客户端发送网络包，服务端收到了。</p>
<p>这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p>
<p>第二次握手：服务端发包，客户端收到了。</p>
<p>这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。</p>
<p>第三次握手：客户端发包，服务端收到了。</p>
<p>这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</p>
<p>因此，需要三次握手才能确认双方的接收与发送能力是否正常。</p>
<p>试想如果是用两次握手，则会出现下面这种情况：</p>
<blockquote>
<p>如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。</p>
</blockquote>
<p><strong>1.2 什么是半连接队列？</strong></p>
<p>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。</p>
<p>当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。</p>
<p>这里在补充一点关于SYN-ACK 重传次数的问题：</p>
<p>服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。</p>
<p>注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s…</p>
<p><strong>1.3 ISN(Initial Sequence Number)是固定的吗？</strong></p>
<p>当一端为建立连接而发送它的SYN时，它为连接选择一个初始序号。ISN随时间而变化，因此每个连接都将具有不同的ISN。ISN可以看作是一个32比特的计数器，每4ms加1 。这样选择序号的目的在于防止在网络中被延迟的分组在以后又被传送，而导致某个连接的一方对它做错误的解释。</p>
<p>三次握手的其中一个重要功能是客户端和服务端交换 ISN(Initial Sequence Number)，以便让对方知道接下来接收数据的时候如何按序列号组装数据。如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。</p>
<p><strong>1.4 三次握手过程中可以携带数据吗？</strong></p>
<p>其实第三次握手的时候，是可以携带数据的。但是，第一次、第二次握手不可以携带数据</p>
<p>为什么这样呢?大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。</p>
<p>也就是说，第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。</p>
<p><strong>1.5 SYN攻击是什么？</strong></p>
<p>服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到SYN洪泛攻击。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS/DDoS 攻击。</p>
<p>检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">netstat -n -p TCP | grep SYN_RECV</span><br></pre></td></tr></table></figure>

<p>常见的防御 SYN 攻击的方法有如下几种：</p>
<ul>
<li>缩短超时（SYN Timeout）时间</li>
<li>增加最大半连接数</li>
<li>过滤网关防护</li>
<li>SYN cookies技术</li>
</ul>
<h2 id="2-四次挥手"><a href="#2-四次挥手" class="headerlink" title="2. 四次挥手"></a>2. 四次挥手</h2><p>建立一个连接需要三次握手，而终止一个连接要经过四次挥手（也有将四次挥手叫做四次握手的）。这由TCP的半关闭（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。</p>
<p>TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，客户端或服务器均可主动发起挥手动作。</p>
<p>刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：</p>
<p>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。</p>
<p>即发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。</p>
<p>第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。</p>
<p>即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。</p>
<p>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。</p>
<p>即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。</p>
<p>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</p>
<p>即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。</p>
<p>收到一个FIN只意味着在这一方向上没有数据流动。客户端执行主动关闭并进入TIME_WAIT是正常的，服务端通常执行被动关闭，不会进入TIME_WAIT状态。</p>
<p>在socket编程中，任何一方执行close()操作即可产生挥手操作。</p>
<p><img src="/images/interview-tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E3%80%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/v2-c7d4b5aca66560365593f57385ce9fa9_720w.jpg" alt="img"></p>
<p><strong>2.1 挥手为什么需要四次？</strong></p>
<p>因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。</p>
<p><strong>2.2 2MSL等待状态</strong></p>
<p>TIME_WAIT状态也成为2MSL等待状态。每个具体TCP实现必须选择一个报文段最大生存时间MSL（Maximum Segment Lifetime），它是任何报文段被丢弃前在网络内的最长时间。这个时间是有限的，因为TCP报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的TTL字段。</p>
<p>对一个具体实现所给定的MSL值，处理的原则是：当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在TIME_WAIT状态停留的时间为2倍的MSL。这样可让TCP再次发送最后的ACK以防这个ACK丢失（另一端超时并重发最后的FIN）。</p>
<p>这种2MSL等待的另一个结果是这个TCP连接在2MSL等待期间，定义这个连接的插口（客户的IP地址和端口号，服务器的IP地址和端口号）不能再被使用。这个连接只能在2MSL结束后才能再被使用。</p>
<p><strong>2.3 四次挥手释放连接时，等待2MSL的意义?</strong></p>
<p>MSL是Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p>
<p>为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。</p>
<p>两个理由：</p>
<ul>
<li>保证客户端发送的最后一个ACK报文段能够到达服务端。</li>
</ul>
<p>这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，服务端超时重传FIN+ACK报文段，而客户端能在2MSL时间内收到这个重传的FIN+ACK报文段，接着客户端重传一次确认，重新启动2MSL计时器，最后客户端和服务端都进入到CLOSED状态，若客户端在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到服务端重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则服务端无法正常进入到CLOSED状态。</p>
<ul>
<li>防止“已失效的连接请求报文段”出现在本连接中。</li>
</ul>
<p>客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。</p>
<p><strong>2.4 为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？</strong></p>
<p>理论上，四个报文都发送完毕，就可以直接进入CLOSE状态了，但是可能网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>《TCP/IP详解 卷1:协议》有一张TCP状态变迁图，很具有代表性，有助于大家理解三次握手和四次挥手的状态变化。如下图所示，粗的实线箭头表示正常的客户端状态变迁，粗的虚线箭头表示正常的服务器状态变迁。</p>
<p><img src="/images/interview-tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E3%80%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/v2-7c402fde8210519feb8f65d41410c205_720w.jpg" alt="img"></p>
]]></content>
      <tags>
        <tag>转</tag>
      </tags>
  </entry>
  <entry>
    <title>interview-进程、线程、协程的区别</title>
    <url>/2020/10/30/interview-%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p><strong>什么是进程和线程</strong></p>
<p>进程是什么呢？</p>
<p>直白地讲，进程就是应用程序的启动实例。比如我们运行一个游戏，打开一个软件，就是开启了一个进程。</p>
<p>进程拥有代码和打开的文件资源、数据资源、独立的内存空间。</p>
<p>线程又是什么呢？</p>
<p>线程从属于进程，是程序的实际执行者。一个进程至少包含一个主线程，也可以有更多的子线程。</p>
<p>线程拥有自己的栈空间。</p>
<img src="/images/interview-%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/image-20201029180523682.png" alt="image-20201029180523682" style="zoom:50%;" />

<p>有人给出了很好的归纳：</p>
<p><strong>对操作系统来说，线程是最小的执行单元，进程是最小的资源管理单元。</strong></p>
<p>无论进程还是线程，都是由操作系统所管理的。</p>
<p>Java中线程具有五种状态：</p>
<p><strong>初始化 可运行 运行中 阻塞 销毁</strong></p>
<p>这五种状态的转化关系如下：</p>
<img src="/images/interview-%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/image-20201029180545720.png" alt="image-20201029180545720" style="zoom:50%;" />

<p>但是，线程不同状态之间的转化是谁来实现的呢？是JVM吗？</p>
<p>并不是。JVM需要通过操作系统内核中的TCB（Thread Control Block）模块来改变线程的状态，这一过程需要耗费一定的CPU资源。</p>
<p><strong>进程和线程的痛点</strong></p>
<p>线程之间是如何进行协作的呢？</p>
<p>最经典的例子就是<strong>生产者/消费者模式</strong>：</p>
<p>若干个生产者线程向队列中写入数据，若干个消费者线程从队列中消费数据。</p>
<img src="/images/interview-%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/image-20201029180606391.png" alt="image-20201029180606391" style="zoom:50%;" />

<p>如何用java语言实现生产者/消费者模式呢？</p>
<p>让我们来看一看代码：</p>
<p>public class ProducerConsumerTest {</p>
<p>}</p>
<p>class Producer extends Thread {</p>
<p>}</p>
<p>class Consumer extends Thread {private final Queue sharedQueue;</p>
<p>}</p>
<p>这段代码做了下面几件事：</p>
<p>1.定义了一个生产者类，一个消费者类。</p>
<p>2.生产者类循环100次，向同步队列当中插入数据。</p>
<p>3.消费者循环监听同步队列，当队列有数据时拉取数据。</p>
<p>4.如果队列满了（达到5个元素），生产者阻塞。</p>
<p>5.如果队列空了，消费者阻塞。</p>
<p>上面的代码正确地实现了生产者/消费者模式，但是却并不是一个高性能的实现。为什么性能不高呢？原因如下：</p>
<p>1.涉及到同步锁。</p>
<p>2.涉及到线程阻塞状态和可运行状态之间的切换。</p>
<p>3.涉及到线程上下文的切换。</p>
<p>以上涉及到的任何一点，都是非常耗费性能的操作。</p>
<p><strong>什么是协程</strong></p>
<p><strong>协程，英文Coroutines，是一种比线程更加轻量级的存在。</strong>正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。</p>
<img src="/images/interview-%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/image-20201029180628288.png" alt="image-20201029180628288" style="zoom:50%;" />

<p>最重要的是，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。</p>
<p>这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。</p>
<p>既然协程这么好，它到底是怎么来使用的呢？</p>
<p>由于Java的原生语法中并没有实现协程（某些开源框架实现了协程，但是很少被使用），所以我们来看一看python当中对协程的实现案例，同样以生产者消费者模式为例：</p>
<p><img src="/images/interview-%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/image-20201029180645894.png" alt="image-20201029180645894"></p>
<p>这段代码十分简单，即使没用过python的小伙伴应该也能基本看懂。</p>
<p>代码中创建了一个叫做consumer的协程，并且在主线程中生产数据，协程中消费数据。</p>
<p>其中 <strong>yield</strong> 是python当中的语法。当协程执行到yield关键字时，会暂停在那一行，等到主线程调用send方法发送了数据，协程才会接到数据继续执行。</p>
<p>但是，yield让协程暂停，和线程的阻塞是有本质区别的。协程的暂停完全由程序控制，线程的阻塞状态是由操作系统内核来进行切换。</p>
<p>因此，<strong>协程的开销远远小于线程的开销。</strong></p>
<p><strong>协程的应用</strong></p>
<p>有哪些编程语言应用到了协程呢？我们举几个栗子：</p>
<p><strong>Lua语言</strong></p>
<p>Lua从5.0版本开始使用协程，通过扩展库coroutine来实现。</p>
<p><strong>Python语言</strong></p>
<p>正如刚才所写的代码示例，python可以通过 yield/send 的方式实现协程。在python 3.5以后，async/await 成为了更好的替代方案。</p>
<p><strong>Go语言</strong></p>
<p>Go语言对协程的实现非常强大而简洁，可以轻松创建成百上千个协程并发执行。</p>
<p><strong>Java语言</strong></p>
<p>如上文所说，Java语言并没有对协程的原生支持，但是某些开源框架模拟出了协程的功能，有兴趣的小伙伴可以看一看<strong>Kilim框架</strong>的源码：</p>
]]></content>
  </entry>
  <entry>
    <title>k8s-pod的状态为evicted</title>
    <url>/2020/08/07/k8s-pod%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%BAevicted/</url>
    <content><![CDATA[<h3 id="遇到问题–k8s–pod的状态为evicted"><a href="#遇到问题–k8s–pod的状态为evicted" class="headerlink" title="遇到问题–k8s–pod的状态为evicted"></a>遇到问题–k8s–pod的状态为evicted</h3><p>eviction，即驱赶的意思，意思是当节点出现异常时，kubernetes将有相应的机制驱赶该节点上的Pod。多见于资源不足时导致的驱赶。</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>排查资源和异常原因，防止新的驱赶产生。使用如下命令删除旧驱赶的遗留</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get pods | grep Evicted | awk &#x27;&#123;print $1&#125;&#x27; | xargs kubectl delete pod</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s-初识1</title>
    <url>/2020/12/18/k8s-%E5%88%9D%E8%AF%861/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>k8s-服务添加tag</title>
    <url>/2020/09/01/k8s-%E6%9C%8D%E5%8A%A1%E6%B7%BB%E5%8A%A0tag/</url>
    <content><![CDATA[<p>需求：由于随时对k8s的使用，有些node节点配置很高，会存在服务混布的情况，这样就需要对每个服务打tag，月末对机器的使用情况各个业务线来进行分摊成本</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">alb.ingress.kubernetes.io/tags:</span> <span class="string">PDB1=xxxxYourTag</span></span><br></pre></td></tr></table></figure>

<p>打完标签之后 不会立即生效 大约10分钟之后就能再<code>aws</code>的控制台上看到<code>ingress</code> 已经出现了yaml文件中配置的<code>tag</code></p>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
  </entry>
  <entry>
    <title>k8s-组件说明1</title>
    <url>/2020/12/18/k8s-%E7%BB%84%E4%BB%B6%E8%AF%B4%E6%98%8E1/</url>
    <content><![CDATA[<p>k8s-组件说明1</p>
<p>borg系统的架构</p>
<img src="/images/k8s-%E7%BB%84%E4%BB%B6%E8%AF%B4%E6%98%8E1/image-20201218221737256.png" alt="image-20201218221737256" style="zoom:50%;" />

<ol>
<li><p>borgmaster 是所有 任务得分发、是整个系统得大脑，为了防止单节点故障、会发现borgmaster有许多副本、并且副本数目是奇数、为了方便选举</p>
</li>
<li><p>borglet 是任务真正的工作节点，从borgmaster获取要执行得任务</p>
</li>
<li><p>scheduler 是对任务进行安排应该哪些borglet有能力去执行，对任务进行打分，将</p>
</li>
<li><p>可以通过配置文件、命令行、浏览器来访问borgmaster得配置</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>合并区间</title>
    <url>/2020/08/07/leetcode%20%E6%95%B0%E7%BB%84-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/</url>
    <content><![CDATA[<h3 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h3><p>给出一个区间的集合，请合并所有重叠的区间。</p>
<p>示例 1:</p>
<p>输入: [[1,3],[2,6],[8,10],[15,18]]<br>输出: [[1,6],[8,10],[15,18]]<br>解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].<br>示例 2:</p>
<p>输入: [[1,4],[4,5]]<br>输出: [[1,5]]<br>解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。</p>
<p>Go</p>
<p>作者：力扣 (LeetCode)<br>链接：<a href="https://leetcode-cn.com/leetbook/read/array-and-string/c5tv3/">https://leetcode-cn.com/leetbook/read/array-and-string/c5tv3/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><ol>
<li><p>先将区间按照 start 进行排序 遍历每个区间，</p>
</li>
<li><p>开始向后遍历 是否区间满足合并的条件</p>
</li>
<li><pre><code class="go">#初始
left := intervals[i][0]
right := intervals[i][1] 
&lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   从&amp;#96;j &amp;#x3D; i + 1&amp;#96;开始 判断后面j区间的开始&amp;#96;intervals[j][0]&amp;#96;是否&amp;#96;&amp;lt;&amp;#x3D;right&amp;#96; 是 则可以合并 切新区间的&amp;#96;left&amp;#x3D;left right &amp;#x3D; max(right, intervals[j][1])&amp;#96;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;​    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;### 代码实现&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#96;&amp;#96;&amp;#96;go&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;type MergeSlice [][]int&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;func (s MergeSlice) Len() int           &amp;#123; return len(s) &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;func (s MergeSlice) Swap(i, j int)      &amp;#123; s[i], s[j] &amp;#x3D; s[j], s[i] &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;func (s MergeSlice) Less(i, j int) bool &amp;#123; return s[i][0] &amp;lt; s[j][0] &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;func merge(intervals [][]int) [][]int &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    sort.Sort(MergeSlice(intervals)) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    retList :&amp;#x3D; make([][]int, 0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    size :&amp;#x3D; len(intervals)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var i int&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for i &amp;lt; size &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        left :&amp;#x3D; intervals[i][0]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        right :&amp;#x3D; intervals[i][1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        j :&amp;#x3D; i + 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for j &amp;lt; size &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if intervals[j][0] &amp;lt;&amp;#x3D; right &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                right &amp;#x3D; Max(intervals[j][1], right)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                j++&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125; else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                break&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ret :&amp;#x3D; []int&amp;#123;left, right&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        retList &amp;#x3D; append(retList, ret)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        i &amp;#x3D; j       &amp;#x2F;&amp;#x2F; 合并之后i&amp;#x3D;j+1 没有合并i&amp;#x3D;i+1 都可以用i&amp;#x3D;j表示&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return retList&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;func Max(a, b int) int &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if a &amp;gt;&amp;#x3D; b &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return b&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt;
</code></pre>
</li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>寻找数组的中心索引</title>
    <url>/2020/08/07/leetcode%20%E6%95%B0%E7%BB%84-%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h3 id="寻找数组的中心索引"><a href="#寻找数组的中心索引" class="headerlink" title="寻找数组的中心索引"></a>寻找数组的中心索引</h3><p>给定一个整数类型的数组 nums，请编写一个能够返回数组 “中心索引” 的方法。</p>
<p>我们是这样定义数组 中心索引 的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。</p>
<p>如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。</p>
<p>示例 1：</p>
<p>输入：<br>nums = [1, 7, 3, 6, 5, 6]<br>输出：3<br>解释：<br>索引 3 (nums[3] = 6) 的左侧数之和 (1 + 7 + 3 = 11)，与右侧数之和 (5 + 6 = 11) 相等。<br>同时, 3 也是第一个符合要求的中心索引。<br>示例 2：</p>
<p>输入：<br>nums = [1, 2, 3]<br>输出：-1<br>解释：<br>数组中不存在满足此条件的中心索引。</p>
<p>说明：</p>
<p>nums 的长度范围为 [0, 10000]。<br>任何一个 nums[i] 将会是一个范围在 [-1000, 1000]的整数。</p>
<p>Go</p>
<p>思路 </p>
<p>S 是数组的和，当索引 i 是中心索引时，位于 i 左边数组元素的和 leftsum 满足 S - nums[i] - leftsum。<br>我们只需要判断当前索引 i 是否满足 leftsum==S-nums[i]-leftsum 并动态计算 leftsum 的值。</p>
<p>作者：力扣 (LeetCode)<br>链接：<a href="https://leetcode-cn.com/leetbook/read/array-and-string/yf47s/">https://leetcode-cn.com/leetbook/read/array-and-string/yf47s/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">解法一</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pivotIndex</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    result:=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> result &lt; <span class="built_in">len</span>(nums) &#123;</span><br><span class="line"></span><br><span class="line">        left:=<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span>&#123;</span><br><span class="line">            <span class="keyword">var</span> sum <span class="keyword">int</span></span><br><span class="line">            <span class="keyword">for</span> _,item :=<span class="keyword">range</span> nums[<span class="number">0</span>:result] &#123;</span><br><span class="line">                sum+=item</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum</span><br><span class="line">        &#125;</span><br><span class="line">        right:=<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span>&#123;</span><br><span class="line">            <span class="keyword">var</span> sum <span class="keyword">int</span></span><br><span class="line">            <span class="keyword">for</span> _,item  :=<span class="keyword">range</span> nums[result+<span class="number">1</span>:] &#123;</span><br><span class="line">                sum+=item</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> right() == left() &#123;</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">        result ++</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p>通过</p>
<p>显示详情</p>
<p>执行用时：336 ms, 在所有 Go 提交中击败了6.46%的用户</p>
<p>内存消耗：5.8 MB, 在所有 Go 提交中击败了93.18%的用户</p>
<p>方法二：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pivotIndex</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    result := <span class="number">0</span></span><br><span class="line">    readAll := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        gte0 := <span class="literal">false</span></span><br><span class="line">        lte0 := <span class="literal">false</span></span><br><span class="line">        <span class="keyword">for</span> _, item := <span class="keyword">range</span> nums &#123;</span><br><span class="line">            <span class="keyword">if</span> item &gt;= <span class="number">0</span> &#123;</span><br><span class="line">                gte0 = <span class="literal">true</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lte0 = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> gte0 &amp;&amp; lte0 &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    loadAll := readAll()</span><br><span class="line">    <span class="keyword">for</span> result &lt; <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">        <span class="keyword">var</span> left <span class="keyword">int</span></span><br><span class="line">        <span class="keyword">var</span> right <span class="keyword">int</span></span><br><span class="line">        <span class="keyword">if</span> result &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> _, item := <span class="keyword">range</span> nums[:result] &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> item == <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">                left += item</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> _, item := <span class="keyword">range</span> nums[result+<span class="number">1</span>:] &#123;</span><br><span class="line">            <span class="keyword">if</span> item == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            right += item</span><br><span class="line">            <span class="keyword">if</span> right &gt; left &amp;&amp; !loadAll &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> left == right &#123;</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">        result++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显示详情</p>
<p>执行用时：424 ms, 在所有 Go 提交中击败了5.26%的用户</p>
<p>内存消耗：5.8 MB, 在所有 Go 提交中击败了100.00%的用户</p>
<p>解法三：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pivotIndex</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> _,item:=<span class="keyword">range</span> nums &#123;</span><br><span class="line">        sum+=item</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> leftSum <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> index,item:=<span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> leftSum==sum-item-leftSum &#123;</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">        &#125;</span><br><span class="line">        leftSum+=item</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行用时：24 ms, 在所有 Go 提交中击败了82.78%的用户</p>
<p>内存消耗：6 MB, 在所有 Go 提交中击败了86.36%的用户</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索插入位置</title>
    <url>/2020/08/07/leetcode%20%E6%95%B0%E7%BB%84-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<h3 id="搜索插入位置"><a href="#搜索插入位置" class="headerlink" title="搜索插入位置"></a>搜索插入位置</h3><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>你可以假设数组中无重复元素。</p>
<p>示例 1:</p>
<p>输入: [1,3,5,6], 5<br>输出: 2<br>示例 2:</p>
<p>输入: [1,3,5,6], 2<br>输出: 1<br>示例 3:</p>
<p>输入: [1,3,5,6], 7<br>输出: 4<br>示例 4:</p>
<p>输入: [1,3,5,6], 0<br>输出: 0</p>
<p>作者：力扣 (LeetCode)<br>链接：<a href="https://leetcode-cn.com/leetbook/read/array-and-string/cxqdh/">https://leetcode-cn.com/leetbook/read/array-and-string/cxqdh/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchInsert</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> nums[<span class="number">0</span>] &gt; target &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> nums[<span class="built_in">len</span>(nums)<span class="number">-1</span>] &lt; target &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> index := <span class="number">0</span>; index &lt; <span class="built_in">len</span>(nums)<span class="number">-1</span>; index++ &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[index] == target &#123;</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> index+<span class="number">1</span> &gt;<span class="built_in">len</span>(nums) &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> nums[index+<span class="number">1</span>] == target &#123;</span><br><span class="line">            <span class="keyword">return</span> index +<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> nums[index] &lt; target &amp;&amp; target &lt; nums[index+<span class="number">1</span>] &#123;</span><br><span class="line">            <span class="keyword">return</span> index + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这个题目主要是考二分查找 </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchInsert</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n:=<span class="built_in">len</span>(nums)</span><br><span class="line">    left,right:=<span class="number">0</span>,n<span class="number">-1</span></span><br><span class="line">    ans:=n</span><br><span class="line">    <span class="keyword">for</span> left&lt;=right &#123;</span><br><span class="line">        mid:=(right-left)&gt;&gt;<span class="number">1</span>+left</span><br><span class="line">        <span class="keyword">if</span> target&lt;= nums[mid] &#123;</span><br><span class="line">            right=mid<span class="number">-1</span></span><br><span class="line">            ans=mid</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            left=mid+<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  ans</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>旋转矩阵</title>
    <url>/2020/08/07/leetcode%20%E6%95%B0%E7%BB%84-%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h3 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h3><p>给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。</p>
<p>不占用额外内存空间能否做到？</p>
<p>示例 1:</p>
<p>给定 matrix =<br>[<br>  [1,2,3],<br>  [4,5,6],<br>  [7,8,9]<br>],</p>
<p>原地旋转输入矩阵，使其变为:<br>[<br>  [7,4,1],<br>  [8,5,2],<br>  [9,6,3]<br>]<br>示例 2:</p>
<p>给定 matrix =<br>[<br>  [ 5, 1, 9,11],<br>  [ 2, 4, 8,10],<br>  [13, 3, 6, 7],<br>  [15,14,12,16]<br>], </p>
<p>原地旋转输入矩阵，使其变为:<br>[<br>  [15,13, 2, 5],<br>  [14, 3, 4, 1],<br>  [12, 6, 8, 9],<br>  [16, 7,10,11]<br>]</p>
<p>作者：力扣 (LeetCode)<br>链接：<a href="https://leetcode-cn.com/leetbook/read/array-and-string/clpgd/">https://leetcode-cn.com/leetbook/read/array-and-string/clpgd/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><ol>
<li>用翻转代替旋转</li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rotate</span><span class="params">(matrix [][]<span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取N</span></span><br><span class="line">    N := <span class="built_in">len</span>(matrix)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先水平翻转</span></span><br><span class="line">    <span class="keyword">for</span> y := <span class="number">0</span>; y &lt; (N / <span class="number">2</span>); y++ &#123;</span><br><span class="line">        matrix[y], matrix[N<span class="number">-1</span>-y] = matrix[N<span class="number">-1</span>-y], matrix[y]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再按主对角线进行元素翻转</span></span><br><span class="line">    <span class="keyword">for</span> y := <span class="number">0</span>; y &lt; N; y++ &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            这里需要注意，如果用 x&lt;N 这个条件，会导致对角线元素翻转两次，最终恢复原状，所以要 x&lt;y</span></span><br><span class="line"><span class="comment">            使得翻转的过程只进行一次，即</span></span><br><span class="line"><span class="comment">            y=0时，不进行翻转</span></span><br><span class="line"><span class="comment">            y=1时，只进行(1,0)和(0,1)元素翻转</span></span><br><span class="line"><span class="comment">            y=2时，(2,0)和(0,2)，(2,1)和(1,2)翻转</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">for</span> x := <span class="number">0</span>; x &lt; y; x++ &#123;</span><br><span class="line">            matrix[y][x], matrix[x][y] = matrix[x][y], matrix[y][x]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="执行结果："><a href="#执行结果：" class="headerlink" title="执行结果："></a>执行结果：</h3><p>通过</p>
<p>显示详情</p>
<p>执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户</p>
<p>内存消耗：2.2 MB, 在所有 Go 提交中击败了58.33%的用户</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 字符串-最长公共前缀</title>
    <url>/2020/08/22/leetcode-%E5%AD%97%E7%AC%A6%E4%B8%B2-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</url>
    <content><![CDATA[<p>最长公共前缀<br>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 “”。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出: &quot;fl&quot;</span><br></pre></td></tr></table></figure>


<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">输出: &quot;&quot;</span><br></pre></td></tr></table></figure>

<p>解释: 输入不存在公共前缀。<br>说明:</p>
<p>所有输入只包含小写字母 a-z 。</p>
<p>思路：</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 数组-对角线遍历</title>
    <url>/2020/08/18/leetcode-%E6%95%B0%E7%BB%84-%E5%AF%B9%E8%A7%92%E7%BA%BF%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个含有 M x N 个元素的矩阵（M 行，N 列），请以对角线遍历的顺序返回这个矩阵中的所有元素，对角线遍历如下图所示。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">[</span><br><span class="line"> [ 1, 2, 3 ],</span><br><span class="line"> [ 4, 5, 6 ],</span><br><span class="line"> [ 7, 8, 9 ]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">输出:  [1,2,4,7,5,3,6,8,9]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/diagonal_traverse.png" alt="解释:"></p>
<p>说明:</p>
<p>给定矩阵中的元素总数不会超过 100000 。</p>
<p>Go</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 官方题解第一种方法，遍历对角线，然后对偶数行序列翻转</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findDiagonalOrder</span><span class="params">(matrix [][]<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(matrix) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历的对角线数目为 行数+列数</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(matrix[<span class="number">0</span>]) + <span class="built_in">len</span>(matrix) - <span class="number">1</span>; i++ &#123;</span><br><span class="line">        <span class="comment">// 当前对角线元素集</span></span><br><span class="line">        cur := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>) </span><br><span class="line">        <span class="comment">// 当前坐标</span></span><br><span class="line">        x,y := <span class="number">0</span>,i</span><br><span class="line">        <span class="comment">// 我们假设右边拼接了一个与行数相等的矩阵，因此，如果遇到拼接的矩阵元素，需要跳过</span></span><br><span class="line">        <span class="keyword">for</span> y &gt;= <span class="built_in">len</span>(matrix[<span class="number">0</span>]) &#123;</span><br><span class="line">            x,y = x+<span class="number">1</span>,y<span class="number">-1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前元素加入集合，向左下角移动一格</span></span><br><span class="line">        <span class="keyword">for</span> x &lt; <span class="built_in">len</span>(matrix) &amp;&amp; y &gt;= <span class="number">0</span> &#123;</span><br><span class="line">            cur = <span class="built_in">append</span>(cur,matrix[x][y])</span><br><span class="line">            x,y = x+<span class="number">1</span>,y<span class="number">-1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是偶数行序列，进行翻转</span></span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">            reverse(cur)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前对角线元素序列加入结果数组</span></span><br><span class="line">        res = <span class="built_in">append</span>(res,cur...)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 翻转数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(cur []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i,j := <span class="number">0</span>,<span class="built_in">len</span>(cur)<span class="number">-1</span>; i &lt; j; i,j = i+<span class="number">1</span>,j<span class="number">-1</span> &#123;</span><br><span class="line">        cur[i],cur[j] = cur[j],cur[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行用时：48 ms, 在所有 Go 提交中击败了20.71%的用户</p>
<p>内存消耗：7 MB, 在所有 Go 提交中击败了6.12%的用户</p>
]]></content>
  </entry>
  <entry>
    <title>leetcode 数组-零矩阵</title>
    <url>/2020/08/17/leetcode-%E6%95%B0%E7%BB%84-%E9%9B%B6%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>零矩阵<br>编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[</span><br><span class="line">  [1,1,1],</span><br><span class="line">  [1,0,1],</span><br><span class="line">  [1,1,1]</span><br><span class="line">]</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [1,0,1],</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [1,0,1]</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[</span><br><span class="line">  [0,1,2,0],</span><br><span class="line">  [3,4,5,2],</span><br><span class="line">  [1,3,1,5]</span><br><span class="line">]</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [0,0,0,0],</span><br><span class="line">  [0,4,5,0],</span><br><span class="line">  [0,3,1,0]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<p>作者：力扣 (LeetCode)<br>链接：<a href="https://leetcode-cn.com/leetbook/read/array-and-string/ciekh/">https://leetcode-cn.com/leetbook/read/array-and-string/ciekh/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>思路：</p>
<p>找到0的位置 然后遍历set 0 就可以</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setZeroes</span><span class="params">(matrix [][]<span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    lenth1 := <span class="built_in">len</span>(matrix)</span><br><span class="line">    lenth2 := <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">    hMap,lMap := <span class="built_in">make</span>([]<span class="keyword">bool</span>,lenth1),<span class="built_in">make</span>([]<span class="keyword">bool</span>,lenth2)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;lenth1;i++&#123;</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span>;j&lt;lenth2;j++&#123;</span><br><span class="line">            <span class="keyword">if</span> matrix[i][j] == <span class="number">0</span>&#123;</span><br><span class="line">                hMap[i] = <span class="literal">true</span></span><br><span class="line">                lMap[j] = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;lenth1;i++&#123;</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span>;j&lt;lenth2;j++&#123;</span><br><span class="line">            <span class="keyword">if</span> hMap[i] || lMap[j]&#123;</span><br><span class="line">                matrix[i][j] = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2020/12/03/log-%E6%97%A5%E5%BF%97%E5%AE%9A%E6%97%B6%E6%B8%85%E7%90%86/</url>
    <content><![CDATA[<h3 id="一、思路"><a href="#一、思路" class="headerlink" title="一、思路"></a>一、<a href="https://www.jianshu.com/p/c8751434b9fb">思路</a></h3><p>定时删除日志，其实分为两个过程：</p>
<ol>
<li>查找符合条件的日志并删除</li>
<li>定时<br>过程1需要写一个查找脚本，过程2需要用到linux的crontab</li>
</ol>
<h3 id="二、查找并删除"><a href="#二、查找并删除" class="headerlink" title="二、查找并删除"></a>二、查找并删除</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># vim delete-logs.sh</span><br></pre></td></tr></table></figure>

<p>删除指定目录下1天以上的日志文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> access.log</span></span><br><span class="line">find /home/work/local/cb-recommendation/logs -name &quot;access.log.*&quot; -mtime +1 -exec  rm -rf &#123;&#125;  \;</span><br><span class="line"><span class="meta">#</span><span class="bash"> counter.log</span></span><br><span class="line">find /home/work/local/cb-recommendation/logs -name &quot;counter.log.*&quot; -mtime +1 -exec  rm -rf &#123;&#125;  \; </span><br><span class="line"><span class="meta">#</span><span class="bash"> geo.log</span></span><br><span class="line">find /home/work/local/cb-recommendation/logs -name &quot;geo.log.*&quot; -mtime +1 -exec  rm -rf &#123;&#125;  \;</span><br><span class="line"><span class="meta">#</span><span class="bash"> recommend.err.log</span></span><br><span class="line">find /home/work/local/cb-recommendation/logs -name &quot;recommend.err.log.*&quot; -mtime +1 -exec  rm -rf &#123;&#125;  \;</span><br><span class="line"><span class="meta">#</span><span class="bash"> recommend.log</span></span><br><span class="line">find /home/work/local/cb-recommendation/logs -name &quot;recommend.log.*&quot; -mtime +1 -exec  rm -rf &#123;&#125;  \;</span><br><span class="line"><span class="meta">#</span><span class="bash"> timer.log</span></span><br><span class="line">find /home/work/local/cb-recommendation/logs -name &quot;timer.log.*&quot; -mtime +1 -exec  rm -rf &#123;&#125;  \;</span><br></pre></td></tr></table></figure>

<p>授权</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> chmod +x delete-logs.sh</span></span><br></pre></td></tr></table></figure>

<h3 id="三、linux定时任务"><a href="#三、linux定时任务" class="headerlink" title="三、linux定时任务"></a>三、linux定时任务</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># crontab -e</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># For details see man 4 crontabs</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Example of job definition:</span></span><br><span class="line"><span class="comment"># .---------------- minute (0 - 59)</span></span><br><span class="line"><span class="comment"># | .-------------- hour (0 - 23)</span></span><br><span class="line"><span class="comment"># | | .---------- day of month (1 - 31)</span></span><br><span class="line"><span class="comment"># | | | .------- month (1 - 12) OR jan,feb,mar,apr ...</span></span><br><span class="line"><span class="comment"># | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span></span><br><span class="line"><span class="comment"># | | | | |</span></span><br><span class="line"><span class="comment"># * * * * * user-name command to be executed</span></span><br><span class="line"> 55 23 * * * /home/work/scripts/delete-logs.sh</span><br></pre></td></tr></table></figure>

<p>完工</p>
]]></content>
  </entry>
  <entry>
    <title>mac init</title>
    <url>/2021/01/06/mac-init/</url>
    <content><![CDATA[<h3 id="软件下载"><a href="#软件下载" class="headerlink" title="软件下载"></a>软件下载</h3><ul>
<li><p>goland</p>
</li>
<li><p>intelij </p>
</li>
<li><p>iterm</p>
</li>
<li><p>docker-desktop</p>
</li>
</ul>
<h3 id="客户端插件"><a href="#客户端插件" class="headerlink" title="客户端插件"></a>客户端插件</h3><ul>
<li><p>mysql</p>
</li>
<li><p>redis</p>
</li>
<li><p>git</p>
</li>
<li><p>jenv</p>
</li>
</ul>
<h3 id="jdk-下载"><a href="#jdk-下载" class="headerlink" title="jdk 下载"></a>jdk 下载</h3><ul>
<li><p>jdk 1.8</p>
</li>
<li><p>logstash</p>
<ul>
<li><p>filebeat</p>
</li>
<li><p>elasticsearch  <a href="https://www.elastic.co/cn/downloads/past-releases#elasticsearch">https://www.elastic.co/cn/downloads/past-releases#elasticsearch</a></p>
</li>
<li><p>kibana</p>
</li>
<li><p>go 1.8</p>
</li>
<li><p>python 3.7</p>
</li>
</ul>
</li>
</ul>
<h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><ul>
<li><pre><code class="shell">alias ll=&#39;ls -l&#39;
&lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ git 自动补全&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ bash_profile&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  + &amp;#96;&amp;#96;&amp;#96;bash&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mfxing  cat ~&amp;#x2F;.bash_profile&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if [ -f ~&amp;#x2F;.bashrc ] ; then&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ~&amp;#x2F;.bashrc&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fi&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    # iterm&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CLICOLOR&amp;#x3D;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    LSCOLORS&amp;#x3D;gxfxcxdxbxegedabagacad&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    export TERM&amp;#x3D;xterm-color&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    export M2_HOME&amp;#x3D;&amp;#x2F;Users&amp;#x2F;mengfanxing_g&amp;#x2F;software&amp;#x2F;apache-maven-3.5.4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    export PATH&amp;#x3D;$PATH:$M2_HOME&amp;#x2F;bin&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ##go&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    export GOPATH&amp;#x3D;&amp;#x2F;Users&amp;#x2F;mengfanxing_g&amp;#x2F;godev&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    export GOBIN&amp;#x3D;$GOPATH&amp;#x2F;bin&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    export PATH&amp;#x3D;$PATH:$GOBIN&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    #export GOPROXY&amp;#x3D;https:&amp;#x2F;&amp;#x2F;goproxy.io,direct&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    export PATH&amp;#x3D;$PATH:$GOROOT&amp;#x2F;bin&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    export GOSUMDB&amp;#x3D;off&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    export GO111MODULE&amp;#x3D;on&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    #export GOPROXY&amp;#x3D;http:&amp;#x2F;&amp;#x2F;10.120.1.209:3000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ##mysql&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    export PATH&amp;#x3D;$&amp;#123;PATH&amp;#125;:&amp;#x2F;usr&amp;#x2F;local&amp;#x2F;mysql&amp;#x2F;bin&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    export PATH&amp;#x3D;&amp;#x2F;usr&amp;#x2F;local&amp;#x2F;mongodb&amp;#x2F;bin:$PATH&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    export PATH&amp;#x3D;&amp;#x2F;usr&amp;#x2F;local&amp;#x2F;Cellar:$PATH&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    export IME_SCRIPTS_PATH&amp;#x3D;&amp;#x2F;Users&amp;#x2F;mengfanxing_g&amp;#x2F;duserver&amp;#x2F;ime-theme-pkg&amp;#x2F;src&amp;#x2F;main&amp;#x2F;resources&amp;#x2F;scripts&amp;#x2F;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    export PATH&amp;#x3D;$PATH:$IME_SCRIPTS_PATH&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    export PATH&amp;#x3D;&amp;quot;$HOME&amp;#x2F;.jenv&amp;#x2F;bin:$PATH&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    export PATH&amp;#x3D;$PATH:&amp;#x2F;Applications&amp;#x2F;Postgres.app&amp;#x2F;Contents&amp;#x2F;Versions&amp;#x2F;11&amp;#x2F;bin&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    # Setting PATH for android-sdk&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    export ANDROID_SDK_ROOT&amp;#x3D;&amp;#x2F;usr&amp;#x2F;local&amp;#x2F;share&amp;#x2F;android-sdk&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    export ANDROID_HOME&amp;#x3D;&amp;#x2F;usr&amp;#x2F;local&amp;#x2F;share&amp;#x2F;android-sdk&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    export PATH&amp;#x3D;&amp;quot;$&amp;#123;PATH&amp;#125;:$&amp;#123;ANDROID_SDK_ROOT&amp;#125;&amp;#x2F;tools:$&amp;#123;ANDROID_SDK_ROOT&amp;#125;&amp;#x2F;platform-tools&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    export PATH&amp;#x3D;&amp;quot;$&amp;#123;PATH&amp;#125;:&amp;#x2F;usr&amp;#x2F;local&amp;#x2F;Cellar&amp;#x2F;gradle&amp;#x2F;5.2.1&amp;#x2F;bin&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    #export PLAY_HOME&amp;#x3D;&amp;#x2F;Applications&amp;#x2F;play-1.2.4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    export PLAY_HOME&amp;#x3D;&amp;#x2F;Users&amp;#x2F;mengfanxing_g&amp;#x2F;tools&amp;#x2F;play-1.2.4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    export PATH&amp;#x3D;$PATH:$PLAY_HOME&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    #eval &amp;quot;$(jenv init -)&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    #enables colorin the terminal bash shell export&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    export CLICOLOR&amp;#x3D;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    #setsup thecolor scheme for list export&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    export LSCOLORS&amp;#x3D;gxfxcxdxbxegedabagacad&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    #sets up theprompt color (currently a green similar to linux terminal)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    #export PS1&amp;#x3D;&amp;#39;\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;36m\]\w\[\033[00m\]\$&amp;#39;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    #enables colorfor iTerm&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    export TERM&amp;#x3D;xterm-256color&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alias gcc&amp;#x3D;&amp;#39;gcc-8&amp;#39;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alias cc&amp;#x3D;&amp;#39;gcc-8&amp;#39;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alias g++&amp;#x3D;&amp;#39;g++-8&amp;#39;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alias c++&amp;#x3D;&amp;#39;c++-8&amp;#39;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    export PATH&amp;#x3D;&amp;quot;&amp;#x2F;Users&amp;#x2F;mengfanxing_g&amp;#x2F;tools:$PATH&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    export MICRO_REGISTRY&amp;#x3D;consul&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alias hwrelaybj1&amp;#x3D;&amp;#39;ssh work@10.49.1.180&amp;#39;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alias hwrelaybj4&amp;#x3D;&amp;#39;ssh work@119.3.170.35&amp;#39;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alias injumper&amp;#x3D;&amp;#39;ssh work@35.154.102.190&amp;#39;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alias hwhk&amp;#x3D;&amp;#39;ssh work@159.138.9.178&amp;#39;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alias sandboxjumper&amp;#x3D;&amp;#39;ssh work@35.160.18.159&amp;#39;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    # java 1.6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    # JAVA_HOME&amp;#x3D;&amp;#x2F;Library&amp;#x2F;Java&amp;#x2F;JavaVirtualMachines&amp;#x2F;1.6.0.jdk&amp;#x2F;Contents&amp;#x2F;Home&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    # java 1.8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    JAVA_HOME&amp;#x3D;&amp;#x2F;Library&amp;#x2F;Java&amp;#x2F;JavaVirtualMachines&amp;#x2F;jdk1.8.0_172.jdk&amp;#x2F;Contents&amp;#x2F;Home&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    #jdk15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    #JAVA_HOME&amp;#x3D;&amp;#x2F;Library&amp;#x2F;Java&amp;#x2F;JavaVirtualMachines&amp;#x2F;jdk-15.0.1.jdk&amp;#x2F;Contents&amp;#x2F;Home&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    PATH&amp;#x3D;$JAVA_HOME&amp;#x2F;bin:$PATH:.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    #CLASSPATH&amp;#x3D;$JAVA_HOME&amp;#x2F;lib&amp;#x2F;tools.jar:$JAVA_HOME&amp;#x2F;lib&amp;#x2F;dt.jar:.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    export JAVA_HOME&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    export PATH&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    export CLASSPATH&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt;

+ bashrc

  &lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;complete -C aws_completer aws&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alias ll=&amp;#x27;ls -l&amp;#x27;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;alias&lt;/span&gt; python=&lt;span class=&quot;string&quot;&gt;&amp;quot;/usr/local/Cellar/python/3.7.0/bin/python3.7&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alias hwmysql=&amp;quot;mysql -h 10.48.1.125 -P 3306 -u root -pHua_xxx_111&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alias hwredis=&amp;quot;redis-cli -h 10.49.1.109 -p6379 -c&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alias python=&amp;quot;/usr/local/bin/python2&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alias login-relay=&amp;quot;ssh mengfanxing@13.251.183.70&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alias redis-cli-dev=&amp;quot;redis-cli -h hkg02-dx-gc04.hkg02.baidu.com -p 8501 -c&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alias redis-cli-sandbox=&amp;quot;redis-cli -h 10.29.10.14 -p 8700 -c&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alias mysql-dev=&amp;quot;mysql -h hkg02-dx-gc04.hkg02.baidu.com -P 8306 -u dev -p&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alias apjumper=&amp;#x27;ssh work@13.251.183.70&amp;#x27;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alias work-relay=&amp;quot;ssh mengfanxing@13.251.183.70&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alias tencent-login=&amp;quot;ssh work@49.234.187.242&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alias usjumper=&amp;#x27;ssh work@52.32.151.225&amp;#x27;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alias inputjumper=&amp;#x27;ssh ec2-user@35.154.102.190&amp;#x27;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alias rec01=&amp;#x27;ssh work@18.138.50.186&amp;#x27;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alias rec02=&amp;#x27;ssh work@18.138.52.92&amp;#x27;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alias huaweiJumper=&amp;#x27;ssh work@159.138.9.178&amp;#x27;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alias lezhuan=&amp;#x27;ssh work@10.49.3.168&amp;#x27;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alias hwrelaybj1=&amp;#x27;ssh work@10.49.1.180&amp;#x27;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alias sandbox=&amp;#x27;ssh work@35.160.18.159&amp;#x27;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alias sandboxk8s=&amp;#x27;ssh k8s@10.29.2.9&amp;#x27;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function git_branch &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  branch=&amp;quot;`git branch 2&amp;gt;/dev/null | grep &amp;quot;^\*&amp;quot; | sed -e &amp;quot;s/^\*\ //&amp;quot;`&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  if [ &amp;quot;$&amp;#123;branch&amp;#125;&amp;quot; != &amp;quot;&amp;quot; ];then&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      if [ &amp;quot;$&amp;#123;branch&amp;#125;&amp;quot; = &amp;quot;(no branch)&amp;quot; ];then&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          branch=&amp;quot;(`git rev-parse --short HEAD`...)&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      fi&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      echo &amp;quot; ($branch)&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  fi&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;export&lt;/span&gt; PS1=&lt;span class=&quot;string&quot;&gt;&amp;#x27;\u@\h \[\033[01;36m\]\W\[\033[01;32m\]$(git_branch)\[\033[00m\] \$ &amp;#x27;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;export LANG=&amp;#x27;UTC-8&amp;#x27;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;export LC_ALL=&amp;#x27;en_US.UTF-8&amp;#x27;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;export TERM=xterm&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alias sandbox=&amp;quot;ssh work@10.29.10.97&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alias sandbox_apollo=&amp;quot;ssh work@10.29.0.236&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alias sandbox_1=&amp;quot;ssh work@35.160.18.159&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt;








</code></pre>
</li>
</ul>
<h4 id="es压测"><a href="#es压测" class="headerlink" title="es压测"></a>es压测</h4><ol>
<li><p>jvm 从cms改G1 看看性能，然后在改为jdk11 使用ZGC 看看性能</p>
</li>
<li><p>新机器需要调整相应配置 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/system-config.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/system-config.html</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo sh -c &quot;ulimit -n 65535 &amp;&amp; exec su $LOGNAME&quot;</span><br><span class="line">sudo sh -c &quot;ulimit -u 4096 &amp;&amp; exec su $LOGNAME&quot;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>pip install –upgrade “esrally==1.2.1”</p>
]]></content>
  </entry>
  <entry>
    <title>mysql--update for select 1</title>
    <url>/2020/08/07/mysql%20%E6%8C%87%E5%AE%9A%E6%9D%A1%E7%9B%AE%E6%95%B0%E9%87%8F%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<h3 id="需求-select-1-for-update"><a href="#需求-select-1-for-update" class="headerlink" title="需求 select 1 for update"></a>需求 select 1 for update</h3><p> 根据过滤条件 然后根据时间降序查询最近得一条记录 然后更新</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>mysql的update语句只支持更新前多少行，不支持从某行到另一行，比如<br><code>UPDATE tb_name SET column_name=&#39;test&#39; ORDER BY id ASC LIMIT 30;</code><br>更新前30行的某个字段内容，没什么问题。</p>
<h3 id="beego的代码实现"><a href="#beego的代码实现" class="headerlink" title="beego的代码实现"></a>beego的代码实现</h3><p>初始版本</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">cardOrm.QueryTable(model.CardRecord&#123;&#125;).Filter(<span class="string">&quot;user_id&quot;</span>, cardRecord.UserId).</span><br><span class="line">                    Filter(<span class="string">&quot;card_id&quot;</span>, cardRecord.CardId).</span><br><span class="line">                    Filter(<span class="string">&quot;create_date&quot;</span>, period).OrderBy(<span class="string">&quot;-ctime&quot;</span>).One(&amp;cardRecordRes)</span><br><span class="line">                <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    logs.Error(<span class="string">&quot;GetCardInfo error!&quot;</span>, err.Error())</span><br><span class="line">                    <span class="built_in">panic</span>(&amp;b_error.BizError&#123;Code: constant.ServerError, Message: <span class="string">&quot;server has something wrong&quot;</span>&#125;)</span><br><span class="line">                &#125;</span><br><span class="line">                cardRecordRes.RealRewardNum = consolation</span><br><span class="line">                cardRecordRes.RealRewardType = cardRecord.RewardType</span><br><span class="line">                cardRecordRes.SymbolUrl = infoList[index].SymbolUrl</span><br><span class="line"></span><br><span class="line">                _, err = cardOrm.Update(&amp;cardRecordRes)</span><br></pre></td></tr></table></figure>

<p>这样的代码会执行两条sql，如果外面再套个for循环个50次 那么久会相当于和mysql 做了100次交互</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="number">16</span>:<span class="number">24</span>:<span class="number">44</span><span class="variable">.363</span> [orm_log<span class="variable">.go</span>:<span class="number">67</span>]  [ORM]<span class="number">2020</span>/<span class="number">08</span>/<span class="number">14</span> <span class="number">16</span>:<span class="number">24</span>:<span class="number">44</span>  -[Queries/<span class="keyword">default</span>] - [  OK /    db<span class="variable">.Query</span> /    <span class="number">34</span><span class="variable">.1ms</span>] - [SELECT T0.<span class="meta">`id`, T0.`user_id`, T0.`create_date`, T0.`card_id`, T0.`state`, T0.`ctime`, T0.`reward_type`, T0.`reward_num`, T0.`real_reward_num`, T0.`real_reward_type`, T0.`lock_type`, T0.`background_url`, T0.`symbol_url` FROM `card_record` T0 WHERE T0.`user_id` = ? AND T0.`card_id` = ? AND T0.`create_date` = ? ORDER BY T0.`ctime` DESC LIMIT 1] - `711`, `67`, `20200814`</span></span><br><span class="line"></span><br><span class="line"><span class="number">2020</span>/<span class="number">08</span>/<span class="number">14</span> <span class="number">16</span>:<span class="number">24</span>:<span class="number">44</span><span class="variable">.453</span> [orm_log<span class="variable">.go</span>:<span class="number">67</span>]  [ORM]<span class="number">2020</span>/<span class="number">08</span>/<span class="number">14</span> <span class="number">16</span>:<span class="number">24</span>:<span class="number">44</span>  -[Queries/<span class="keyword">default</span>] - [  OK /     db<span class="variable">.Exec</span> /    <span class="number">90</span><span class="variable">.2ms</span>] - [UPDATE <span class="meta">`card_record` SET `user_id` = ?, `create_date` = ?, `card_id` = ?, `state` = ?, `ctime` = ?, `reward_type` = ?, `reward_num` = ?, `real_reward_num` = ?, `real_reward_type` = ?, `lock_type` = ?, `background_url` = ?, `symbol_url` = ? WHERE `id` = ?] - `711`, `20200814`, `67`, `2`, `1597393475`, `12`, `100`, `100`, `12`, `1`, `/card/b-27.png`, `s4`, `41150`</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>预想的版本</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">cardOrm.QueryTable(model.CardRecord&#123;&#125;).Filter(<span class="string">&quot;user_id&quot;</span>, cardRecord.UserId).</span><br><span class="line">                    Filter(<span class="string">&quot;card_id&quot;</span>, cardRecord.CardId).</span><br><span class="line">Filter(<span class="string">&quot;create_date&quot;</span>, period).OrderBy(<span class="string">&quot;-ctime&quot;</span>).limit(<span class="number">1</span>,<span class="number">0</span>).update(orm.params&#123;</span><br><span class="line">  <span class="string">&quot;RealRewardNum&quot;</span>:consolation,</span><br><span class="line">  <span class="string">&quot;RealRewardType&quot;</span>:cardRecord.RewardType,</span><br><span class="line">  <span class="string">&quot;SymbolUrl&quot;</span>:infoList[index].SymbolUrl</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是输出的语句是</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="number">2020</span>/<span class="number">08</span>/<span class="number">14</span> <span class="number">17</span>:<span class="number">19</span>:<span class="number">37</span><span class="variable">.159</span> [orm_log<span class="variable">.go</span>:<span class="number">67</span>]  [ORM]<span class="number">2020</span>/<span class="number">08</span>/<span class="number">14</span> <span class="number">17</span>:<span class="number">19</span>:<span class="number">37</span>  -[Queries/<span class="keyword">default</span>] - [  OK /     db<span class="variable">.Exec</span> /    <span class="number">11</span><span class="variable">.2ms</span>] - [update card_record set real_reward_num = ?,real_reward_type=?,symbol_url=? where user_id=? <span class="keyword">and</span> card_id=? <span class="keyword">and</span> create_date=? ] - <span class="meta">`30`, `12`, `s6`, `717`, `68`, `20200814`</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>虽然 减少一次select 的操作 ，但是可以看出暂时beego 不支持 query order by limit update 联合使用 我们只能手写sql </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">_, err := cardOrm.Raw(<span class="string">&quot;update card_record set real_reward_num = ?,real_reward_type=?,symbol_url=?&quot;</span>+</span><br><span class="line">    <span class="string">&quot; where user_id=? and card_id=?&quot;</span>+</span><br><span class="line">    <span class="string">&quot; and create_date=? order by ctime DESC limit 1 &quot;</span>, consolation, cardRecord.RewardType,</span><br><span class="line">    infoList[index].SymbolUrl, cardRecord.UserId, cardRecord.CardId, period).Exec()</span><br></pre></td></tr></table></figure>

<p>输出sql</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="number">2020</span>/<span class="number">08</span>/<span class="number">14</span> <span class="number">17</span>:<span class="number">19</span>:<span class="number">37</span><span class="variable">.159</span> [orm_log<span class="variable">.go</span>:<span class="number">67</span>]  [ORM]<span class="number">2020</span>/<span class="number">08</span>/<span class="number">14</span> <span class="number">17</span>:<span class="number">19</span>:<span class="number">37</span>  -[Queries/<span class="keyword">default</span>] - [  OK /     db<span class="variable">.Exec</span> /    <span class="number">11</span><span class="variable">.2ms</span>] - [update card_record set real_reward_num = ?,real_reward_type=?,symbol_url=? where user_id=? <span class="keyword">and</span> card_id=? <span class="keyword">and</span> create_date=? order by ctime DESC limit <span class="number">1</span> ] - <span class="meta">`30`, `12`, `s6`, `717`, `68`, `20200814`</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> <code>Finish</code></p>
]]></content>
      <categories>
        <category>mysql</category>
        <category>beego</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>beego</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-常用脚本</title>
    <url>/2020/09/04/mysql-%E5%B8%B8%E7%94%A8%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h3 id="连接mysql-脚本"><a href="#连接mysql-脚本" class="headerlink" title="连接mysql 脚本"></a>连接mysql 脚本</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -h $ip -u$username -P$port-p$password $database</span><br></pre></td></tr></table></figure>



<h3 id="导出表结构及表数据"><a href="#导出表结构及表数据" class="headerlink" title="导出表结构及表数据"></a>导出表结构及表数据</h3><p>  1、导出數據库為dbname的表结构（其中用戶名為root,密码為dbpasswd,生成的脚本名為db.sql）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump -h 192.168.1.100 -uroot --single-transaction -pdbpasswd -d dbname &gt;db.sql;</span><br></pre></td></tr></table></figure>

<p>  2、导出數據库為dbname某张表(test)结构</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump -h 192.168.1.100 -uroot --single-transaction -pdbpasswd -d dbname test&gt;db.sql;</span><br></pre></td></tr></table></figure>

<p>  3、导出數據库為dbname所有表结构及表數據（不加-d）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump -h 192.168.1.100 -uroot --single-transaction -pdbpasswd dbname &gt;db.sql;</span><br></pre></td></tr></table></figure>

<p>  4、导出數據库為dbname某张表(test)结构及表數據（不加-d）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump -h 192.168.1.100 -uroot --single-transaction -pdbpasswd dbname test&gt;db.sql;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>mysql-查看字符集</title>
    <url>/2020/08/26/mysql-%E6%9F%A5%E7%9C%8B%E5%AD%97%E7%AC%A6%E9%9B%86/</url>
    <content><![CDATA[<p>一、查看MySQL数据库服务器和数据库MySQL字符集。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> show variables like <span class="string">&#x27;%char%&#x27;</span>;</span></span><br><span class="line">+--------------------------+-----------------------------------------------------------+</span><br><span class="line">| Variable_name            | Value                                                     |</span><br><span class="line">+--------------------------+-----------------------------------------------------------+</span><br><span class="line">| character_set_client     | utf8                                                      |</span><br><span class="line">| character_set_connection | utf8                                                      |</span><br><span class="line">| character_set_database   | utf8                                                      |</span><br><span class="line">| character_set_filesystem | binary                                                    |</span><br><span class="line">| character_set_results    | utf8                                                      |</span><br><span class="line">| character_set_server     | utf8                                                      |</span><br><span class="line">| character_set_system     | utf8                                                      |</span><br><span class="line">| character_sets_dir       | /usr/local/mysql-5.7.23-macos10.13-x86_64/share/charsets/ |</span><br><span class="line">+--------------------------+-----------------------------------------------------------+</span><br><span class="line">8 rows in set (0.02 sec)</span><br></pre></td></tr></table></figure>

<p>二、查看MySQL数据表（table）的MySQL字符集。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> show table status from db_beego like <span class="string">&quot;%tb_category%&quot;</span> \G;</span></span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           Name: tb_category</span><br><span class="line">         Engine: InnoDB</span><br><span class="line">        Version: 10</span><br><span class="line">     Row_format: Dynamic</span><br><span class="line">           Rows: 2</span><br><span class="line"> Avg_row_length: 8192</span><br><span class="line">    Data_length: 16384</span><br><span class="line">Max_data_length: 0</span><br><span class="line">   Index_length: 0</span><br><span class="line">      Data_free: 0</span><br><span class="line"> Auto_increment: 5</span><br><span class="line">    Create_time: 2020-07-21 22:03:14</span><br><span class="line">    Update_time: NULL</span><br><span class="line">     Check_time: NULL</span><br><span class="line">      Collation: utf8mb4_general_ci</span><br><span class="line">       Checksum: NULL</span><br><span class="line"> Create_options:</span><br><span class="line">        Comment:</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>三、查看MySQL数据列（column）的MySQL字符集。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> show full columns from tb_category \G;</span></span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">     Field: id</span><br><span class="line">      Type: int(11)</span><br><span class="line"> Collation: NULL</span><br><span class="line">      Null: NO</span><br><span class="line">       Key: PRI</span><br><span class="line">   Default: NULL</span><br><span class="line">     Extra: auto_increment</span><br><span class="line">Privileges: select,insert,update,references</span><br><span class="line">   Comment:</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">     Field: name</span><br><span class="line">      Type: varchar(255)</span><br><span class="line"> Collation: utf8mb4_general_ci</span><br><span class="line">      Null: NO</span><br><span class="line">       Key:</span><br><span class="line">   Default: NULL</span><br><span class="line">     Extra:</span><br><span class="line">Privileges: select,insert,update,references</span><br><span class="line">   Comment:</span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line">     Field: created</span><br><span class="line">      Type: timestamp</span><br><span class="line"> Collation: NULL</span><br><span class="line">      Null: NO</span><br><span class="line">       Key:</span><br><span class="line">   Default: CURRENT_TIMESTAMP</span><br><span class="line">     Extra:</span><br><span class="line">Privileges: select,insert,update,references</span><br><span class="line">   Comment:</span><br><span class="line">*************************** 4. row ***************************</span><br><span class="line">     Field: updated</span><br><span class="line">      Type: timestamp</span><br><span class="line"> Collation: NULL</span><br><span class="line">      Null: NO</span><br><span class="line">       Key:</span><br><span class="line">   Default: CURRENT_TIMESTAMP</span><br><span class="line">     Extra: on update CURRENT_TIMESTAMP</span><br><span class="line">Privileges: select,insert,update,references</span><br><span class="line">   Comment:</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>nginx的使用</title>
    <url>/2020/08/07/nginx%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="正向代理与反向代理"><a href="#正向代理与反向代理" class="headerlink" title="正向代理与反向代理"></a>正向代理与反向代理</h3><ol>
<li><p>我们常说的代理服务器（多指 VPN），一般就是正向代理。它的特点有：隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端请求的服务都由代理服务器代替来请求；「正向代理」指一对一或多对一，Server 不知道请求的 Client 都是哪些人。</p>
<img src="/images/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86.png" alt="正向代理" style="zoom:33%;" />
</li>
<li><p>反向代理恰好跟正向代理相反。同时反向代理一般是负载均衡的一个原理。按照上面所说，正向代理是一对一或多对一，那么反向代理就是一对多</p>
</li>
</ol>
<img src="/images/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86.png" alt="反向代理" style="zoom:33%;" />

<p><strong>两者的区别在于代理的对象不一样：正向代理代理的对象是客户端，反向代理代理的对象是服务端。</strong></p>
<h3 id="nginx的使用"><a href="#nginx的使用" class="headerlink" title="nginx的使用"></a>nginx的使用</h3><h4 id="启动nginx"><a href="#启动nginx" class="headerlink" title="启动nginx"></a>启动nginx</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./nginx -c nginx.conf</span><br></pre></td></tr></table></figure>

<h4 id="重启nginx"><a href="#重启nginx" class="headerlink" title="重启nginx"></a>重启nginx</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./nginx -s reload</span><br></pre></td></tr></table></figure>



<h4 id="nginx-conf配置熟知"><a href="#nginx-conf配置熟知" class="headerlink" title="nginx.conf配置熟知"></a>nginx.conf配置熟知</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">user root; # 表示nginx是用root用户启动的</span><br><span class="line">worker_processes auto; # 设置nginx的线程数 默认是机器内核的数量</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="获取真实ip"><a href="#获取真实ip" class="headerlink" title="获取真实ip"></a>获取真实ip</h4><ol>
<li><p>这个功能依赖于http_realip_module  在安装nginx的时候 需要带上 <code>--with-http_realip_module</code> </p>
</li>
<li><p>查看已安装的nginx是否支持这个模块</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./tools/nginx/sbin/nginx -V</span><br><span class="line"><span class="meta">&gt;</span></span><br><span class="line">nginx version: nginx/1.12.2</span><br><span class="line">built by gcc 7.3.1 20180303 (Red Hat 7.3.1-5) (GCC)</span><br><span class="line">built with OpenSSL 1.1.0h  27 Mar 2018</span><br><span class="line">TLS SNI support enabled</span><br><span class="line">configure arguments: --prefix=/home/work/tools/nginx --with-http_ssl_module --with-http_sub_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_stub_status_module --with-stream=dynamic --with-compat --with-pcre=/home/work/pcre-8.40 --with-zlib=/home/work/zlib-1.2.11 --with-openssl=/home/work/openssl-1.1.0h</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h4 id="设置server"><a href="#设置server" class="headerlink" title="设置server"></a>设置server</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name  xxx.xx.com; # 绑定域名</span><br><span class="line">    access_log  /data/logs/nginx-access.log  main;</span><br><span class="line">    error_log   /data/logs/nginx-error.log;</span><br><span class="line">    location / &#123; # 设置反向代理的location </span><br><span class="line">             real_ip_header X-Forwarded-For; </span><br><span class="line">             set_real_ip_from x.x.x.x/x; # Ip/network of the reverse proxy (or ip received into REMOTE_ADDR)</span><br><span class="line">             proxy_set_header Host $host;</span><br><span class="line">             proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">             proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">             proxy_pass http://localhost:8080;  # 设置要反向代理的地址</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>redis cluster 批量删除key</title>
    <url>/2020/08/07/redis-cluster%20%E6%89%B9%E9%87%8F%E5%88%A0%E9%99%A4key/</url>
    <content><![CDATA[<p>步骤一：</p>
<p>使用redis nodes 命令 获取master 节点的信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; CLUSTER NODES</span><br><span class="line">47a3cfa636a42217fdde923ad0af975520557fc3 127.0.0.1:6379@16379 myself,slave 73981099d52abe7ed040e9f5c7a30abd4509e4d4 0 1597031768000 0 connected</span><br><span class="line">73981099d52abe7ed040e9f5c7a30abd4509e4d4 127.0.0.1:6379@16379 master - 0 1597031770200 1 connected 0-5460</span><br><span class="line">dfa8c3b9608b9a8e0e663f63c272a4645ccf91bb 127.0.0.1:6379@16379 master - 0 1597031771201 3 connected 10923-16383</span><br><span class="line">f8415a623f17b45a503d0257ee1e6fbd963317af 127.0.0.1:6379@16379 slave dfa8c3b9608b9a8e0e663f63c272a4645ccf91bb 0 1597031770000 3 connected</span><br><span class="line">0b6a6f7ae9283fb0328b6a2a4494411809c4b8c0 127.0.0.1:6379@16379 slave aebe29e94d12609693530f93ede90be1b5163146 0 1597031772202 2 connected</span><br><span class="line">aebe29e94d12609693530f93ede90be1b5163146 127.0.0.1:6379@16379 master - 0 1597031770000 2 connected 5461-10922</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>步骤二：</p>
<p>编写 批量删除key的脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">redis_ser01=xx.xxx.x.xxx</span><br><span class="line"></span><br><span class="line">redis_ser02=127.0.0.1</span><br><span class="line"></span><br><span class="line">redis_ser03=127.0.0.2 </span><br><span class="line"></span><br><span class="line">port=6379</span><br><span class="line"></span><br><span class="line">redis-cli -c -h $redis_ser01 -p $port keys $1 | xargs -i redis-cli -h $redis_ser01 -p $port del &#123;&#125;</span><br><span class="line"></span><br><span class="line">redis-cli -c -h $redis_ser02 -p $port keys $1 | xargs -i redis-cli -h $redis_ser02 -p $port del &#123;&#125;</span><br><span class="line"></span><br><span class="line">redis-cli -c -h $redis_ser03 -p $port keys $1 | xargs -i redis-cli -h $redis_ser03 -p $port del &#123;&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
        <category>运维</category>
        <category>redis</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>URL及参数设计规范</title>
    <url>/2020/08/06/restful-%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h1 id="URL及参数设计规范"><a href="#URL及参数设计规范" class="headerlink" title="URL及参数设计规范"></a><strong>URL及参数设计规范</strong></h1><h2 id="1-uri设计规范"><a href="#1-uri设计规范" class="headerlink" title="1.uri设计规范"></a>1.uri设计规范</h2><ol>
<li>uri末尾不需要出现斜杠/</li>
<li>在uri中使用斜杠/是表达层级关系的。</li>
<li>在uri中可以使用连接符-, 来提升可读性。<br>比如 <a href="http://xxx.com/xx-yy">http://xxx.com/xx-yy</a> 比 <a href="http://xxx.com/xx_yy%E4%B8%AD%E7%9A%84%E5%8F%AF%E8%AF%BB%E6%80%A7%E6%9B%B4%E5%A5%BD%E3%80%82">http://xxx.com/xx_yy中的可读性更好。</a></li>
<li>在uri中不允许出现下划线字符_.</li>
<li>在uri中尽量使用小写字符。</li>
<li>在uri中不允许出现文件扩展名. 比如接口为 /xxx/api, 不要写成 /xxx/api.php 这样的是不合法的。</li>
<li>在uri中使用复数形式。</li>
</ol>
<p>具体可以看：<a href="https://blog.restcase.com/7-rules-for-rest-api-uri-design/">https://blog.restcase.com/7-rules-for-rest-api-uri-design/</a></p>
<p>在RESTful架构中，每个uri代表一种资源，因此uri设计中不能使用动词，只能使用名词，并且名词中也应该尽量使用复数形式。使用者应该使用相应的http动词 GET、POST、PUT、PATCH、DELETE等操作这些资源即可。</p>
<p>那么在我们未使用RESTful规范之前，我们是如下方式来定义接口的，形式是不固定的，并且没有统一的规范。比如如下形式:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">http://xxx.com/api/getallUsers; // GET请求方式，获取所有的用户信息</span><br><span class="line">http://xxx.com/api/getuser/1;   // GET请求方式，获取标识为1的用户信息</span><br><span class="line">http://xxx.com/api/user/delete/1 // GET、POST 删除标识为1的用户信息</span><br><span class="line">http://xxx.com/api/updateUser/1  // POST请求方式 更新标识为1的用户信息</span><br><span class="line">http://xxx.com/api/User/add      // POST请求方式，添加新的用户</span><br></pre></td></tr></table></figure>

<p>如上我们可以看到，在未使用Restful规范之前，接口形式是不固定的，没有统一的规范，下面我们来看下使用RESTful规范的接口如下，两者之间对比下就可以看到各自的优点了。</p>
<ol>
<li><p>api 有版本信息</p>
<p>譬如： <code>/v1/xxoo</code> <code>/v2/xxoo</code></p>
</li>
<li><p>尽可能使用复数,且含义明确。名词最佳</p>
<p><code>/v1/topics</code>  <code>/v1/users</code>  </p>
<p><code>/v1/getusers</code> // 不推荐</p>
</li>
<li><p>使用get参数规划数据展示规则</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;xxx.com&#x2F;api&#x2F;users;     &#x2F;&#x2F; GET请求方式 获取所有用户信息</span><br><span class="line">http:&#x2F;&#x2F;xxx.com&#x2F;api&#x2F;users&#x2F;1;   &#x2F;&#x2F; GET请求方式 获取标识为1的用户信息</span><br><span class="line">http:&#x2F;&#x2F;xxx.com&#x2F;api&#x2F;users&#x2F;1;   &#x2F;&#x2F; DELETE请求方式 删除标识为1的用户信息</span><br><span class="line">http:&#x2F;&#x2F;xxx.com&#x2F;api&#x2F;users&#x2F;1;   &#x2F;&#x2F; PATCH请求方式，更新标识为1的用户部分信息</span><br><span class="line">http:&#x2F;&#x2F;xxx.com&#x2F;api&#x2F;users;     &#x2F;&#x2F; POST请求方式 添加新的用户</span><br><span class="line">http:&#x2F;&#x2F;xxx.com&#x2F;api&#x2F;users?sex&#x3D;1  &#x2F;&#x2F; GET 请求获取sex&#x3D;1的用户是哪些</span><br><span class="line">http:&#x2F;&#x2F;xxx.com&#x2F;api&#x2F;users?country&#x3D;CN &#x2F;&#x2F; GET 请求获取country&#x3D;CN的用户是哪些</span><br><span class="line">http:&#x2F;&#x2F;xxx.com&#x2F;api&#x2F;users?limit&#x3D;10 &#x2F;&#x2F; GET 请求获取10个用户</span><br></pre></td></tr></table></figure>

<h2 id="2-HTTP请求规范"><a href="#2-HTTP请求规范" class="headerlink" title="2.HTTP请求规范"></a>2.HTTP请求规范</h2><p>GET (SELECT): 查询；从服务器取出资源.<br>POST(CREATE): 新增; 在服务器上新建一个资源。<br>PUT(UPDATE): 更新; 在服务器上更新资源(客户端提供改变后的完整资源)。<br>PATCH(UPDATE): 更新；在服务器上更新部分资源(客户端提供改变的属性)。<br>DELETE(DELETE): 删除; 从服务器上删除资源。</p>
<h2 id="3-参数命名规范"><a href="#3-参数命名规范" class="headerlink" title="3.参数命名规范"></a>3.参数命名规范</h2><p>参数推荐采用下划线命名的方式。比如如下demo:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;xxx.com&#x2F;api&#x2F;today-login &#x2F;&#x2F; 获取今天登录的用户。</span><br><span class="line">http:&#x2F;&#x2F;xxx.com&#x2F;api&#x2F;today-login&amp;sort&#x3D;login_desc &#x2F;&#x2F; 获取今天登录的用户、登录时间降序排序。</span><br></pre></td></tr></table></figure>

<h2 id="4-http状态码相关的"><a href="#4-http状态码相关的" class="headerlink" title="4.http状态码相关的"></a>4.http状态码相关的</h2><h3 id="状态码范围"><a href="#状态码范围" class="headerlink" title="状态码范围"></a>状态码范围</h3><p>客户端的每一次请求, 服务器端必须给出回应，回应一般包括HTTP状态码和数据两部分。</p>
<p>1xx: 信息，请求收到了，继续处理;表示消息中包含一个临时的信息响应。<br>2xx: 代表成功. 行为被成功地接收、理解及采纳。<br>3xx: 重定向。<br>4xx: 客户端错误，请求包含语法错误或请求无法实现。<br>5xx: 服务器端错误.</p>
<h4 id="2xx-状态码"><a href="#2xx-状态码" class="headerlink" title="2xx 状态码"></a>2xx 状态码</h4><p>200 OK [GET]: 服务器端成功返回用户请求的数据。<br>201 CREATED [POST/PUT/PATCH]: 用户新建或修改数据成功。<br>202 Accepted 表示一个请求已经进入后台排队(一般是异步任务)。<br>204 NO CONTENT -[DELETE]: 用户删除数据成功。</p>
<h4 id="4xx状态码"><a href="#4xx状态码" class="headerlink" title="4xx状态码"></a>4xx状态码</h4><p>400：Bad Request - [POST/PUT/PATCH]: 用户发出的请求有错误，服务器不理解客户端的请求，未做任何处理。<br>401: Unauthorized; 表示用户没有权限(令牌、用户名、密码错误)。<br>403：Forbidden: 表示用户得到授权了，但是访问被禁止了, 也可以理解为不具有访问资源的权限。<br>404：Not Found: 所请求的资源不存在，或不可用。<br>405：Method Not Allowed: 用户已经通过了身份验证, 但是所用的HTTP方法不在它的权限之内。<br>406：Not Acceptable: 用户的请求的格式不可得(比如用户请求的是JSON格式，但是只有XML格式)。<br>410：Gone - [GET]: 用户请求的资源被转移或被删除。且不会再得到的。<br>415: Unsupported Media Type: 客户端要求的返回格式不支持，比如，API只能返回JSON格式，但是客户端要求返回XML格式。<br>422：Unprocessable Entity: 客户端上传的附件无法处理，导致请求失败。<br>429：Too Many Requests: 客户端的请求次数超过限额。</p>
<h4 id="5xx-状态码"><a href="#5xx-状态码" class="headerlink" title="5xx 状态码"></a>5xx 状态码</h4><p>5xx 状态码表示服务器端错误。</p>
<p>500：INTERNAL SERVER ERROR; 服务器发生错误。<br>502：网关错误。<br>503: Service Unavailable 服务器端当前无法处理请求。<br>504：网关超时。</p>
<p>##5.统一返回数据格式</p>
<p>RESTful规范中的请求应该返回统一的数据格式。对于返回的数据，一般会包含如下字段:</p>
<ol>
<li>code: http响应的状态码。</li>
<li>status: 包含文本, 比如：’success’(成功), ‘fail’(失败), ‘error’(异常) HTTP状态响应码在500-599之间为 ‘fail’; 在400-499之间为 ‘error’, 其他一般都为 ‘success’。 对于响应状态码为 1xx, 2xx, 3xx 这样的可以根据实际情况可要可不要。</li>
</ol>
<p>当status的值为 ‘fail’ 或 ‘error’时，需要添加 message 字段，用于显示错误信息。</p>
<ol start="3">
<li>data: 当请求成功的时候, 返回的数据信息。 但是当状态值为 ‘fail’ 或 ‘error’ 时，data仅仅包含错误原因或异常信息等。</li>
</ol>
<p>返回成功的响应JSON格式一般为如下:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;code&quot;</span>: <span class="number">200</span>,</span><br><span class="line">    <span class="attr">&quot;status&quot;</span>: <span class="string">&quot;success&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>: [&#123;</span><br><span class="line">        <span class="attr">&quot;userName&quot;</span>: <span class="string">&quot;tugenhua&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;age&quot;</span>: <span class="number">31</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回失败的响应json格式为如下:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;code&quot;</span>: <span class="number">401</span>,</span><br><span class="line">    <span class="attr">&quot;status&quot;</span>: <span class="string">&quot;error&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;message&quot;</span>: &#x27;用户没有权限&#x27;,</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>架构设计</category>
        <category>restful</category>
      </categories>
      <tags>
        <tag>restful</tag>
      </tags>
  </entry>
  <entry>
    <title>shell执行curl请求</title>
    <url>/2020/09/04/shell-%E6%89%A7%E8%A1%8Ccurl%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<p>需求： 给550w用户 批量调用融云接口封禁</p>
<ol>
<li>按行读取文件的内容</li>
<li>执行curl命令 </li>
<li>输出请求的结果</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">function httpRequest()</span><br><span class="line">&#123;</span><br><span class="line">    #curl 请求</span><br><span class="line">    info=`curl -X POST \</span><br><span class="line">  https://api-sg01.ronghub.com/user/block.json \</span><br><span class="line">  -H &#x27;App-Key: qf3d5gbjq9pyh&#x27; \</span><br><span class="line">  -H &#x27;Content-Type: application/x-www-form-urlencoded&#x27; \</span><br><span class="line">  -H &#x27;Nonce: 14314&#x27; \</span><br><span class="line">  -H &#x27;Postman-Token: b2a4bf59-a20e-4654-afa1-489ab18085fe&#x27; \</span><br><span class="line">  -H &#x27;Signature: 7c14b3ebd8896ca00221447087a1ce71343bbddb&#x27; \</span><br><span class="line">  -H &#x27;Timestamp: 1599048545791&#x27; \</span><br><span class="line">  -H &#x27;cache-control: no-cache&#x27; \</span><br><span class="line">  -d &#x27;userId=$&#123;1&#125;&amp;minute=43200&amp;undefined=&#x27;`</span><br><span class="line">   echo &quot;info is :&quot; $&#123;info&#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">cat /home/work/rongyun/user_result.txt | while read line</span><br><span class="line"> do</span><br><span class="line">     userId=&quot;&quot;</span><br><span class="line">    echo &quot;File:$&#123;line&#125;&quot;</span><br><span class="line">     userId=$&#123;line&#125;</span><br><span class="line">     echo $&#123;userId&#125;</span><br><span class="line">     httpRequest &quot;$&#123;userId&#125;&quot;</span><br><span class="line"> done</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>sublime json 格式化快捷键</title>
    <url>/2020/08/20/sublime-json-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<p>1、打开 Sublime，<code>command + shift + p</code> -&gt; Install package<br> 搜索 Pretty JSON，安装</p>
<p>2、手工 install</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I: cd &lt;Packages directory&gt; (例如 Mac ~&#x2F;Library&#x2F;Application\ Support&#x2F;Sublime\ Text\ 2&#x2F;Packages </span><br><span class="line">or </span><br><span class="line">~&#x2F;Library&#x2F;Application\ Support&#x2F;Sublime\ Text\ 3&#x2F;Packages)</span><br><span class="line"></span><br><span class="line">II: git clone https:&#x2F;&#x2F;github.com&#x2F;dzhibas&#x2F;SublimePrettyJson.git</span><br></pre></td></tr></table></figure>

<p>格式化快捷键 :</p>
<p>macOS: <code>command + ctrl + j</code><br> Windows: <code>ctrl + alt + j</code></p>
]]></content>
  </entry>
  <entry>
    <title>tencent准备工作</title>
    <url>/2020/12/17/tencent%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/</url>
    <content><![CDATA[<p>部门：未来实验室-车路协同平台组</p>
<p>核心业务: </p>
<ol>
<li>端的工作（android端，小程序端）这部分工作不多</li>
<li>纯后台的工作（go多）</li>
<li>后台+web的工作（web管理类）这部分go+react </li>
<li>交通仿真器的工作 python</li>
<li>平台的工作 和边缘计算平台结合的如k8s之类的组件使用的之类的</li>
</ol>
<p>业务特性：</p>
<ol>
<li>大数据、这个大数据可能是超乎想象的大数据，一台无人车一天几tb的数据</li>
<li>高实时两个非常重要的特性的、高实时也是超乎想象的，需要服务有百毫秒级别的延迟</li>
<li>当然我们的这个产品是很多高实时的特性，有可能传统的组件都不适用、需要我们自己研发</li>
</ol>
<p>补充：</p>
<ol>
<li>这里的百毫秒是端到端的时延，不是服务时延，也就是服务时延可能只有10ms左右的，但是这里又有很多的计算、目前都处于探索和权衡的阶段，也就没有找到特别合适的组件，这里面最近正在做的也是要各种对比选型，看看情况</li>
</ol>
<p>自己负责的工作：</p>
<ol>
<li>平台的工作 和边缘计算平台结合的如k8s之类的组件使用的之类的</li>
<li>组件化，之前我们的产品是poc层级的，现在要poc转化成可交付的产品，这里面有很多组件化的工作，比如引入redis，hbase等等组件去改造</li>
<li>有兴趣可以研究一下flink之类的流处理组件的一些指标</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>vim的常用命令</title>
    <url>/2020/08/06/vim%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="vim-多行注释"><a href="#vim-多行注释" class="headerlink" title="vim 多行注释"></a>vim 多行注释</h3><ol>
<li>首先按 esc 进入命令<strong>行</strong>模式下，按下 Ctrl + v ，进入列（也叫区块）模式;</li>
<li>在<strong>行</strong>首使用上下键选择需要<strong>注释</strong>的<strong>多行</strong>;</li>
<li>按下键盘（大写） “I” 键，进入插入模式；</li>
<li>然后输入<strong>注释</strong>符（ “//”、“#”     等）;</li>
<li>最后按下 “Esc” 键。 注：在按下 esc 键后，会稍等一会才会出现<strong>注释</strong>，不要着急~~时间很短的</li>
</ol>
<h3 id="vim-多行取消注释"><a href="#vim-多行取消注释" class="headerlink" title="vim 多行取消注释"></a>vim 多行取消注释</h3><ol>
<li>Ctrl + v 进入块选择模式</li>
<li>选中你要删除的行首的注释符号，注意// 要选中两个</li>
<li>选好之后按d即可删除注释</li>
</ol>
]]></content>
      <categories>
        <category>vim</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>vmware-NAT配置</title>
    <url>/2020/12/20/vmware-NAT%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h3 id="搭建前提"><a href="#搭建前提" class="headerlink" title="搭建前提"></a>搭建前提</h3><p>配置前提，没有连接宽带，使用的是wifi。</p>
<h4 id="我们需要先了解一下什么是NAT"><a href="#我们需要先了解一下什么是NAT" class="headerlink" title="我们需要先了解一下什么是NAT"></a>我们需要先了解一下什么是NAT</h4><h5 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h5><p>在Windows上搭建集群实验环境时，为能够让集群结点之间相互通信，我们需要通过VMware进行网络设置。我们主要讲解NAT模式(网络地址转换模式)的原理及配置过程。</p>
<h5 id="二、工作原理"><a href="#二、工作原理" class="headerlink" title="二、工作原理"></a>二、工作原理</h5><p>1.“NAT”类型，称为网络地址转换，在“仅主机”类型的基础上提供了guest可以访问外部host的能力<br>2.虚拟机之间、虚拟机和宿主机之间、虚拟机和外部host之间都可以进行通信<br>3.虚拟机的IP只需要配置NAT网段中的IP，访问外部host可以通过宿主机IP访问。它不需要有外部网络独立的IP（即物理交换机网段中的IP）<br>4.优点：虚拟机的网络配置确定后，就可以很少变动。因为NAT配置不变，宿主机连接的网络变化，不影响虚拟机。所以大部分集群实验选择的就是NAT模式</p>
<img src="/images/vmware-NAT%E9%85%8D%E7%BD%AE/SouthEast.png" alt="这里写图片描述" style="zoom: 67%;" />



<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol>
<li>需要宿主机关闭防火墙</li>
<li>需要开启主机VMware的2个服务：NAT和DHCP（默认是开启的），如果没有开启，在虚拟机中添加vm0，vm1.vm8，在宿主机中就会自动创建出来了。</li>
<li>NAT使用得是VMnet8得虚拟网卡，我们需要将<img src="/images/vmware-NAT%E9%85%8D%E7%BD%AE/image-20201219163743635.png" alt="image-20201219163743635"></li>
</ol>
<p>wlan配置共享给VMnet8，然后修改vmnet8得ip v4配置</p>
<img src="/images/vmware-NAT%E9%85%8D%E7%BD%AE/image-20201219164052935.png" alt="image-20201219164052935" style="zoom:50%;" />

<ol start="4">
<li><p>设置vmnet8 ip地址为192.168.0.2,默认网关设置为192.168.0.1 子网掩码设置为255.255.255.0</p>
</li>
<li><p>设置虚拟机使用NAT模式进行和宿主机连接 <img src="/images/vmware-NAT%E9%85%8D%E7%BD%AE/image-20201219164519656.png" alt="image-20201219164519656" style="zoom: 25%;" /></p>
</li>
<li><p>编辑虚拟机中的网络配置<img src="/images/vmware-NAT%E9%85%8D%E7%BD%AE/image-20201219164645822.png" alt="image-20201219164645822" style="zoom:25%;" />，</p>
<p>同时还需要设置图中得DHCP配置，配置虚拟机静态ip所属得网段。<img src="/images/vmware-NAT%E9%85%8D%E7%BD%AE/image-20201219164830809.png" alt="image-20201219164830809" style="zoom:25%;" /></p>
<ol start="7">
<li><p>配置虚拟机网卡信息：切换root用户，输入以下命令，进入VI编辑，配置保存即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/sysconfig/network-scripts/ifcfg-eth33</span><br></pre></td></tr></table></figure>

<img src="/images/vmware-NAT%E9%85%8D%E7%BD%AE/image-20201219165024491.png" alt="image-20201219165024491" style="zoom:50%;" />

<ol start="8">
<li><p>重启网络服务 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用service命令</span></span><br><span class="line">service network restart </span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 systemctl </span></span><br><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="借鉴的链接"><a href="#借鉴的链接" class="headerlink" title="借鉴的链接"></a>借鉴的链接</h3><ol>
<li><a href="https://blog.csdn.net/dingguanyi/article/details/77829085">https://blog.csdn.net/dingguanyi/article/details/77829085</a> </li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>zip&amp;unzip的使用</title>
    <url>/2020/08/07/zip-unzip%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="zip的使用"><a href="#zip的使用" class="headerlink" title="zip的使用"></a>zip的使用</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zip -r myfile.zip ./*</span><br><span class="line">将当前目录下的所有文件和文件夹全部压缩成myfile.zip文件,－r表示递归压缩子目录下所有文件.</span><br></pre></td></tr></table></figure>



<h3 id="unzip-的使用"><a href="#unzip-的使用" class="headerlink" title="unzip 的使用"></a>unzip 的使用</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">unzip -o -d /home/sunny myfile.zip</span><br><span class="line">把myfile.zip文件解压到 /home/sunny/</span><br><span class="line">-o:不提示的情况下覆盖文件；</span><br><span class="line">-d:-d /home/sunny 指明将文件解压缩到/home/sunny目录下；</span><br></pre></td></tr></table></figure>



<h3 id="对已有zip包的更改"><a href="#对已有zip包的更改" class="headerlink" title="对已有zip包的更改"></a>对已有zip包的更改</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zip -d myfile.zip smart.txt</span><br><span class="line">删除压缩文件中smart.txt文件</span><br><span class="line">zip -m myfile.zip ./rpm_info.txt</span><br><span class="line">向压缩文件中myfile.zip中添加rpm_info.txt文件</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>zip</tag>
        <tag>unzip</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2020/11/10/%E4%BC%B4%E9%B1%BC%E9%9D%A2%E8%AF%95%E9%A2%98%20/</url>
    <content><![CDATA[<p>给定一个字符串表示的数字 str ， (只包含0-9，没有前导0)， </p>
<p>再给一个整数K，k &lt;= len(str) </p>
<p>从str里删掉k个字符，使剩下的字符串表示的数值最小 (原字符串里，每个字符的顺序是不能改变的。)</p>
<p>str=”351” k=1</p>
<p>“31”</p>
<p>str=”3519” k=1</p>
<p>“319” </p>
<p>3519 K=2</p>
<p>319 k=1</p>
<p>351  359 5193</p>
<p>str=”3519” k=2</p>
<p>35 51 </p>
<p>35 31  39 51 59 19</p>
<p>结果  len-k</p>
<p>15分钟</p>
<p>35991 k=2</p>
<p>351</p>
<p>12345  k=3</p>
<p>func getMin（str string,k int）string{</p>
<p> max:=-1 </p>
<p>for （i:=0;i&lt;len-k;i++）{</p>
<p>if str[i:k] &gt; max{}</p>
<p>}</p>
<p>for  k– {</p>
<p>first:=strconv.atoi(str[0])</p>
<p>second:=strconv.atoi(str[1]) //i</p>
<p>if first&lt;second{</p>
<p> str= str[0]+str[2:]</p>
<p>391</p>
<p>}else{</p>
<p>str= str[1：]</p>
<p> }</p>
<p>}</p>
<p>  return str</p>
<p>}</p>
<p>1000万推送量，下游PUSH接口的QPS 1w/s的限制</p>
<p>\1. 在预定时间内 比如 30分钟推完1000万条push</p>
<p>\2. 控制推送速率，不能打垮下游RPC接口</p>
<p><img src="/Users/mengfanxing_g/richard/blog/XingServer/source/_posts/image-20201110214534990.png" alt="image-20201110214534990">                       ![            </p>
<p>​          <img src="/Users/mengfanxing_g/richard/blog/XingServer/source/_posts/image-20201110214447919.png" alt="11">            </p>
]]></content>
  </entry>
  <entry>
    <title>修改linux时区</title>
    <url>/2020/08/06/%E4%BF%AE%E6%94%B9linux%E6%97%B6%E5%8C%BA/</url>
    <content><![CDATA[<h3 id="查看当前时区"><a href="#查看当前时区" class="headerlink" title="查看当前时区"></a>查看当前时区</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">date -R</span><br></pre></td></tr></table></figure>



<h3 id="修改时区为东八区"><a href="#修改时区为东八区" class="headerlink" title="修改时区为东八区"></a>修改时区为东八区</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>复杂度分析</title>
    <url>/2020/08/05/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="时间与复杂度分析"><a href="#时间与复杂度分析" class="headerlink" title="时间与复杂度分析"></a>时间与复杂度分析</h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>###理解 </p>
<p><img src="https://static001.geekbang.org/resource/image/22/ef/22900968aa2b190072c985a08b0e92ef.png" alt="img"></p>
<p>T(n) :    是所有代码执行的时间</p>
<p>O:    表示代码的执行时间 T(n) 与 f(n) 表达式成正比</p>
<p>f(n) :    表示每行代码执行的次数总和</p>
<p>这就是大 O 时间复杂度表示法。大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。</p>
<p>我们通常会忽略掉公式中的常量、低阶、系数，只需要记住一个最大的阶就可以了；所以我们在分析代码的时间复杂度的时候只需要关注执行次数最大的那一段代码就可以了</p>
<h3 id="代码复杂度量级"><a href="#代码复杂度量级" class="headerlink" title="代码复杂度量级"></a>代码复杂度量级</h3><p><img src="https://static001.geekbang.org/resource/image/37/0a/3723793cc5c810e9d5b06bc95325bf0a.jpg" alt="img"></p>
<p>####复杂度量级分类</p>
<p>多项式量级和非多项式量级，</p>
<p>#####非多项式量级</p>
<h6 id="增数阶O-2-n-和阶乘阶-O-n"><a href="#增数阶O-2-n-和阶乘阶-O-n" class="headerlink" title="增数阶O($2^n$) 和阶乘阶 O(n!)"></a>增数阶O($2^n$) 和阶乘阶 O(n!)</h6><p>非多项式量级也叫Non-Deterministic Polynomial 非确定多项式，因为当n越来越大的时候，非多项式量级算法的执行时间急剧增大。</p>
<p>#####多项式量级的时间复杂度</p>
<h6 id="O-1"><a href="#O-1" class="headerlink" title="O(1)"></a>O(1)</h6><p>理解：O(1)只是常量级时间复杂度的一种表示、并不是只执行了一行代码，比如下面 即便代码有三行它的时间复杂度也是O(1)而不是O(3)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">8</span>; </span><br><span class="line"><span class="keyword">var</span> j = <span class="number">6</span>; </span><br><span class="line"><span class="keyword">var</span> sum = i + j;</span><br></pre></td></tr></table></figure>

<h6 id="O-log-2n-amp-O-nlog-2n"><a href="#O-log-2n-amp-O-nlog-2n" class="headerlink" title="O($log_2n$)&amp;O($nlog_2n$)"></a>O($log_2n$)&amp;O($nlog_2n$)</h6><p>for example O($log_2n$)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i=<span class="number">1</span>; </span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> i&lt;=n &#123;</span><br><span class="line">        <span class="keyword">break</span> </span><br><span class="line">    &#125;</span><br><span class="line">  i = i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据前面时间复杂度分析、i=i*2 和 if 语句执行的次数最多。我们只要知道这两行代码执行了多少次就能算出这段代码的时间复杂度。 </p>
<p><img src="https://static001.geekbang.org/resource/image/9b/9a/9b1c88264e7a1a20b5954be9bc4bec9a.jpg" alt="img"></p>
<p> 所以我们只要知道x是多少 我们就能知道i=i*2 和if语句执行的次数是多少。通过$2^x=n$ 转换得出 x= $log_2n$</p>
<p>所以这段代码的时间复杂度是 2$log_2n$ 因为2是常数可以省略，所以这段代码最终的时间复杂度是$log_2n$</p>
<p>for example O($nlog_2n$)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i=<span class="number">1</span>; </span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> i&lt;=n &#123;</span><br><span class="line">        <span class="keyword">break</span> </span><br><span class="line">    &#125;</span><br><span class="line">  i = i * <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据上面的思路可以很容易的看出这段代码的时间复杂度是 $log_3n$ ,实际是不管是以2为底、以3为底，还是以10为底，我们都可以把所有对数阶的时间复杂度都记为$log_2n$ ；我们知道对数之间是可以相互转化的，$log_3n = log_32<em>log_2n$  所以O($log_3n$) =O(C</em> $log_2n$) 其中C= $log_32 $  是一个常量、根据大O表示法可以忽略系数，即 </p>
<p>O(Cf(n)) = O(f(n))。所以，O($log_2n$) 就等于 O($log_3n$)。</p>
<h6 id="O-m-n-、O-m-n"><a href="#O-m-n-、O-m-n" class="headerlink" title="O(m+n)、O(m*n)"></a>O(m+n)、O(m*n)</h6><p>for example</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cal</span><span class="params">( m, n <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum_1 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; m; ++i) &#123;</span><br><span class="line">    sum_1 = sum_1 + i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> sum_2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> j = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; j &lt; n; ++j) &#123;</span><br><span class="line">    sum_2 = sum_2 + j;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum_1 + sum_2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中我们可以看出，m、n是两个数据规模，我们无法评估出m、n谁的量级大、所以我们在表达复杂度的时候就不能简单的利用加法法则省略其中的一个，所以上面的代码复杂度是O(m+n)。</p>
<h5 id="总结复杂度分析法则"><a href="#总结复杂度分析法则" class="headerlink" title="总结复杂度分析法则"></a>总结复杂度分析法则</h5><p>1）单段代码看高频：比如循环。<br>2）多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。<br>3）嵌套代码求乘积：比如递归、多重循环等<br>4）多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加</p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>与时间复杂度类比、空间复杂度就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">(n <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">  slice := <span class="built_in">make</span>([]<span class="keyword">int</span>,n)</span><br><span class="line">  <span class="keyword">for</span> (;i&lt;=n;i++)&#123;</span><br><span class="line">    slice[i]=i*i</span><br><span class="line">  &#125;</span><br><span class="line">  logs.<span class="built_in">println</span>(slice)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟分析时间复杂度一样，看到第二行，我们申请了一个空间存储变量 i，但是它是常量阶的跟数据规模没有关系、所以我们可以忽略，第三行我们申请了一个长度和容量都为n的切片，除此之外下面代码没有占用额外的存储空间、所以这段代码占用的空间复杂度为O(n)</p>
<p>我们常见的空间复杂度是O(1)、O(n)、O( $n^2$ )</p>
<h2 id="最好、最坏、平均、均摊时间复杂度分析"><a href="#最好、最坏、平均、均摊时间复杂度分析" class="headerlink" title="最好、最坏、平均、均摊时间复杂度分析"></a>最好、最坏、平均、均摊时间复杂度分析</h2><p>最好情况时间复杂度（best case time complexity）、最坏情况时间复杂度（worst case time complexity）</p>
<p>平均情况时间复杂度（average case time complexity）、均摊时间复杂度（amortized time complexity）</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2020/11/02/%E5%AD%9F%E5%87%A1%E6%98%9F%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86/</url>
    <content><![CDATA[<p>孟凡星</p>
<p>电话：17600362123</p>
<p>邮箱：<a href="mailto:nizhidaoIEdeyisima@gmail.com">nizhidaoIEdeyisima@gmail.com</a>  <a href="mailto:17600362123@yahoo.com">17600362123@yahoo.com</a></p>
<h2 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h2><p>男 未婚</p>
<p>27岁</p>
<p>沈阳大学/本科</p>
<p>工作经验：4年</p>
<p>现居住地： 北京</p>
<p>户口所在地：辽宁-葫芦岛</p>
<p>求职意向 偏向于go</p>
<p>期望工作性质 : 全职</p>
<p>期望月薪 : 35k/月</p>
<p>期望从事行业 : 计算机软件</p>
<p>期望从事职业 : 软件开发</p>
<p>期望工作地点 : 北京</p>
<p>目前状况 : 我目前处于在职</p>
<p>自我评价</p>
<ol>
<li>老实、踏实、认真、仔细、有责任心是我的做事方式，总会高于领导的要求来严格要求自己，对领导分配的任务能高效及时的完成。</li>
<li>抗压能力、自学能力强，对在开发中用到的新技术、疑难问题，能够快速的从网上或其他地方获取解决办法，有自己的学习笔记，乐于技术分享</li>
<li>能指导初级、中级工程师进行开发。</li>
<li>对工作负责，有集体荣誉感，任劳任怨。</li>
<li>热爱学习，热衷于技术，经常学习新技术补充自己。</li>
<li>有带领团队的经验（5-8人）</li>
<li>对于容器化的部署有丰富的经验</li>
</ol>
<h2 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h2><h3 id="2018-7月至今北京小熊博望（百度国际化）"><a href="#2018-7月至今北京小熊博望（百度国际化）" class="headerlink" title="2018.7月至今北京小熊博望（百度国际化）"></a>2018.7月至今北京小熊博望（百度国际化）</h3><h3 id="2017-10月2018-7中国中煤能源股份有限公司"><a href="#2017-10月2018-7中国中煤能源股份有限公司" class="headerlink" title="2017.10月2018.7中国中煤能源股份有限公司"></a>2017.10月2018.7<a href="https://www.baidu.com/link?url=LvM0KE2SlhWwuukv0f2xuySMWmdIx4Qe1WzDvim-m7UkX_HB1ZCZ2muEUsOyB_fE&wd=&eqid=ae8224ba0003a119000000035b4ad478">中国中煤能源股份有限公司</a></h3><p>###2016.12月2017.9北京智慧流科技教育有限公司</p>
<h2 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h2><p><strong>2018.7-至今</strong></p>
<p>Meet （视频聊天 reslet netty） </p>
<p>Sleepiness （轻应用类 springboot）</p>
<p>SleepinessCMS （sleepiness的cms平台 Vue）</p>
<p>MaterialPlatform （轻应用类 springboot）</p>
<p>MaterialPlatformCMS （贴纸平台的cms  Vue）</p>
<p>输入法主题自动打包 （小工具类 内部使用 Go）</p>
<p>壁纸SDK (轻应用类 Go)</p>
<p>壁纸SDKCMS (壁纸cms Vue)</p>
<p>生酮饮食 (轻应用类 Go)</p>
<p>场景化sdk （小工具类 Go）</p>
<p>海外赚 （轻应用类Go）</p>
<p>海外赚CMS （轻应用类Go 开发中）</p>
<p>luck-quiz (轻应用类Go)新meet(java)</p>
<p><strong>2017.10月-2018.7</strong></p>
<p>Itzh集团的ERP系统 （企业内部管理系统ssm ext）</p>
<p><strong>2016.10-2017.9</strong></p>
<p>陕旅英语（k12 dubbo）</p>
<p>闽教英语（k12 dubbo）</p>
<p>湘少英语（k12 dubbo）</p>
<p>粤人英语（k12 dubbo）</p>
<p>课堂宝 （素材资源上传平台）</p>
<p><strong>在国际化工作描述 :</strong> </p>
<ol>
<li>负责国际化出海产品的开发</li>
<li>老百度国际化项目的迁移</li>
<li>Elk集群的部署和维护</li>
<li>实时分析公司各个产品线的pv、uv 、接口超时情况、日志error报警</li>
<li>代码review及优化</li>
<li>线上项目的维护</li>
<li>Springboot 和golang 对小工具、轻应用产品的开发</li>
<li>使用AWS CI/CD，云容器的部署、服务上线</li>
<li>技术分享</li>
<li>把控各个产品线的工作进度，确保主要产品线的正常迭代&amp;注意组员的工作状态</li>
<li>负责对招聘新员工进行面试及安排</li>
</ol>
<p><strong>meet项目描述</strong> </p>
<p>这个项目是海外的视频语音聊天软件，由于是全球范围内都有普及，用户可以相互视频或者语音聊天，所以引发了用户的很高兴趣，为了提高用户的体验，缓存用户的数据结构改为了redis hash（对uid取模来分shard），为了可以多条件筛选附近的聊天室，选取了用mongodb来对聊天室进行geo 建模，对于多种匹配策略，复用了工厂的设计模式，通过这个项目的开发，学习了很多，深入的明白了如何写出高质量的代码，实现需求功能如何做技术选型，熟练的使用shell编写脚本，来计算pv uv，编写定时任务（后期我搭建了elastic集群，能够实时的收集各个产品的日志，图形化的展示产品的健康情况，对于错误日志和接口的响应情况进行分析，能够及时发送给rd），后期优化为视频聊天，提供主播对用户一对一服务的聊天、通过对主播的录屏、接通时长还有接通率来给主播进行打分，实现流量倾斜，通过一些假用户的消息下发来吸引用户付费。 目前日pv1400w的pv ，项目部署再aws的eks上，通过pod的性能参数、来考虑是否要增加机器。</p>
<p><strong>luckquiz项目描述</strong></p>
<p> 这个是一个基于beego开发的项目，有答题、刮卡、乐透、幸运转盘的小游戏，初期是吸引用户玩游戏来消耗金币、然后通过开广告来获取奖励的生态模式来运作。通过aes对用户和时间戳来加密生成验证用户有效性的token、像答题、刮卡、转盘每天玩的次数都是有次数限制的、而且奖励的金币概率和中奖概率也需要随时用户金币数和现金数的增加而改变。其中答题要求下发给用户的题目信息不允许有重复的，</p>
<p>方案一： 使用mysql not in（性能太差）<br>方案二： 了解到 其实是给用户下发的题目和题库的题目做差集，使用redis sdiff 命令 redis key是这样的，因为sdiff key1 key2 ，<br>key1 key2 如果不在同一个slot上，就会发出redis 错误，所以开始用{}，先计算key的hash，将answer 用{}括起来，使其<br>落在同一个slot上,题库的题目 {answer}:load-questions:%questionType ,用户看过的题目 {answer}:load-questions-by:%userId<br>能到达预期目的<br>方案三： 方案二虽然能达到预期目的，但是随着用户量的增加、单个slot的容量总是有限的，所以在用户注册的时候，给每个用户都会将题库复制一份，<br>rediskey 与userId进行绑定,题库的题目 answer:load-questions:{userId}:questionType ,用户看过的题目 answer:load-questions-by:{userId}<br>这样解决了单个slot内存过于庞大的问题这个还有一个好处就是差集的计算都交给了redis 的机器去操作<br>方案四：使用bitset 指令 SETBIT key offset value 复杂度 O(1)<br>一个bit位来表示某个元素对应的值或者状态,其中的key就是对应元素本身。我们知道8个bit可以组成一个Byte，所以bitmap本身会极大的节省储存空间。之前存储一个questionId是int64类型 ，大概的空间占用计算公式是：($offset/8/1024/1024)MB，也就是说8388608 个题目在redis里才会占用1mb的内存空间， offset 标识题目id，0 标识未打过，1标识已经答过</p>
<p><strong>2017.10-月2018.7</strong></p>
<p><strong>在中煤工作描述 :</strong> </p>
<ol>
<li>负责企业内部网站的开发</li>
<li>对接口的性能进行自测，并对代码调优。</li>
<li>相关模块接口的开发和单元测试</li>
<li>代码review</li>
<li>线上项目的维护&amp;项目进度的推进</li>
<li>和项目经理确定需求可行性。</li>
</ol>
<p><strong>项目描述 :</strong></p>
<p>这个项目是做集团的ERP系统，这个项目极大的提高了部门领导对项目的审核效率和对资产预算的评估情况，以及资产管理部门对资产分配的了解，项目处对各个项目详细信息的控制情况。 这个项目涉及了资产模块、项目模块和采购模块这三个主要功能、</p>
<p>个人承担对项目模块的全部开发。这个项目采用的是Ssm架构、通过对mybatis-generator开源框架的修改、自动化生成了对表的业务逻辑的正删改查、和接口的自动化测试脚本和junit测试实例、因为这个项目是企业的办公软件、大多数业务逻辑都是围绕对表的增删改查、</p>
<p>所以大大的减轻了开发的时间、提高了开发效率。 这个项目的亮点就是解耦很成功、三个主要功能都可以各自拆分开来、整个项目采用的是前后端分离的开发模式、大大的提高了开发效率。通过这个项目我学到了工作流的开发、更重要的是和小组人员的及时沟通</p>
<p>能减少不必要的开发上的错误、也能提高工作效率、再一次的认识到在开发前小组讨论对业务的熟悉对开发而言的重要及必要性。而且在讨论中能够对自己想法淬炼、增强思维的严谨性。</p>
<p><strong>项目描述 :</strong> </p>
<p>专业技能</p>
<ul>
<li>微服务的两个派系 阿里系的dubbo 和SpringCloud栈系的SpringBoot。</li>
<li>云服务      aws 、huawei CI/CD ，docker 和k8s的使用 </li>
<li>熟练在Linux系统上开发，编写shell脚本</li>
<li>java golang  python nodejs     </li>
<li>基本框架 Spring SpringMvc Mybatis Hebinate     JPA vue beego </li>
<li>服务治理：zookeper </li>
<li>请求治理：nginx、elb、nlb</li>
<li>数据库：mysql 、redis 、mangodb、elasticearch oracle sqlserver、sql优化</li>
<li>前端：html5(熟悉) extjs、jquery、jsp</li>
<li>高并发基本技能：队列 多线程 </li>
<li>网络通信：netty 、socket</li>
<li>爬虫 （jsoup、python）</li>
</ul>
<p><strong>教育经历</strong></p>
<p><strong>2013.09-2017.06</strong> <strong>沈阳大学 |</strong> <strong>计算机科学与技术 |**</strong>本科**</p>
<p>所获证书</p>
<ul>
<li>全国大学生创新创业训练计划项目 国家三等奖</li>
<li>辽宁省创青春大学生创业比赛  银奖</li>
<li>辽宁省计算机软件设计大赛-外包组三等奖</li>
<li>沈阳大学计算机软件设计竞赛 一等奖</li>
<li>互联网+大学生创新创业大赛     一等奖</li>
<li>大学生移动应用开发大赛 三等奖</li>
<li>大学英语四级</li>
</ul>
<p>语言能力</p>
<p><strong>英语 :</strong> <strong>读写能力良好 |</strong> <strong>听说能力良好</strong></p>
<p><strong>其他：优秀毕业生</strong> <strong>答辩成绩 94</strong></p>
<p> 孟凡星</p>
<p>电话：17600362123</p>
<p>邮箱：<a href="mailto:nizhidaoIEdeyisima@gmail.com">nizhidaoIEdeyisima@gmail.com</a>  <a href="mailto:17600362123@yahoo.com">17600362123@yahoo.com</a></p>
]]></content>
  </entry>
  <entry>
    <title>打包go-web镜像</title>
    <url>/2020/10/29/%E6%89%93%E5%8C%85go-web%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>文件夹复制cp</title>
    <url>/2020/08/07/%E6%96%87%E4%BB%B6%E5%A4%B9%E5%A4%8D%E5%88%B6cp/</url>
    <content><![CDATA[<h3 id="文件夹复制"><a href="#文件夹复制" class="headerlink" title="文件夹复制"></a>文件夹复制</h3><ol>
<li><p>正常的复制命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp -rf /www/cms.whd.com/conf/  mycms/</span><br><span class="line">-r 是递归的意思，会把问价下的子文件目录都会复制</span><br><span class="line">-f 参数是强制复制，比如你在a文件中有个文件名叫b，然后你把c文件夹里面的另一个文件名叫做b的复制到a里面，这个时候回冲突，然后会提示你要不要继续复制，加上-f就不会提示你了。</span><br><span class="line"></span><br><span class="line">但是当我们执行上面的那个命令时还是会提示你要不要覆盖</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>直接使用命令实习 (推荐)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> \cp -rf &#x2F;www&#x2F;cms.whd.com&#x2F;conf&#x2F;  &#x2F;www&#x2F;cms.manager&#x2F;core&#x2F;conf&#x2F;</span><br><span class="line">如果写在脚本中可以使用下面的方式 $(pwd) 或者 $&#96;pwd&#96; 来获取当前的目录路径</span><br><span class="line"> \cp -rf &#x2F;www&#x2F;cms.whd.com&#x2F;conf&#x2F; $(pwd)&#x2F;target&#x2F;cms.manager&#x2F;bdp&#x2F;core&#x2F;conf&#x2F;</span><br><span class="line">我们看到 只是在命令前加了一个反斜杠（\），这样就不会再次确认了，而且只在命令中起作用比较好。</span><br></pre></td></tr></table></figure>



</li>
</ol>
]]></content>
      <categories>
        <category>linux</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>cp</tag>
      </tags>
  </entry>
  <entry>
    <title>架构-选型</title>
    <url>/2020/08/27/%E6%9E%B6%E6%9E%84-%E9%80%89%E5%9E%8B/</url>
    <content><![CDATA[<h3 id="是否需要使用mvc模式"><a href="#是否需要使用mvc模式" class="headerlink" title="是否需要使用mvc模式"></a>是否需要使用mvc模式</h3><ol>
<li><p>mvc 模式</p>
<p>​    <img src="/images/%E6%9E%B6%E6%9E%84-%E9%80%89%E5%9E%8B/mvc.png" alt="mvc模式"></p>
<ol>
<li>controllers : 处理/user /pay 相关业务数据的输入和输出</li>
<li>实体 譬如 数据库实体类</li>
<li>Dao层 业务的实际处理层</li>
</ol>
<p>简单的业务 没什么并发</p>
</li>
<li><p>分布式模式</p>
</li>
</ol>
<img src="/images/%E6%9E%B6%E6%9E%84-%E9%80%89%E5%9E%8B/%E5%88%86%E5%B8%83%E5%BC%8F.png" alt="分布式" style="zoom: 50%;" />

<p>分布式架构 可以很好的对具体的业务做流量的负载均衡，适合流量很高的业务，集群方式去部署 </p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>端口占用</title>
    <url>/2020/08/07/%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8/</url>
    <content><![CDATA[<h3 id="查看端口占用"><a href="#查看端口占用" class="headerlink" title="查看端口占用"></a>查看端口占用</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mac使用lsof 查看端口8080是否被占用 </span></span><br><span class="line">lsof -i:8080</span><br><span class="line"><span class="meta">&gt;</span></span><br><span class="line">COMMAND PID          USER   FD   TYPE            DEVICE SIZE/OFF NODE NAME</span><br><span class="line">BaiduHi 444 mengfanxing_g   54u  IPv4 0xa65d4596444d7d5      0t0  TCP localhost:63023-&gt;123.125.115.205:http-alt (ESTABLISHED)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> linux 使用netstat 查看8080是佛被占用</span></span><br><span class="line">netstat -anp| grep 8080</span><br><span class="line"><span class="meta">&gt;</span></span><br><span class="line">(Not all processes could be identified, non-owned process info</span><br><span class="line"> will not be shown, you would have to be root to see it all.)</span><br><span class="line">tcp6       0      0 :::8080                 :::*                    LISTEN      25263/./new-meet-ro</span><br><span class="line">tcp6       0      0 x.x.x.x:33316      117.78.7.65:8080        ESTABLISHED 26598/java</span><br><span class="line">tcp6       0      0 x.x.x.x:33236      117.78.7.65:8080        ESTABLISHED 26509/java</span><br></pre></td></tr></table></figure>



<h3 id="根据pid查看进程"><a href="#根据pid查看进程" class="headerlink" title="根据pid查看进程"></a>根据pid查看进程</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用lsof 查看pid=25263的进程</span></span><br><span class="line">lsof -i: grep 25263</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> new-meet- 25263 work    6u  IPv6 1043683416      0t0  TCP *:webcache (LISTEN)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用netstat 查看pid=25263的进程</span></span><br><span class="line">netstat -nap | grep 25263</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> (Not all processes could be identified, non-owned process info</span></span><br><span class="line"> will not be shown, you would have to be root to see it all.)</span><br><span class="line">tcp6       0      0 :::8080                 :::*                    LISTEN      25263/./new-meet-ro</span><br></pre></td></tr></table></figure>



<h3 id="查看远程端口是否打开"><a href="#查看远程端口是否打开" class="headerlink" title="查看远程端口是否打开"></a>查看远程端口是否打开</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用nc 来检查单个端口</span></span><br><span class="line">nc -zv 127.0.0.1 22</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">  Connection to 127.0.0.1 port 22 [tcp/ssh] succeeded!</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用nc 来检查一段打开的端口范围</span></span><br><span class="line">nc -zv 127.0.0.1 22-24</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Connection to 127.0.0.1 port 22 [tcp/ssh] succeeded!</span></span><br><span class="line">nc: connectx to 127.0.0.1 port 23 (tcp) failed: Connection refused</span><br><span class="line">nc: connectx to 127.0.0.1 port 24 (tcp) failed: Connection refused</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>port</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2020/11/17/%E7%BB%99%E4%BD%A0100w%E4%B8%AA%E6%95%B0%E5%AD%97%20%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E6%9C%80%E5%A4%A7%E7%9A%84100%E4%B8%AA%E6%95%B0%E5%AD%97%EF%BC%8C%E9%82%A3%E4%B9%88%E4%B8%80%E4%B8%AA%E4%BA%BF%E5%91%A2%20%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h3 id="给你100w个数字-如何获取最大的100个数字，那么一个亿呢-怎么处理"><a href="#给你100w个数字-如何获取最大的100个数字，那么一个亿呢-怎么处理" class="headerlink" title="给你100w个数字 如何获取最大的100个数字，那么一个亿呢 怎么处理"></a>给你100w个数字 如何获取最大的100个数字，那么一个亿呢 怎么处理</h3><h3 id="排序-用哪种排序-他的时间复杂度-最优情况是什么-最差情况是什么样"><a href="#排序-用哪种排序-他的时间复杂度-最优情况是什么-最差情况是什么样" class="headerlink" title="排序 用哪种排序 他的时间复杂度 最优情况是什么 最差情况是什么样"></a>排序 用哪种排序 他的时间复杂度 最优情况是什么 最差情况是什么样</h3><h3 id="你有什么要问面试官的吗？"><a href="#你有什么要问面试官的吗？" class="headerlink" title="你有什么要问面试官的吗？"></a>你有什么要问面试官的吗？</h3><h3 id="您的团队是什么样的？你对您的团队有什么规划吗？有没有定期的做技术分享呢？然后说说自己团队的技术分享是怎么做的"><a href="#您的团队是什么样的？你对您的团队有什么规划吗？有没有定期的做技术分享呢？然后说说自己团队的技术分享是怎么做的" class="headerlink" title="您的团队是什么样的？你对您的团队有什么规划吗？有没有定期的做技术分享呢？然后说说自己团队的技术分享是怎么做的"></a>您的团队是什么样的？你对您的团队有什么规划吗？有没有定期的做技术分享呢？然后说说自己团队的技术分享是怎么做的</h3><h3 id="你对我本次的面试评价觉得怎么样？"><a href="#你对我本次的面试评价觉得怎么样？" class="headerlink" title="你对我本次的面试评价觉得怎么样？"></a>你对我本次的面试评价觉得怎么样？</h3>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2020/11/02/%E7%BB%8F%E5%8E%86%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>孟凡星</p>
<p>电话：17600362123</p>
<p>邮箱：<a href="mailto:nizhidaoIEdeyisima@gmail.com">nizhidaoIEdeyisima@gmail.com</a>  <a href="mailto:17600362123@yahoo.com">17600362123@yahoo.com</a></p>
<h2 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h2><p>男 未婚</p>
<p>27岁</p>
<p>沈阳大学/本科</p>
<p>工作经验：4年</p>
<p>现居住地： 北京</p>
<p>户口所在地：辽宁-葫芦岛</p>
<p>求职意向 偏向于go</p>
<p>期望工作性质 : 全职</p>
<p>期望月薪 : 35k/月</p>
<p>期望从事行业 : 计算机软件</p>
<p>期望从事职业 : 软件开发</p>
<p>期望工作地点 : 北京</p>
<p>目前状况 : 我目前处于在职</p>
<p>自我评价</p>
<ol>
<li>老实、踏实、认真、仔细、有责任心是我的做事方式，总会高于领导的要求来严格要求自己，对领导分配的任务能高效及时的完成。</li>
<li>抗压能力、自学能力强，对在开发中用到的新技术、疑难问题，能够快速的从网上或其他地方获取解决办法，有自己的学习笔记，乐于技术分享</li>
<li>能指导初级、中级工程师进行开发。</li>
<li>对工作负责，有集体荣誉感，任劳任怨。</li>
<li>热爱学习，热衷于技术，经常学习新技术补充自己。</li>
<li>有带领团队的经验（5-8人）</li>
<li>对于容器化的部署有丰富的经验</li>
</ol>
<h2 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h2><h3 id="2018-7月至今北京小熊博望（百度国际化）"><a href="#2018-7月至今北京小熊博望（百度国际化）" class="headerlink" title="2018.7月至今北京小熊博望（百度国际化）"></a>2018.7月至今北京小熊博望（百度国际化）</h3><h3 id="2017-10月2018-7中国中煤能源股份有限公司"><a href="#2017-10月2018-7中国中煤能源股份有限公司" class="headerlink" title="2017.10月2018.7中国中煤能源股份有限公司"></a>2017.10月2018.7<a href="https://www.baidu.com/link?url=LvM0KE2SlhWwuukv0f2xuySMWmdIx4Qe1WzDvim-m7UkX_HB1ZCZ2muEUsOyB_fE&wd=&eqid=ae8224ba0003a119000000035b4ad478">中国中煤能源股份有限公司</a></h3><p>###2016.3月2017.9北京智慧流科技教育有限公司</p>
<h2 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h2><p><strong>2018.7-至今</strong></p>
<p>Meet （视频聊天 reslet netty） </p>
<p>Sleepiness （轻应用类 springboot）</p>
<p>SleepinessCMS （sleepiness的cms平台 Vue）</p>
<p>MaterialPlatform （轻应用类 springboot）</p>
<p>MaterialPlatformCMS （贴纸平台的cms  Vue）</p>
<p>输入法主题自动打包 （小工具类 内部使用 Go）</p>
<p>壁纸SDK (轻应用类 Go)</p>
<p>壁纸SDKCMS (壁纸cms Vue)</p>
<p>生酮饮食 (轻应用类 Go)</p>
<p>场景化sdk （小工具类 Go）</p>
<p>海外赚 （轻应用类Go）</p>
<p>海外赚CMS （轻应用类Go 开发中）</p>
<p>luck-quiz (轻应用类Go)</p>
<p>新meet(java)</p>
<p><strong>2017.10月-2018.7</strong></p>
<p>Itzh集团的ERP系统 （企业内部管理系统ssm ext）</p>
<p><strong>2016.10-2017.9</strong></p>
<p>陕旅英语（k12 dubbo）</p>
<p>闽教英语（k12 dubbo）</p>
<p>湘少英语（k12 dubbo）</p>
<p>粤人英语（k12 dubbo）</p>
<p>课堂宝 （素材资源上传平台）</p>
<p><strong>在国际化工作描述 :</strong> </p>
<ol>
<li>负责国际化出海产品的开发</li>
<li>老百度国际化项目的迁移</li>
<li>Elk集群的部署和维护</li>
<li>实时分析公司各个产品线的pv、uv 、接口超时情况、日志error报警</li>
<li>代码review及优化</li>
<li>线上项目的维护</li>
<li>Springboot 和golang 对小工具、轻应用产品的开发</li>
<li>使用AWS CI/CD，云容器的部署、服务上线</li>
<li>技术分享</li>
<li>把控各个产品线的工作进度，确保主要产品线的正常迭代&amp;注意组员的工作状态</li>
<li>负责对招聘新员工进行面试及安排</li>
</ol>
<p><strong>meet项目描述</strong> </p>
<p>这个项目是海外的视频语音聊天软件，由于是全球范围内都有普及，用户可以相互视频或者语音聊天，所以引发了用户的很高兴趣，为了提高用户的体验，缓存用户的数据结构改为了redis hash（对uid取模来分shard），为了可以多条件筛选附近的聊天室，选取了用mongodb来对聊天室进行geo 建模，对于多种匹配策略，复用了工厂的设计模式，通过这个项目的开发，学习了很多，深入的明白了如何写出高质量的代码，实现需求功能如何做技术选型，熟练的使用shell编写脚本，来计算pv uv，编写定时任务（后期我搭建了elastic集群，能够实时的收集各个产品的日志，图形化的展示产品的健康情况，对于错误日志和接口的响应情况进行分析，能够及时发送给rd），后期优化为视频聊天，提供主播对用户一对一服务的聊天、通过对主播的录屏、接通时长还有接通率来给主播进行打分，实现流量倾斜，通过一些假用户的消息下发来吸引用户付费。 目前日pv1400w的pv ，项目部署再aws的eks上，通过pod的性能参数、来考虑是否要增加机器。</p>
<p><strong>luckquiz项目描述</strong></p>
<p> 这个是一个基于beego开发的项目，有答题、刮卡、乐透、幸运转盘的小游戏，初期是吸引用户玩游戏来消耗金币、然后通过开广告来获取奖励的生态模式来运作。通过aes对用户和时间戳来加密生成验证用户有效性的token、像答题、刮卡、转盘每天玩的次数都是有次数限制的、而且奖励的金币概率和中奖概率也需要随时用户金币数和现金数的增加而改变。其中答题要求下发给用户的题目信息不允许有重复的，</p>
<p>方案一： 使用mysql not in（性能太差）<br>方案二： 了解到 其实是给用户下发的题目和题库的题目做差集，使用redis sdiff 命令 redis key是这样的，因为sdiff key1 key2 ，<br>key1 key2 如果不在同一个slot上，就会发出redis 错误，所以开始用{}，先计算key的hash，将answer 用{}括起来，使其<br>落在同一个slot上,题库的题目 {answer}:load-questions:%questionType ,用户看过的题目 {answer}:load-questions-by:%userId<br>能到达预期目的<br>方案三： 方案二虽然能达到预期目的，但是随着用户量的增加、单个slot的容量总是有限的，所以在用户注册的时候，给每个用户都会将题库复制一份，<br>rediskey 与userId进行绑定,题库的题目 answer:load-questions:{userId}:questionType ,用户看过的题目 answer:load-questions-by:{userId}<br>这样解决了单个slot内存过于庞大的问题这个还有一个好处就是差集的计算都交给了redis 的机器去操作<br>方案四：使用bitset 指令 SETBIT key offset value 复杂度 O(1)<br>一个bit位来表示某个元素对应的值或者状态,其中的key就是对应元素本身。我们知道8个bit可以组成一个Byte，所以bitmap本身会极大的节省储存空间。之前存储一个questionId是int64类型 ，大概的空间占用计算公式是：($offset/8/1024/1024)MB，也就是说8388608 个题目在redis里才会占用1mb的内存空间， offset 标识题目id，0 标识未打过，1标识已经答过</p>
<p><strong>2017.10-月2018.7</strong></p>
<p><strong>在中煤工作描述 :</strong> </p>
<ol>
<li>负责企业内部网站的开发</li>
<li>对接口的性能进行自测，并对代码调优。</li>
<li>相关模块接口的开发和单元测试</li>
<li>代码review</li>
<li>线上项目的维护&amp;项目进度的推进</li>
<li>和项目经理确定需求可行性。</li>
</ol>
<p><strong>项目描述 :</strong></p>
<p>这个项目是做集团的ERP系统，这个项目极大的提高了部门领导对项目的审核效率和对资产预算的评估情况，以及资产管理部门对资产分配的了解，项目处对各个项目详细信息的控制情况。 这个项目涉及了资产模块、项目模块和采购模块这三个主要功能、</p>
<p>个人承担对项目模块的全部开发。这个项目采用的是Ssm架构、通过对mybatis-generator开源框架的修改、自动化生成了对表的业务逻辑的正删改查、和接口的自动化测试脚本和junit测试实例、因为这个项目是企业的办公软件、大多数业务逻辑都是围绕对表的增删改查、</p>
<p>所以大大的减轻了开发的时间、提高了开发效率。 这个项目的亮点就是解耦很成功、三个主要功能都可以各自拆分开来、整个项目采用的是前后端分离的开发模式、大大的提高了开发效率。通过这个项目我学到了工作流的开发、更重要的是和小组人员的及时沟通</p>
<p>能减少不必要的开发上的错误、也能提高工作效率、再一次的认识到在开发前小组讨论对业务的熟悉对开发而言的重要及必要性。而且在讨论中能够对自己想法淬炼、增强思维的严谨性。</p>
<p><strong>项目描述 :</strong> </p>
<p>专业技能</p>
<ul>
<li>微服务的两个派系 阿里系的dubbo 和SpringCloud栈系的SpringBoot。</li>
<li>云服务      aws 、huawei CI/CD ，docker 和k8s的使用 </li>
<li>熟练在Linux系统上开发，编写shell脚本</li>
<li>java golang  python nodejs     </li>
<li>基本框架 Spring SpringMvc Mybatis Hebinate     JPA vue beego </li>
<li>服务治理：zookeper </li>
<li>请求治理：nginx、elb、nlb</li>
<li>数据库：mysql 、redis 、mangodb、elasticearch oracle sqlserver、sql优化</li>
<li>前端：html5(熟悉) extjs、jquery、jsp</li>
<li>高并发基本技能：队列 多线程 </li>
<li>网络通信：netty 、socket</li>
<li>爬虫 （jsoup、python）</li>
</ul>
<p><strong>教育经历</strong></p>
<p><strong>2013.09-2017.06</strong> <strong>沈阳大学 |</strong> <strong>计算机科学与技术 |**</strong>本科**</p>
<p>所获证书</p>
<ul>
<li>全国大学生创新创业训练计划项目 国家三等奖</li>
<li>辽宁省创青春大学生创业比赛  银奖</li>
<li>辽宁省计算机软件设计大赛-外包组三等奖</li>
<li>沈阳大学计算机软件设计竞赛 一等奖</li>
<li>互联网+大学生创新创业大赛     一等奖</li>
<li>大学生移动应用开发大赛 三等奖</li>
<li>大学英语四级</li>
</ul>
<p>语言能力</p>
<p><strong>英语 :</strong> <strong>读写能力良好 |</strong> <strong>听说能力良好</strong></p>
<p><strong>其他：优秀毕业生</strong> <strong>答辩成绩 94</strong></p>
<p> 孟凡星</p>
<p>电话：17600362123</p>
<p>邮箱：<a href="mailto:nizhidaoIEdeyisima@gmail.com">nizhidaoIEdeyisima@gmail.com</a>  <a href="mailto:17600362123@yahoo.com">17600362123@yahoo.com</a></p>
]]></content>
  </entry>
  <entry>
    <title>自己学习gRPC(一)</title>
    <url>/2020/09/25/%E8%87%AA%E5%B7%B1%E5%AD%A6%E4%B9%A0gRPC-%E4%B8%80/</url>
    <content><![CDATA[<p>参照文档：</p>
<p><a href="https://developers.google.com/protocol-buffers/docs/gotutorial">https://developers.google.com/protocol-buffers/docs/gotutorial</a>  google接入protobuf官方文档</p>
<p><a href="https://github.com/protocolbuffers/protobuf/releases">https://github.com/protocolbuffers/protobuf/releases</a>  protoc 的github二进制下载地址</p>
<h4 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h4><ol>
<li><h4 id="先安装protoc"><a href="#先安装protoc" class="headerlink" title="先安装protoc"></a>先安装protoc</h4></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd protoc-3.6.1-osx-x86_64</span><br><span class="line">cp -r include/ /usr/local/include/</span><br><span class="line">cp -r bin/ /usr/local/bin/</span><br></pre></td></tr></table></figure>

<p><strong>如果是mac 需要去系统偏好设置中授权</strong> </p>
<p>测试如果展示和下面证明安装成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mfxing  protoc</span><br><span class="line">Usage: protoc [OPTION] PROTO_FILES</span><br><span class="line">Parse PROTO_FILES and generate output based on the options given:</span><br><span class="line">  -IPATH, --proto_path=PATH   Specify the directory in which to search for</span><br><span class="line">                              imports.  May be specified multiple times;</span><br><span class="line">                              directories will be searched in order.  If not</span><br><span class="line">                              given, the current working directory is used.</span><br><span class="line">                              If not found in any of the these directories,</span><br><span class="line">                              the --descriptor_set_in descriptors will be</span><br><span class="line">                              checked for required proto file.</span><br><span class="line">  --version                   Show version info and exit.</span><br><span class="line">  ...</span><br><span class="line">    @&lt;filename&gt;                 Read options and filenames from file. If a</span><br><span class="line">                              relative file path is specified, the file</span><br><span class="line">                              will be searched in the working directory.</span><br><span class="line">                              The --proto_path option will not affect how</span><br><span class="line">                              this argument file is searched. Content of</span><br><span class="line">                              the file will be expanded in the position of</span><br><span class="line">                              @&lt;filename&gt; as in the argument list. Note</span><br><span class="line">                              that shell expansion is not applied to the</span><br><span class="line">                              content of the file (i.e., you cannot use</span><br><span class="line">                              quotes, wildcards, escapes, commands, etc.).</span><br><span class="line">                              Each line corresponds to a single argument,</span><br><span class="line">                              even if it contains spaces.</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>安装protoc-gen-go</p>
<ol>
<li><p>Install the protocol compiler plugin for Go (<code>protoc-gen-go</code>) using the following command:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">export</span> GO111MODULE=on  <span class="comment"># Enable module mode</span></span><br><span class="line">$ go get github.com/golang/protobuf/protoc-gen-go</span><br></pre></td></tr></table></figure>
</li>
<li><p>Update your <code>PATH</code> so that the <code>protoc</code> compiler can find the plugin:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">export</span> PATH=<span class="string">&quot;<span class="variable">$PATH</span>:<span class="subst">$(go env GOPATH)</span>/bin&quot;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<h3 id="Get-the-example-code"><a href="#Get-the-example-code" class="headerlink" title="Get the example code"></a>Get the example code</h3><p>The example code is part of the <a href="https://github.com/grpc/grpc-go">grpc-go</a> repo.</p>
<ol>
<li><p><a href="https://github.com/grpc/grpc-go/archive/v1.31.0.zip">Download the repo as a zip file</a> and unzip it, or clone the repo:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> -b v1.31.0 https://github.com/grpc/grpc-go</span><br></pre></td></tr></table></figure>
</li>
<li><p>Change to the quick start example directory:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> grpc-go/examples/helloworld</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="Run-the-example"><a href="#Run-the-example" class="headerlink" title="Run the example"></a>Run the example</h3><p>From the <code>examples/helloworld</code> directory:</p>
<ol>
<li><p>Compile and execute the server code:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ go run greeter_server/main.go</span><br></pre></td></tr></table></figure>
</li>
<li><p>From a different terminal, compile and execute the client code to see the client output:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ go run greeter_client/main.go</span><br><span class="line">Greeting: Hello world</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>Congratulations! You’ve just run a client-server application with gRPC.</p>
<h3 id="Update-a-gRPC-service"><a href="#Update-a-gRPC-service" class="headerlink" title="Update a gRPC service"></a>Update a gRPC service</h3><p>In this section you’ll update the application with an extra server method. The gRPC service is defined using <a href="https://developers.google.com/protocol-buffers">protocol buffers</a>. To learn more about how to define a service in a <code>.proto</code> file see <a href="https://grpc.io/docs/tutorials/basic/go">gRPC Basics: Go</a>. For now, all you need to know is that both the server and the client stub have a <code>SayHello()</code> RPC method that takes a <code>HelloRequest</code> parameter from the client and returns a <code>HelloReply</code> from the server, and that the method is defined like this:</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The greeting service definition.</span></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">Greeter</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Sends a greeting</span></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> SayHello (HelloRequest) <span class="keyword">returns</span> (HelloReply) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The request message containing the user&#x27;s name.</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">HelloRequest</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> name = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The response message containing the greetings</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">HelloReply</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> <span class="class"><span class="keyword">message</span> = 1;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>

<p>Open <code>helloworld/helloworld.proto</code> and add a new <code>SayHelloAgain()</code> method, with the same request and response types:</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The greeting service definition.</span></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">Greeter</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Sends a greeting</span></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> SayHello (HelloRequest) <span class="keyword">returns</span> (HelloReply) </span>&#123;&#125;</span><br><span class="line">  <span class="comment">// Sends another greeting</span></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> SayHelloAgain (HelloRequest) <span class="keyword">returns</span> (HelloReply) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The request message containing the user&#x27;s name.</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">HelloRequest</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> name = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The response message containing the greetings</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">HelloReply</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> <span class="class"><span class="keyword">message</span> = 1;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>

<p>Remember to save the file!</p>
<h3 id="Regenerate-gRPC-code"><a href="#Regenerate-gRPC-code" class="headerlink" title="Regenerate gRPC code"></a>Regenerate gRPC code</h3><p>Before you can use the new service method, you need to recompile the updated <code>.proto</code> file.</p>
<p>Note</p>
<p>We are in the process of transitioning to a <a href="https://github.com/grpc/grpc-go/pull/3453">new Go protoc plugin</a>. Until the transition is complete, you need to install <code>grpc-go/cmd/protoc-gen-go-grpc</code> manually (using the command shown below) before regenerating <code>.pb.go</code> files. To track progress on this issue, see <a href="https://github.com/grpc/grpc.io/issues/298">Update Go quick start #298</a>.</p>
<p>While still in the <code>examples/helloworld</code> directory, run the following commands:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ ( <span class="built_in">cd</span> ../../cmd/protoc-gen-go-grpc &amp;&amp; go install . )</span><br><span class="line">$ protoc --go_out=. --go-grpc_out=. \</span><br><span class="line">    --go_opt=paths=source_relative \</span><br><span class="line">    --go-grpc_opt=paths=source_relative \</span><br><span class="line">    helloworld/helloworld.proto</span><br></pre></td></tr></table></figure>

<p>This will regenerate the <code>helloworld/helloworld.pb.go</code> and <code>helloworld/helloworld_grpc.pb.go</code> files, which contain:</p>
<ul>
<li>Code for populating, serializing, and retrieving <code>HelloRequest</code> and <code>HelloReply</code> message types.</li>
<li>Generated client and server code.</li>
</ul>
<h3 id="Update-and-run-the-application"><a href="#Update-and-run-the-application" class="headerlink" title="Update and run the application"></a>Update and run the application</h3><p>You have regenerated server and client code, but you still need to implement and call the new method in the human-written parts of the example application.</p>
<h4 id="Update-the-server"><a href="#Update-the-server" class="headerlink" title="Update the server"></a>Update the server</h4><p>Open <code>greeter_server/main.go</code> and add the following function to it:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span> <span class="title">SayHelloAgain</span><span class="params">(ctx context.Context, in *pb.HelloRequest)</span> <span class="params">(*pb.HelloReply, error)</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;pb.HelloReply&#123;Message: <span class="string">&quot;Hello again &quot;</span> + in.GetName()&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Update-the-client"><a href="#Update-the-client" class="headerlink" title="Update the client"></a>Update the client</h4><p>Open <code>greeter_client/main.go</code> to add the following code to the end of the <code>main()</code> function body:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r, err = c.SayHelloAgain(ctx, &amp;pb.HelloRequest&#123;Name: name&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;could not greet: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">&quot;Greeting: %s&quot;</span>, r.GetMessage())</span><br></pre></td></tr></table></figure>

<p>Remember to save your changes.</p>
<h4 id="Run"><a href="#Run" class="headerlink" title="Run!"></a>Run!</h4><p>Run the client and server like you did before. Execute the following commands from the <code>examples/helloworld</code> directory:</p>
<ol>
<li><p>Run the server:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ go run greeter_server/main.go</span><br></pre></td></tr></table></figure>
</li>
<li><p>From another terminal, run the client. This time, add a name as a command-line argument:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ go run greeter_client/main.go Alice</span><br></pre></td></tr></table></figure>

<p>You’ll see the following output:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Greeting: Hello Alice</span><br><span class="line">Greeting: Hello again Alice</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>连接mysql的脚本</title>
    <url>/2020/08/07/%E8%BF%9E%E6%8E%A5mysql%E7%9A%84%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h3 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h3><p><code>mysql的服务器地址： 127.0.0.1  mysql的端口: 3306 mysql的用户: root mysq的密码: abcdefg</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">mysql -h 127.0.0.1 -P 3306 -u root  -pabcdefg databaseName;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 语言学习笔记 Gin框架(三)</title>
    <url>/2020/08/06/Go-%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Gin%E6%A1%86%E6%9E%B6-%E4%B8%89/</url>
    <content><![CDATA[<h1 id="gin与-gorm的集成"><a href="#gin与-gorm的集成" class="headerlink" title="gin与 gorm的集成"></a>gin与 gorm的集成</h1><p>1.什么是Gorm<br>go语言编写的orm框架<br>特点：<br>1)全功能ORM<br>2)关联（包含一个，包含多个，属于，多对多）<br>3)Callbacks（创建/保存/更新/删除/查找前后回调）<br>4)预加载<br>5)事务<br>6)复合主键<br>7)SQL Builder（执行原生sql）<br>8)自动迁移<br>9)日志</p>
<p>2.安装</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> get -u github.com/jinzhu/gorm</span><br></pre></td></tr></table></figure>

<p>3.数据库连接<br>1)引入相应驱动</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="string">&quot;github.com/jinzhu/gorm/dialects/mysql&quot;</span></span><br><span class="line"><span class="comment">// import _ &quot;github.com/jinzhu/gorm/dialects/postgres&quot;</span></span><br><span class="line"><span class="comment">// import _ &quot;github.com/jinzhu/gorm/dialects/sqlite&quot;</span></span><br><span class="line"><span class="comment">// import _ &quot;github.com/jinzhu/gorm/dialects/mssql&quot;</span></span><br></pre></td></tr></table></figure>

<p>2)连接示例<br>Mysql</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;github.com/jinzhu/gorm&quot;</span></span><br><span class="line">    _ <span class="string">&quot;github.com/jinzhu/gorm/dialects/mysql&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  db, err := gorm.Open(<span class="string">&quot;mysql&quot;</span>, <span class="string">&quot;user:password@/dbname?charset=utf8&amp;parseTime=True&amp;loc=Local&quot;</span>)</span><br><span class="line">  <span class="keyword">defer</span> db.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PostgreSQL</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;github.com/jinzhu/gorm&quot;</span></span><br><span class="line">    _ <span class="string">&quot;github.com/jinzhu/gorm/dialects/postgres&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  db, err := gorm.Open(<span class="string">&quot;postgres&quot;</span>, <span class="string">&quot;host=myhost user=gorm dbname=gorm sslmode=disable password=mypassword&quot;</span>)</span><br><span class="line">  <span class="keyword">defer</span> db.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Sqlite3</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;github.com/jinzhu/gorm&quot;</span></span><br><span class="line">    _ <span class="string">&quot;github.com/jinzhu/gorm/dialects/sqlite&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  db, err := gorm.Open(<span class="string">&quot;sqlite3&quot;</span>, <span class="string">&quot;/tmp/gorm.db&quot;</span>)</span><br><span class="line">  <span class="keyword">defer</span> db.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.自动迁移<br>创建表，缺少的列和索引，不会改变现有列的类型或删除列</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/jinzhu/gorm&quot;</span></span><br><span class="line">    _ <span class="string">&quot;github.com/jinzhu/gorm/dialects/postgres&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    host = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">    port = <span class="number">5432</span></span><br><span class="line">    user = <span class="string">&quot;postgres&quot;</span></span><br><span class="line">    password = <span class="string">&quot;1&quot;</span></span><br><span class="line">    dbname = <span class="string">&quot;dm-identity&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    gorm.Model</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">int</span></span><br><span class="line">    Birthday time.Time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    psqlInfo := fmt.Sprintf(<span class="string">&quot;host=%s port=%d user=%s password=%s dbname=%s sslmode=disable&quot;</span>, host, port, user, password, dbname)</span><br><span class="line"></span><br><span class="line">    db, err := gorm.Open(<span class="string">&quot;postgres&quot;</span>, psqlInfo)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;connected successfully&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> db.Close()</span><br><span class="line"></span><br><span class="line">    db.AutoMigrate(&amp;User&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>db.AutoMigrate(&amp;User{})会创建/更新”users”表。</p>
<p>5.表结构操作<br>1)检验表是否存在</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result <span class="keyword">bool</span></span><br><span class="line">result = db.HasTable(&amp;User&#123;&#125;)</span><br><span class="line">fmt.Println(result)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>2)创建表</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.CreateTable(&amp;User&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>3)删除表</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除模型User对应的表</span></span><br><span class="line">db.DropTable(&amp;User&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除users表</span></span><br><span class="line">db.DropTable(<span class="string">&quot;users&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>4)修改列</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.Model(&amp;User&#123;&#125;).ModifyColumn(<span class="string">&quot;description&quot;</span>, <span class="string">&quot;text&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>go5)删除列</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.model(&amp;User&#123;&#125;).DropColumn(<span class="string">&quot;description&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>6)添加外键</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.Model(&amp;User&#123;&#125;).AddForeignKey(<span class="string">&quot;city_id&quot;</span>,<span class="string">&quot;cities(id)&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>7)添加索引</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.Model(&amp;User&#123;&#125;).AddIndex(<span class="string">&quot;idx_user_name&quot;</span>, <span class="string">&quot;name&quot;</span>)</span><br><span class="line"></span><br><span class="line">db.Model(&amp;User&#123;]).AddUniqueIndex(<span class="string">&quot;idx_user_name&quot;</span>, <span class="string">&quot;name&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>8)删除索引</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.Model(&amp;User&#123;&#125;).RemoveIndex(<span class="string">&quot;idx_user_name&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>6.模型Model定义<br>1)gorm.Model结构体</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Model <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID        <span class="keyword">uint</span> <span class="string">`gorm:&quot;primary_key&quot;`</span></span><br><span class="line">    CreatedAt time.Time</span><br><span class="line">    UpdatedAt time.Time</span><br><span class="line">    DeletedAt *time.Time <span class="string">`sql:&quot;index&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2)定义Model结构体</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认表名是 Model名称的小写+复数</span></span><br><span class="line"><span class="keyword">type</span> Profile <span class="keyword">struct</span> &#123;</span><br><span class="line">    gorm.Model</span><br><span class="line">    Refer <span class="keyword">int</span></span><br><span class="line">    Name  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Name <span class="keyword">string</span>  <span class="string">`gorm:&quot;size:255&quot;`</span> <span class="comment">//string默认长度255,size重设长度</span></span><br><span class="line">  Age <span class="keyword">int</span> <span class="string">`gorm:&quot;column:my_age&quot;`</span> <span class="comment">//设置列名为my_age</span></span><br><span class="line">  Num <span class="keyword">int</span>  <span class="string">`gorm:&quot;AUTO_INCREMENT&quot;`</span> <span class="comment">//自增</span></span><br><span class="line">  IgnoreMe <span class="keyword">int</span> <span class="string">`gorm:&quot;-&quot;`</span> <span class="comment">// 忽略字段</span></span><br><span class="line">  Email <span class="keyword">string</span> <span class="string">`gorm:&quot;type:varchar(100);unique_index&quot;//type设置sql类型，unique_index为该列设置唯一索引`</span></span><br><span class="line">  Address <span class="keyword">string</span> <span class="string">`gorm:&quot;not null;unique&quot;`</span> <span class="comment">//非空</span></span><br><span class="line">  no <span class="keyword">string</span> <span class="string">`gorm:&quot;index:idx_no&quot;`</span> <span class="comment">// 创建索引并命名，如果有其他同名索引，则创建组合索引</span></span><br><span class="line">  code <span class="keyword">string</span> <span class="string">`gorm:&quot;index:idx_no&quot;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">  Profile Profile <span class="string">`gorm:&quot;ForeignKey:ProfileID;AssociationForeignKey:Refer&quot;`</span> <span class="comment">//设置外键</span></span><br><span class="line">  ProfileID <span class="keyword">int</span></span><br><span class="line">  remark <span class="keyword">string</span> <span class="string">`gorm:&quot;default:&#x27;test&#x27;&quot;`</span> <span class="comment">//默认值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    psqlInfo := fmt.Sprintf(<span class="string">&quot;host=%s port=%d user=%s password=%s dbname=%s sslmode=disable&quot;</span>, host, port, user, password, dbname)</span><br><span class="line"></span><br><span class="line">    db, err := gorm.Open(<span class="string">&quot;postgres&quot;</span>, psqlInfo)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> db.Close()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 全局禁用表名复数</span></span><br><span class="line">    db.SingularTable(<span class="literal">true</span>)</span><br><span class="line">    </span><br><span class="line">    db.AutoMigrate(&amp;User&#123;&#125;, &amp;Profile&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3)自定义表名</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义表名(方法一)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(User)</span> <span class="title">TableName</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;my_user&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 自定义表名(方法二)</span></span><br><span class="line">db.Table(<span class="string">&quot;my_user&quot;</span>).CreateTable(&amp;User&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>8.创建</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">user := User&#123;Name: <span class="string">&quot;Jinzhu&quot;</span>, Age: <span class="number">18</span>, Birthday: time.Now()&#125;</span><br><span class="line"></span><br><span class="line">db.NewRecord(user) <span class="comment">// =&gt; 主键为空返回`true`</span></span><br><span class="line"></span><br><span class="line">db.Create(&amp;user)</span><br><span class="line"></span><br><span class="line">db.NewRecord(user) <span class="comment">// =&gt; 创建`user`后返回`false`</span></span><br></pre></td></tr></table></figure>

<p>9.查询</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取第一条记录，按主键排序</span></span><br><span class="line">db.First(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users ORDER BY id LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取最后一条记录，按主键排序</span></span><br><span class="line">db.Last(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users ORDER BY id DESC LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有记录</span></span><br><span class="line">db.Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用主键获取记录</span></span><br><span class="line">db.First(&amp;user, <span class="number">10</span>)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE id = 10;</span></span><br></pre></td></tr></table></figure>

<p>1)Where查询条件(简单SQL)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取第一个匹配记录</span></span><br><span class="line">db.Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).First(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27; limit 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有匹配记录</span></span><br><span class="line">db.Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27;;</span></span><br><span class="line"></span><br><span class="line">db.Where(<span class="string">&quot;name &lt;&gt; ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).Find(&amp;users)</span><br><span class="line"></span><br><span class="line"><span class="comment">// IN</span></span><br><span class="line">db.Where(<span class="string">&quot;name in (?)&quot;</span>, []<span class="keyword">string</span>&#123;<span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;jinzhu 2&quot;</span>&#125;).Find(&amp;users)</span><br><span class="line"></span><br><span class="line"><span class="comment">// LIKE</span></span><br><span class="line">db.Where(<span class="string">&quot;name LIKE ?&quot;</span>, <span class="string">&quot;%jin%&quot;</span>).Find(&amp;users)</span><br><span class="line"></span><br><span class="line"><span class="comment">// AND</span></span><br><span class="line">db.Where(<span class="string">&quot;name = ? AND age &gt;= ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;22&quot;</span>).Find(&amp;users)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Time</span></span><br><span class="line">db.Where(<span class="string">&quot;updated_at &gt; ?&quot;</span>, lastWeek).Find(&amp;users)</span><br><span class="line"></span><br><span class="line">db.Where(<span class="string">&quot;created_at BETWEEN ? AND ?&quot;</span>, lastWeek, today).Find(&amp;users)</span><br></pre></td></tr></table></figure>

<p>2)Where查询条件（Struct &amp; Map）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Struct</span></span><br><span class="line">db.Where(&amp;User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>, Age: <span class="number">20</span>&#125;).First(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name = &quot;jinzhu&quot; AND age = 20 LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Map</span></span><br><span class="line">db.Where(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">20</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name = &quot;jinzhu&quot; AND age = 20;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主键的Slice</span></span><br><span class="line">db.Where([]<span class="keyword">int64</span>&#123;<span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE id IN (20, 21, 22);</span></span><br></pre></td></tr></table></figure>

<p>3)Not条件</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.Not(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).First(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name &lt;&gt; &quot;jinzhu&quot; LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Not In</span></span><br><span class="line">db.Not(<span class="string">&quot;name&quot;</span>, []<span class="keyword">string</span>&#123;<span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;jinzhu 2&quot;</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name NOT IN (&quot;jinzhu&quot;, &quot;jinzhu 2&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Not In slice of primary keys</span></span><br><span class="line">db.Not([]<span class="keyword">int64</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;).First(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE id NOT IN (1,2,3);</span></span><br><span class="line"></span><br><span class="line">db.Not([]<span class="keyword">int64</span>&#123;&#125;).First(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Plain SQL</span></span><br><span class="line">db.Not(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).First(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE NOT(name = &quot;jinzhu&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Struct</span></span><br><span class="line">db.Not(User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>&#125;).First(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name &lt;&gt; &quot;jinzhu&quot;;</span></span><br></pre></td></tr></table></figure>

<p>4)带内联条件的查询</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按主键获取</span></span><br><span class="line">db.First(&amp;user, <span class="number">23</span>)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE id = 23 LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单SQL</span></span><br><span class="line">db.Find(&amp;user, <span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name = &quot;jinzhu&quot;;</span></span><br><span class="line"></span><br><span class="line">db.Find(&amp;users, <span class="string">&quot;name &lt;&gt; ? AND age &gt; ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>, <span class="number">20</span>)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name &lt;&gt; &quot;jinzhu&quot; AND age &gt; 20;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Struct</span></span><br><span class="line">db.Find(&amp;users, User&#123;Age: <span class="number">20</span>&#125;)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE age = 20;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Map</span></span><br><span class="line">db.Find(&amp;users, <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;age&quot;</span>: <span class="number">20</span>&#125;)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE age = 20;</span></span><br></pre></td></tr></table></figure>

<p>5)Or条件查询</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.Where(<span class="string">&quot;role = ?&quot;</span>, <span class="string">&quot;admin&quot;</span>).Or(<span class="string">&quot;role = ?&quot;</span>, <span class="string">&quot;super_admin&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE role = &#x27;admin&#x27; OR role = &#x27;super_admin&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Struct</span></span><br><span class="line">db.Where(<span class="string">&quot;name = &#x27;jinzhu&#x27;&quot;</span>).Or(User&#123;Name: <span class="string">&quot;jinzhu 2&quot;</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27; OR name = &#x27;jinzhu 2&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Map</span></span><br><span class="line">db.Where(<span class="string">&quot;name = &#x27;jinzhu&#x27;&quot;</span>).Or(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;jinzhu 2&quot;</span>&#125;).Find(&amp;users)</span><br></pre></td></tr></table></figure>

<p>6)查询链</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.Where(<span class="string">&quot;name &lt;&gt; ?&quot;</span>,<span class="string">&quot;jinzhu&quot;</span>).Where(<span class="string">&quot;age &gt;= ? and role &lt;&gt; ?&quot;</span>,<span class="number">20</span>,<span class="string">&quot;admin&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name &lt;&gt; &#x27;jinzhu&#x27; AND age &gt;= 20 AND role &lt;&gt; &#x27;admin&#x27;;</span></span><br><span class="line"></span><br><span class="line">db.Where(<span class="string">&quot;role = ?&quot;</span>, <span class="string">&quot;admin&quot;</span>).Or(<span class="string">&quot;role = ?&quot;</span>, <span class="string">&quot;super_admin&quot;</span>).Not(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).Find(&amp;users)</span><br></pre></td></tr></table></figure>

<p>7)FirstOrInit<br>获取第一个匹配的记录，若没有，则根据条件初始化一个新的记录</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Unfound</span></span><br><span class="line">db.FirstOrInit(&amp;user, User&#123;Name: <span class="string">&quot;non_existing&quot;</span>&#125;)</span><br><span class="line"><span class="comment">//// user -&gt; User&#123;Name: &quot;non_existing&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Found</span></span><br><span class="line">db.Where(User&#123;Name: <span class="string">&quot;Jinzhu&quot;</span>&#125;).FirstOrInit(&amp;user)</span><br><span class="line"><span class="comment">//// user -&gt; User&#123;Id: 111, Name: &quot;Jinzhu&quot;, Age: 20&#125;</span></span><br><span class="line">db.FirstOrInit(&amp;user, <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;jinzhu&quot;</span>&#125;)</span><br><span class="line"><span class="comment">//// user -&gt; User&#123;Id: 111, Name: &quot;Jinzhu&quot;, Age: 20&#125;</span></span><br></pre></td></tr></table></figure>

<p>8)Attrs<br>如果未找到记录，则使用参数初始化结构</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Unfound</span></span><br><span class="line">db.Where(User&#123;Name: <span class="string">&quot;non_existing&quot;</span>&#125;).Attrs(User&#123;Age: <span class="number">20</span>&#125;).FirstOrInit(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM USERS WHERE name = &#x27;non_existing&#x27;;</span></span><br><span class="line"><span class="comment">//// user -&gt; User&#123;Name: &quot;non_existing&quot;, Age: 20&#125;</span></span><br><span class="line"></span><br><span class="line">db.Where(User&#123;Name: <span class="string">&quot;non_existing&quot;</span>&#125;).Attrs(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>).FirstOrInit(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM USERS WHERE name = &#x27;non_existing&#x27;;</span></span><br><span class="line"><span class="comment">//// user -&gt; User&#123;Name: &quot;non_existing&quot;, Age: 20&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Found</span></span><br><span class="line">db.Where(User&#123;Name: <span class="string">&quot;Jinzhu&quot;</span>&#125;).Attrs(User&#123;Age: <span class="number">30</span>&#125;).FirstOrInit(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM USERS WHERE name = jinzhu&#x27;;</span></span><br><span class="line"><span class="comment">//// user -&gt; User&#123;Id: 111, Name: &quot;Jinzhu&quot;, Age: 20&#125;</span></span><br></pre></td></tr></table></figure>

<p>9)Assign<br>将参数分配给结果，不管是否找到</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Unfound</span></span><br><span class="line">db.Where(User&#123;Name: <span class="string">&quot;non_existing&quot;</span>&#125;).Assign(User&#123;Age: <span class="number">20</span>&#125;).FirstOrInit(&amp;user)</span><br><span class="line"><span class="comment">//// user -&gt; User&#123;Name: &quot;non_existing&quot;, Age: 20&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Found</span></span><br><span class="line">db.Where(User&#123;Name: <span class="string">&quot;Jinzhu&quot;</span>&#125;).Assign(User&#123;Age: <span class="number">30</span>&#125;).FirstOrInit(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM USERS WHERE name = jinzhu&#x27;;</span></span><br><span class="line"><span class="comment">//// user -&gt; User&#123;Id: 111, Name: &quot;Jinzhu&quot;, Age: 30&#125;</span></span><br></pre></td></tr></table></figure>

<p>10)FirstOrCreate<br>获取第一个匹配的结果，或创建一个具有给定条件的新纪录</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Unfound</span></span><br><span class="line">db.FirstOrCreate(&amp;user, User&#123;Name: <span class="string">&quot;non_existing&quot;</span>&#125;)</span><br><span class="line"><span class="comment">//// INSERT INTO &quot;users&quot; (name) VALUES (&quot;non_existing&quot;);</span></span><br><span class="line"><span class="comment">//// user -&gt; User&#123;Id: 112, Name: &quot;non_existing&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Found</span></span><br><span class="line">db.Where(User&#123;Name: <span class="string">&quot;Jinzhu&quot;</span>&#125;).FirstOrCreate(&amp;user)</span><br><span class="line"><span class="comment">//// user -&gt; User&#123;Id: 111, Name: &quot;Jinzhu&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<p>11)Select<br>从数据库检索字段</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.Select(<span class="string">&quot;name, age&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT name, age FROM users;</span></span><br><span class="line"></span><br><span class="line">db.Select([]<span class="keyword">string</span>&#123;<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT name, age FROM users;</span></span><br><span class="line"></span><br><span class="line">db.Table(<span class="string">&quot;users&quot;</span>).Select(<span class="string">&quot;COALESCE(age,?)&quot;</span>, <span class="number">42</span>).Rows()</span><br><span class="line"><span class="comment">//// SELECT COALESCE(age,&#x27;42&#x27;) FROM users;</span></span><br></pre></td></tr></table></figure>

<p>12)Order<br>从数据库检索记录时指定顺序</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.Order(<span class="string">&quot;age desc, name&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users ORDER BY age desc, name;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Multiple orders</span></span><br><span class="line">db.Order(<span class="string">&quot;age desc&quot;</span>).Order(<span class="string">&quot;name&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users ORDER BY age desc, name;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ReOrder</span></span><br><span class="line">db.Order(<span class="string">&quot;age desc&quot;</span>).Find(&amp;users1).Order(<span class="string">&quot;age&quot;</span>, <span class="literal">true</span>).Find(&amp;users2)</span><br><span class="line"><span class="comment">//// SELECT * FROM users ORDER BY age desc; (users1)</span></span><br><span class="line"><span class="comment">//// SELECT * FROM users ORDER BY age; (users2)</span></span><br></pre></td></tr></table></figure>

<p>13)Limit<br>指定要检索的记录数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.Limit(<span class="number">3</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users LIMIT 3;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Cancel limit condition with -1</span></span><br><span class="line">db.Limit(<span class="number">10</span>).Find(&amp;users1).Limit(<span class="number">-1</span>).Find(&amp;users2)</span><br><span class="line"><span class="comment">//// SELECT * FROM users LIMIT 10; (users1)</span></span><br><span class="line"><span class="comment">//// SELECT * FROM users; (users2)</span></span><br></pre></td></tr></table></figure>

<p>14)Offset<br>指定在开始返回记录之前要跳过的记录数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.Offset(<span class="number">3</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users OFFSET 3;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Cancel offset condition with -1</span></span><br><span class="line">db.Offset(<span class="number">10</span>).Find(&amp;users1).Offset(<span class="number">-1</span>).Find(&amp;users2)</span><br><span class="line"><span class="comment">//// SELECT * FROM users OFFSET 10; (users1)</span></span><br><span class="line"><span class="comment">//// SELECT * FROM users; (users2)</span></span><br></pre></td></tr></table></figure>

<p>15)Count<br>获取模型的记录数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).Or(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu 2&quot;</span>).Find(&amp;users).Count(&amp;count)</span><br><span class="line"><span class="comment">//// SELECT * from USERS WHERE name = &#x27;jinzhu&#x27; OR name = &#x27;jinzhu 2&#x27;; (users)</span></span><br><span class="line"><span class="comment">//// SELECT count(*) FROM users WHERE name = &#x27;jinzhu&#x27; OR name = &#x27;jinzhu 2&#x27;; (count)</span></span><br><span class="line"></span><br><span class="line">db.Model(&amp;User&#123;&#125;).Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).Count(&amp;count)</span><br><span class="line"><span class="comment">//// SELECT count(*) FROM users WHERE name = &#x27;jinzhu&#x27;; (count)</span></span><br><span class="line"></span><br><span class="line">db.Table(<span class="string">&quot;deleted_users&quot;</span>).Count(&amp;count)</span><br><span class="line"><span class="comment">//// SELECT count(*) FROM deleted_users;</span></span><br></pre></td></tr></table></figure>

<p>16)Group &amp; Having</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">rows, err := db.Table(<span class="string">&quot;orders&quot;</span>).Select(<span class="string">&quot;date(created_at) as date, sum(amount) as total&quot;</span>).Group(<span class="string">&quot;date(created_at)&quot;</span>).Rows()</span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rows, err := db.Table(<span class="string">&quot;orders&quot;</span>).Select(<span class="string">&quot;date(created_at) as date, sum(amount) as total&quot;</span>).Group(<span class="string">&quot;date(created_at)&quot;</span>).Having(<span class="string">&quot;sum(amount) &gt; ?&quot;</span>, <span class="number">100</span>).Rows()</span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> &#123;</span><br><span class="line">    Date  time.Time</span><br><span class="line">    Total <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line">db.Table(<span class="string">&quot;orders&quot;</span>).Select(<span class="string">&quot;date(created_at) as date, sum(amount) as total&quot;</span>).Group(<span class="string">&quot;date(created_at)&quot;</span>).Having(<span class="string">&quot;sum(amount) &gt; ?&quot;</span>, <span class="number">100</span>).Scan(&amp;results)</span><br></pre></td></tr></table></figure>

<p>17)Join<br>指定连接条件</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">rows, err := db.Table(<span class="string">&quot;users&quot;</span>).Select(<span class="string">&quot;users.name, emails.email&quot;</span>).Joins(<span class="string">&quot;left join emails on emails.user_id = users.id&quot;</span>).Rows()</span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db.Table(<span class="string">&quot;users&quot;</span>).Select(<span class="string">&quot;users.name, emails.email&quot;</span>).Joins(<span class="string">&quot;left join emails on emails.user_id = users.id&quot;</span>).Scan(&amp;results)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个连接与参数</span></span><br><span class="line">db.Joins(<span class="string">&quot;JOIN emails ON emails.user_id = users.id AND emails.email = ?&quot;</span>, <span class="string">&quot;jinzhu@example.org&quot;</span>).Joins(<span class="string">&quot;JOIN credit_cards ON credit_cards.user_id = users.id&quot;</span>).Where(<span class="string">&quot;credit_cards.number = ?&quot;</span>, <span class="string">&quot;411111111111&quot;</span>).Find(&amp;user)</span><br></pre></td></tr></table></figure>

<p>18)Pluck<br>查询单列，返回数组</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ages []<span class="keyword">int64</span></span><br><span class="line">db.Find(&amp;users).Pluck(<span class="string">&quot;age&quot;</span>, &amp;ages)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> names []<span class="keyword">string</span></span><br><span class="line">db.Model(&amp;User&#123;&#125;).Pluck(<span class="string">&quot;name&quot;</span>, &amp;names)</span><br><span class="line"></span><br><span class="line">db.Table(<span class="string">&quot;deleted_users&quot;</span>).Pluck(<span class="string">&quot;name&quot;</span>, &amp;names)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要返回多个列，做这样：</span></span><br><span class="line">db.Select(<span class="string">&quot;name, age&quot;</span>).Find(&amp;users)</span><br></pre></td></tr></table></figure>

<p>19)Scan<br>将结果扫描到另一个结构中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result Result</span><br><span class="line">db.Table(<span class="string">&quot;users&quot;</span>).Select(<span class="string">&quot;name, age&quot;</span>).Where(<span class="string">&quot;name = ?&quot;</span>, <span class="number">3</span>).Scan(&amp;result)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Raw SQL</span></span><br><span class="line">db.Raw(<span class="string">&quot;SELECT name, age FROM users WHERE name = ?&quot;</span>, <span class="number">3</span>).Scan(&amp;result)</span><br></pre></td></tr></table></figure>

<p>20)预加载<br>数据库编译一次，然后保存，提高执行效率</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.Preload(<span class="string">&quot;Orders&quot;</span>).Find(&amp;users)</span><br></pre></td></tr></table></figure>

<p>10.更新<br>1)更新全部字段 Save</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.First(&amp;user)</span><br><span class="line"></span><br><span class="line">user.Name = <span class="string">&quot;jinzhu 2&quot;</span></span><br><span class="line">user.Age = <span class="number">100</span></span><br><span class="line">db.Save(&amp;user)</span><br><span class="line"></span><br><span class="line"><span class="comment">//// UPDATE users SET name=&#x27;jinzhu 2&#x27;, age=100, birthday=&#x27;2016-01-01&#x27;, updated_at = &#x27;2013-11-17 21:34:10&#x27; WHERE id=111;</span></span><br></pre></td></tr></table></figure>

<p>2)更新更改字段 Update Updates</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 更新单个属性（如果更改）</span></span><br><span class="line">db.Model(&amp;user).Update(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="comment">//// UPDATE users SET name=&#x27;hello&#x27;, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用组合条件更新单个属性</span></span><br><span class="line">db.Model(&amp;user).Where(<span class="string">&quot;active = ?&quot;</span>, <span class="literal">true</span>).Update(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="comment">//// UPDATE users SET name=&#x27;hello&#x27;, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111 AND active=true;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用`map`更新多个属性，只会更新这些更改的字段</span></span><br><span class="line">db.Model(&amp;user).Updates(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>, <span class="string">&quot;actived&quot;</span>: <span class="literal">false</span>&#125;)</span><br><span class="line"><span class="comment">//// UPDATE users SET name=&#x27;hello&#x27;, age=18, actived=false, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用`struct`更新多个属性，只会更新这些更改的和非空白字段</span></span><br><span class="line">db.Model(&amp;user).Updates(User&#123;Name: <span class="string">&quot;hello&quot;</span>, Age: <span class="number">18</span>&#125;)</span><br><span class="line"><span class="comment">//// UPDATE users SET name=&#x27;hello&#x27;, age=18, updated_at = &#x27;2013-11-17 21:34:10&#x27; WHERE id = 111;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 警告:当使用struct更新时，FORM将仅更新具有非空值的字段</span></span><br><span class="line"><span class="comment">// 对于下面的更新，什么都不会更新为&quot;&quot;，0，false是其类型的空白值</span></span><br><span class="line">db.Model(&amp;user).Updates(User&#123;Name: <span class="string">&quot;&quot;</span>, Age: <span class="number">0</span>, Actived: <span class="literal">false</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>3)更新选择字段</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.Model(&amp;user).Select(<span class="string">&quot;name&quot;</span>).Updates(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>, <span class="string">&quot;actived&quot;</span>: <span class="literal">false</span>&#125;)</span><br><span class="line"><span class="comment">//// UPDATE users SET name=&#x27;hello&#x27;, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111;</span></span><br><span class="line"></span><br><span class="line">db.Model(&amp;user).Omit(<span class="string">&quot;name&quot;</span>).Updates(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>, <span class="string">&quot;actived&quot;</span>: <span class="literal">false</span>&#125;)</span><br><span class="line"><span class="comment">//// UPDATE users SET age=18, actived=false, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111;</span></span><br></pre></td></tr></table></figure>

<p>4)使用sql表达式更新</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">DB.Model(&amp;product).Update(<span class="string">&quot;price&quot;</span>, gorm.Expr(<span class="string">&quot;price * ? + ?&quot;</span>, <span class="number">2</span>, <span class="number">100</span>))</span><br><span class="line"><span class="comment">//// UPDATE &quot;products&quot; SET &quot;price&quot; = price * &#x27;2&#x27; + &#x27;100&#x27;, &quot;updated_at&quot; = &#x27;2013-11-17 21:34:10&#x27; WHERE &quot;id&quot; = &#x27;2&#x27;;</span></span><br><span class="line"></span><br><span class="line">DB.Model(&amp;product).Updates(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;price&quot;</span>: gorm.Expr(<span class="string">&quot;price * ? + ?&quot;</span>, <span class="number">2</span>, <span class="number">100</span>)&#125;)</span><br><span class="line"><span class="comment">//// UPDATE &quot;products&quot; SET &quot;price&quot; = price * &#x27;2&#x27; + &#x27;100&#x27;, &quot;updated_at&quot; = &#x27;2013-11-17 21:34:10&#x27; WHERE &quot;id&quot; = &#x27;2&#x27;;</span></span><br><span class="line"></span><br><span class="line">DB.Model(&amp;product).UpdateColumn(<span class="string">&quot;quantity&quot;</span>, gorm.Expr(<span class="string">&quot;quantity - ?&quot;</span>, <span class="number">1</span>))</span><br><span class="line"><span class="comment">//// UPDATE &quot;products&quot; SET &quot;quantity&quot; = quantity - 1 WHERE &quot;id&quot; = &#x27;2&#x27;;</span></span><br><span class="line"></span><br><span class="line">DB.Model(&amp;product).Where(<span class="string">&quot;quantity &gt; 1&quot;</span>).UpdateColumn(<span class="string">&quot;quantity&quot;</span>, gorm.Expr(<span class="string">&quot;quantity - ?&quot;</span>, <span class="number">1</span>))</span><br><span class="line"><span class="comment">//// UPDATE &quot;products&quot; SET &quot;quantity&quot; = quantity - 1 WHERE &quot;id&quot; = &#x27;2&#x27; AND quantity &gt; 1;</span></span><br></pre></td></tr></table></figure>

<p>11.删除<br>1)删除</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除存在的记录</span></span><br><span class="line">db.Delete(&amp;email)</span><br><span class="line"><span class="comment">//// DELETE from emails where id=10;</span></span><br></pre></td></tr></table></figure>

<p>2)批量删除</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.Where(<span class="string">&quot;email LIKE ?&quot;</span>, <span class="string">&quot;%jinzhu%&quot;</span>).Delete(Email&#123;&#125;)</span><br><span class="line"><span class="comment">//// DELETE from emails where email LIKE &quot;%jinhu%&quot;;</span></span><br><span class="line"></span><br><span class="line">db.Delete(Email&#123;&#125;, <span class="string">&quot;email LIKE ?&quot;</span>, <span class="string">&quot;%jinzhu%&quot;</span>)</span><br><span class="line"><span class="comment">//// DELETE from emails where email LIKE &quot;%jinhu%&quot;;</span></span><br></pre></td></tr></table></figure>

<p>3)软删除<br>如果模型有DeletedAt字段，删除时是软删除</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.Delete(&amp;user)</span><br><span class="line"><span class="comment">//// UPDATE users SET deleted_at=&quot;2013-10-29 10:23&quot; WHERE id = 111;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量删除</span></span><br><span class="line">db.Where(<span class="string">&quot;age = ?&quot;</span>, <span class="number">20</span>).Delete(&amp;User&#123;&#125;)</span><br><span class="line"><span class="comment">//// UPDATE users SET deleted_at=&quot;2013-10-29 10:23&quot; WHERE age = 20;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 软删除的记录将在查询时被忽略</span></span><br><span class="line">db.Where(<span class="string">&quot;age = 20&quot;</span>).Find(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE age = 20 AND deleted_at IS NULL;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Unscoped查找软删除的记录</span></span><br><span class="line">db.Unscoped().Where(<span class="string">&quot;age = 20&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE age = 20;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Unscoped永久删除记录</span></span><br><span class="line">db.Unscoped().Delete(&amp;order)</span><br><span class="line"><span class="comment">//// DELETE FROM orders WHERE id=10;</span></span><br></pre></td></tr></table></figure>

<p>12.事务</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateAnimals</span><span class="params">(db *gorm.DB)</span> <span class="title">err</span></span> &#123;</span><br><span class="line">  tx := db.Begin()</span><br><span class="line">  <span class="comment">// 注意，一旦你在一个事务中，使用tx作为数据库句柄</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> err := tx.Create(&amp;Animal&#123;Name: <span class="string">&quot;Giraffe&quot;</span>&#125;).Error; err != <span class="literal">nil</span> &#123;</span><br><span class="line">     tx.Rollback()</span><br><span class="line">     <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> err := tx.Create(&amp;Animal&#123;Name: <span class="string">&quot;Lion&quot;</span>&#125;).Error; err != <span class="literal">nil</span> &#123;</span><br><span class="line">     tx.Rollback()</span><br><span class="line">     <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tx.Commit()</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>13.SQL构建<br>1)执行原生sql</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.Exec(<span class="string">&quot;DROP TABLE users;&quot;</span>)</span><br><span class="line">db.Exec(<span class="string">&quot;UPDATE orders SET shipped_at=? WHERE id IN (?)&quot;</span>, time.Now, []<span class="keyword">int64</span>&#123;<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Scan</span></span><br><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result Result</span><br><span class="line">db.Raw(<span class="string">&quot;SELECT name, age FROM users WHERE name = ?&quot;</span>, <span class="number">3</span>).Scan(&amp;result)</span><br></pre></td></tr></table></figure>

<p>2)sql.Row &amp; sql.Rows</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">row := db.Table(<span class="string">&quot;users&quot;</span>).Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).Select(<span class="string">&quot;name, age&quot;</span>).Row() <span class="comment">// (*sql.Row)</span></span><br><span class="line">row.Scan(&amp;name, &amp;age)</span><br><span class="line"></span><br><span class="line">rows, err := db.Model(&amp;User&#123;&#125;).Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).Select(<span class="string">&quot;name, age, email&quot;</span>).Rows() <span class="comment">// (*sql.Rows, error)</span></span><br><span class="line"><span class="keyword">defer</span> rows.Close()</span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">    ...</span><br><span class="line">    rows.Scan(&amp;name, &amp;age, &amp;email)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Raw SQL</span></span><br><span class="line">rows, err := db.Raw(<span class="string">&quot;select name, age, email from users where name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).Rows() <span class="comment">// (*sql.Rows, error)</span></span><br><span class="line"><span class="keyword">defer</span> rows.Close()</span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">    ...</span><br><span class="line">    rows.Scan(&amp;name, &amp;age, &amp;email)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3)迭代中使用sql.Rows的Scan</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">rows, err := db.Model(&amp;User&#123;&#125;).Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).Select(<span class="string">&quot;name, age, email&quot;</span>).Rows() <span class="comment">// (*sql.Rows, error)</span></span><br><span class="line"><span class="keyword">defer</span> rows.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">  <span class="keyword">var</span> user User</span><br><span class="line">  db.ScanRows(rows, &amp;user)</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>14.日志</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 启用Logger，显示详细日志</span></span><br><span class="line">db.LogMode(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁用日志记录器，不显示任何日志</span></span><br><span class="line">db.LogMode(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调试单个操作，显示此操作的详细日志</span></span><br><span class="line">db.Debug().Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).First(&amp;User&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>15.架构<br>Gorm使用可链接的API, *gorm.DB是链的桥梁</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db, err := gorm.Open(<span class="string">&quot;postgres&quot;</span>, <span class="string">&quot;user=gorm dbname=gorm sslmode=disable&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新关系</span></span><br><span class="line">db = db.Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过滤更多</span></span><br><span class="line"><span class="keyword">if</span> SomeCondition &#123;</span><br><span class="line">    db = db.Where(<span class="string">&quot;age = ?&quot;</span>, <span class="number">20</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    db = db.Where(<span class="string">&quot;age = ?&quot;</span>, <span class="number">30</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> YetAnotherCondition &#123;</span><br><span class="line">    db = db.Where(<span class="string">&quot;active = ?&quot;</span>, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>go</category>
        <category>gin</category>
      </categories>
      <tags>
        <tag>gin</tag>
        <tag>gorm</tag>
      </tags>
  </entry>
  <entry>
    <title>redis</title>
    <url>/2020/10/15/redis/</url>
    <content><![CDATA[<h3 id="redis的数据结构和编码"><a href="#redis的数据结构和编码" class="headerlink" title="redis的数据结构和编码"></a>redis的数据结构和编码</h3><img src="/images/redis/image-20201015114538604.png" alt="image-20201015114538604" style="zoom:50%;" />

<p>可以使用OBJECT ENCODING</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SET msg <span class="string">&quot;hello wrold&quot;</span></span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING msg</span></span><br><span class="line">&quot;embstr&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SET story <span class="string">&quot;long long long long long long ago ...&quot;</span></span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING story</span></span><br><span class="line">&quot;raw&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SADD numbers 1 3 5</span></span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING numbers</span></span><br><span class="line">&quot;intset&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SADD numbers <span class="string">&quot;seven&quot;</span></span></span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING numbers</span></span><br><span class="line">&quot;hashtable&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>字符串类型的内部编码有3种：</p>
<ul>
<li>int：8个字节的长整型。</li>
<li>embstr：小于等于39个字节的字符串。</li>
<li>raw：大于39个字节的字符串。</li>
</ul>
<p>Redis会根据当前值的类型和长度决定使用哪种内部编码实现。</p>
<h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><p>哈希类型的内部编码有两种：</p>
<ul>
<li><p>ziplist（压缩列表）：</p>
<p>条件：</p>
<ol>
<li>当哈希类型元素个数小于hash-max-ziplist-entries配置（默认512个）</li>
<li>所有值都小于hash-max-ziplist-value配置（默认64字节）</li>
</ol>
</li>
<li><p>hashtable（哈希表）：当哈希类型无法满足ziplist的条件时使用hashtable</p>
</li>
</ul>
<p>Redis使用ziplist作为哈希的内部实现，ziplist使用更加紧凑的结构实现多个元素的连续存储，所以在节省内存方面比hashtable更加优秀。</p>
<p>使用hashtable作为哈希的内部实现，ziplist的读写效率会下降，而hashtable的读写时间复杂度为O（1）。</p>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p>列表类型的内部编码有两种。</p>
<ul>
<li>ziplist（压缩列表）：当列表的元素个数小于list-max-ziplist-entries配置（默认512个），同时列表中每个元素的值都小于list-max-ziplist-value配置时（默认64字节），Redis会选用ziplist来作为列表的内部实现来减少内存的使用。</li>
<li>linkedlist（链表）：当列表类型无法满足ziplist的条件时，Redis会使用linkedlist作为列表的内部实现。</li>
</ul>
<p>提示：</p>
<p>Redis3.2版本提供了quicklist内部编码，简单地说它是以一个ziplist为节点的linkedlist，它结合了ziplist和linkedlist两者的优势，为列表类型提供了一种更为优秀的内部编码实现，它的设计原理可以参考Redis的另一个作者Matt Stancliff的博客：<a href="https://matt.sh/redis-quicklist">https://matt.sh/redis-quicklist</a> 。</p>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>集合类型的内部编码有两种：</p>
<ul>
<li>intset（整数集合）：当集合中的元素都是整数且元素个数小于set-max-intset-entries配置（默认512个）时，Redis会选用intset来作为集合的内部实现，从而减少内存的使用。</li>
<li>hashtable（哈希表）：当集合类型无法满足intset的条件时，Redis会使用hashtable作为集合的内部实现。</li>
</ul>
<h2 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h2><p>有序集合类型的内部编码有两种：</p>
<ul>
<li>ziplist（压缩列表）：当有序集合的元素个数小于zset-max-ziplist-entries配置（默认128个），同时每个元素的值都小于zset-max-ziplist-value配置（默认64字节）时，Redis会用ziplist来作为有序集合的内部实现，ziplist可以有效减少内存的使用。</li>
<li>skiplist（跳跃表）：当ziplist条件不满足时，有序集合会使用skiplist作为内部实现，因为此时ziplist的读写效率会下降。</li>
</ul>
</li>
</ul>
<h4 id="单线程为什么这么快？"><a href="#单线程为什么这么快？" class="headerlink" title="单线程为什么这么快？"></a>单线程为什么这么快？</h4><ol>
<li>纯内存 大概是100纳秒 （主要原因）</li>
<li>非阻塞io （select/poll/epoll）</li>
<li>减少了多线程的切换和竟态消耗 ，多线程如果没有合理使用会比单线程还慢</li>
</ol>
<h4 id="需要注意哪些："><a href="#需要注意哪些：" class="headerlink" title="需要注意哪些："></a>需要注意哪些：</h4><ol>
<li><p>一次只运行一次命令</p>
</li>
<li><p>拒绝慢命令 keys flush flushdb，slow lua script 。mutil/exec operate big value（Collection）</p>
</li>
<li><p>redis 其实不是单线程，再执行下面操作的时候都是有单独线程去执行的</p>
<p>​    fysnc file descriptor</p>
<p>​    close file descriptor</p>
</li>
<li><p>redis的key和string类型的value都限制为512MB</p>
</li>
</ol>
<h2 id="Redis-Api的使用和理解"><a href="#Redis-Api的使用和理解" class="headerlink" title="Redis Api的使用和理解"></a>Redis Api的使用和理解</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ol>
<li><h5 id="结构和命令"><a href="#结构和命令" class="headerlink" title="结构和命令"></a>结构和命令</h5><p>​    key value 结构</p>
<p>​    value的值 可以是字符串 数值 也可以是位图   最大的值有限制是512MB</p>
<ol>
<li><p>场景：</p>
<ol>
<li>缓存</li>
<li>计数器</li>
<li>分布式锁</li>
<li>。。。</li>
</ol>
</li>
<li><p>命令</p>
<p>get key O(1)</p>
<p>set key value O(1)</p>
<p>delete key O(1)</p>
<p>incry key  # key自增1 如果不存在，以0为起点 O(1)</p>
<p>decr key  #key 自减  O(1)</p>
<p>incrby  key k # key 自增k，如果不存在 ,自增后get(key)=k  O(1)</p>
<p>decrby key k  #   key 自减k，如果不存在 ,自增后get(key)=-k  O(1)</p>
</li>
<li><p>快速实战</p>
<ol>
<li><p>实现如下功能：</p>
<p>​    记录网站每个用户个人主页的访问量？</p>
<p> incr userid:pageview (单线程：无竞争) </p>
</li>
<li><p>缓存视频的基本信息（数据源再mysql中）伪代码</p>
<img src="/images/redis/image-20201015142830668.png" alt="image-20201015142830668" style="zoom: 33%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> VideoInfo <span class="title">get</span><span class="params">(<span class="keyword">long</span> id)</span></span>&#123;</span><br><span class="line">    String redisKey = redisPrefix+id</span><br><span class="line">  VideoInfo videoInfo = redis.get(redisKey);</span><br><span class="line">  <span class="keyword">if</span> (videoInfo==<span class="keyword">null</span>)&#123;</span><br><span class="line">    videoInfo=mysql.get(id)&#123;</span><br><span class="line">      <span class="keyword">if</span> (videoInfo!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">// 序列化</span></span><br><span class="line">            redis.set(redisKey,searialize(videoInfo))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> videoInfo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ol>
</li>
</ol>
<pre><code>  3. 分布式的id生成器

     &lt;img src=&quot;/images/redis/image-20201015144059614.png&quot; alt=&quot;image-20201015144059614&quot; style=&quot;zoom:33%;&quot; /&gt;

     incr key  

  4.  set  setnx  setxx

     ​    set key value # 不管key是否存在都设置 O(1)

     ​    setnx key value # key 不存在才设置 O(1)

     ​    set key value xx #  key 存在才设置 O(1)

  5. mget  mset

     ​    mget key1 key2 key3 #批量获取key 原子操作 O(n)

     ​    mset key1 value1 key2 value2 key3 value3 # 批量设置key value O(n)

     &lt;img src=&quot;/images/redis/image-20201015145748466.png&quot; alt=&quot;image-20201015145748466&quot; style=&quot;zoom:25%;&quot; /&gt;  &lt;img src=&quot;/images/redis/image-20201015145832158.png&quot; alt=&quot;image-20201015145832158&quot; style=&quot;zoom:25%;&quot; /&gt;#### 内部编码

  4. #### 查缺补漏

     1. getset 、append 、strlen

        getset key newvalue # set key newvalue 并返回久的value   O(1)

        append key value # 将value追加到旧的value O(1)

        strlen key # 返回字符串的长度（注意中文） O(1)  utf8 中文占用两个字节

     2.  incrbyfloat getrange setrange

        incrbyfloat key 3.5 #增加kkey对应的值是3.5 O(1)

        getrange key start end # 获取字符串指定下标的所有的值  O(n)

        setrange key index value # 设置指定下标所有对应的值  O(n)</code></pre>
<ol start="2">
<li><h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><h4 id="1、hash键值的结构"><a href="#1、hash键值的结构" class="headerlink" title="1、hash键值的结构"></a>1、hash键值的结构</h4><p>​        key   filed value    filed 可以理解为属性  value 是属性值    </p>
<img src="/images/redis/image-20201015152852586.png" alt="image-20201015152852586" style="zoom:25%;" />

<h4 id="2、-特点"><a href="#2、-特点" class="headerlink" title="2、 特点"></a>2、 特点</h4><p>​    Mapmap？map的map   key对应的是一个map  filed和value也像是一个map   </p>
<p>​    SmallRedis  引号的 可以理解为上面</p>
<p>​    filed 不能相同 value 可以相同</p>
<h4 id="3-、重要的api"><a href="#3-、重要的api" class="headerlink" title="3 、重要的api"></a>3 、重要的api</h4><ol>
<li><p>​    hget hset hdel</p>
<p>​    hget key filed # 获取hash key对应filed的value O(1) </p>
<p>​    hset key filed value # 设置hash key 对应field 的value  O(1)</p>
<p>​    hdel key field # 删除hash key 对应filed的value  O(1)</p>
</li>
<li><p>hexists hlen </p>
<p>​    hexists  key filed # 判断hash key 是否有field O(1) </p>
<p>hlen key # 获取hash key field的数量 O(1) </p>
</li>
<li><p>hmegt  hmset</p>
<p>​    hmget key filed1 field2 … filedN # 批量获取hash key的一批field的值  O(n)</p>
<p>​    hmset key filed1 value1 field2 value2 …filedN valueN # 批量设置hash key的一批field value O(n) </p>
</li>
</ol>
<h4 id="4、-实战"><a href="#4、-实战" class="headerlink" title="4、 实战"></a>4、 实战</h4><ol>
<li><p>​    记录网站每个用户个人主页的访问量</p>
<p>​    hincrby user:1:info pageview count</p>
</li>
<li><p>缓存视频的基本信息 伪代码    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> VedioInfo <span class="title">get</span><span class="params">(<span class="keyword">long</span> id)</span></span>&#123;</span><br><span class="line">  String redisKey = redisPrefix + id</span><br><span class="line">  Map&lt;String,String&gt; hashMap = redis.getAll(redisKey)</span><br><span class="line">  VideoInfo videoInfo = transferMapToVideo(hashMap)</span><br><span class="line">  <span class="keyword">if</span> videoInfo == <span class="keyword">null</span> &#123;</span><br><span class="line">        videoInfo = mysql.get(id)</span><br><span class="line">      <span class="keyword">if</span> videoInfo != <span class="keyword">null</span> &#123;</span><br><span class="line">        redis.hmset(redisKey,transVideoToMap(videoInfo))</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> videoInfo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>hgetall hvals  hkeys</p>
<p>hgetall key # 返回对应key的所有field和value O(n) </p>
<p>hvals key # 返回对应key的所有field的values O(n) </p>
<p>hkeys key # 返回对应key的所有field  O(n) </p>
<p>小心使用hgetall 因为redis是单线程  否则会阻塞操作</p>
</li>
<li><p>更新用户信息</p>
<ol>
<li>string key  user存储    key value是整个用户信息</li>
<li>string  key:用户属性  value:属性值</li>
<li>hash  key field 是用户属性 value  属性值</li>
</ol>
<img src="/images/redis/image-20201015174305567.png" alt="image-20201015174305567" style="zoom:25%;" />



</li>
</ol>
</li>
</ol>
<h4 id="5、查缺补漏"><a href="#5、查缺补漏" class="headerlink" title="5、查缺补漏"></a>5、查缺补漏</h4><ol>
<li><p>hsetnx hincrby hincrbyfloat</p>
<p>​    hsetnx key field value # 设置hash key对应field的value 如果field已经存在则失败 O(1)</p>
<p>​    hincrby key field intCounter # hash key对应的field的value自增intCounter  O(1) </p>
<p>​    hincrbyfloat key field floatCounter  # hash key对应的field的value自增loatCounter  O(1)</p>
</li>
</ol>
<ol start="3">
<li><h2 id="list-1"><a href="#list-1" class="headerlink" title="list"></a>list</h2><ol>
<li><h4 id="列表结构"><a href="#列表结构" class="headerlink" title="列表结构"></a>列表结构</h4><p>​    key  elements</p>
</li>
<li><h4 id="重要api"><a href="#重要api" class="headerlink" title="重要api"></a>重要api</h4><p>​    rpush key value1 value2 … valueN #从列表右端插入值(1-n个) O(n)</p>
<p>​    lpush key value1 value2 … valueN # 从列表左端插入值(1-n个) O(n)</p>
<p>​    linsert key before|after value newValue #在list指定的值 前|后插入newValue O(n)</p>
<p>​    lpop key # 从list左边弹出一个item</p>
<p>​    rpop key # 从list右边弹出一个item</p>
<p>​    lrem key count value # 根据count的值，从列表中删除所有与value相等的项 O(n)</p>
<ol>
<li>count&gt;0 从左到右，删除最大count个与value相等的项</li>
<li>count&lt;0 从右到左，删除最大count个与value相等的项</li>
<li>count=0 删除所有与value相等的项</li>
</ol>
<p>​    ltrim key start end # 按照索引范围修剪列表 O(n)</p>
<p>​    lrange key start end（包含end）# 获取列表指定范围的所有item O(n)</p>
<p>​    lindex key index # 获取列表指定索引的值 O(n)</p>
<p>​    llen key # 获取列表的长度 O(1)</p>
<p>​    lset key index newValue # 设置列表指定索引的值为newValueO(n)</p>
<h4 id="3-实战场景"><a href="#3-实战场景" class="headerlink" title="3.实战场景"></a>3.实战场景</h4><p>​    时间轴 timeline</p>
<h4 id="4-查缺补漏"><a href="#4-查缺补漏" class="headerlink" title="4.查缺补漏"></a>4.查缺补漏</h4><p>​    blpop brpop</p>
<ol>
<li>​    blpop key timeout # lpop阻塞版本，timeout是阻塞超时时间，timeout=0 为永远不阻塞</li>
<li>brpop key timeout # rpop阻塞版本，timeout是阻塞超时时间，timeout=0 为永远不阻塞</li>
</ol>
<h5 id="5-tips"><a href="#5-tips" class="headerlink" title="5. tips"></a>5. tips</h5><ol>
<li>​    LPUSH + LPOP = Stack</li>
<li>​    LPUSH + RPOP = Quene</li>
<li>LPUSH + LTRIM = Cappend Collection 固定大小的集合</li>
<li>LPSUH + BRPOP = Message Quene </li>
</ol>
</li>
</ol>
</li>
<li><p>set</p>
<ol>
<li><p>集合结构</p>
<p>​    key  values</p>
</li>
<li><p>特点</p>
<ol>
<li>无序</li>
<li>无重复</li>
<li>集合间的操作</li>
</ol>
</li>
<li><p>api</p>
<ol>
<li><p>sadd  srem</p>
<p>sadd key element  #向集合key添加element（如果element已经存在 添加失败） O(1)</p>
<p>srem key element  # 将集合key中element移出掉  O(1)</p>
</li>
<li><p>scard、sismember 、srandmember、 smembers</p>
<p>scard key # 计算 集合的大小</p>
<p>sismember key element # 判断element是否在集合key中存在</p>
<p>srandmember key count # 从集合中随机挑选count个元素  </p>
<p>spop key # 从集合中随机弹出一个元素 （弹出之后 集合中不存在这个元素了）</p>
<p>smembers key # 返回集合中所有元素 </p>
<ol>
<li>无序</li>
<li>小心使用 集合多会阻塞队列</li>
</ol>
</li>
<li><p>集合内实战</p>
<ol>
<li><p>抽奖系统</p>
<p>​    可以借助srandmember 或者spop来实现</p>
</li>
<li><p>like 赞 踩</p>
</li>
<li><p>添加标签 </p>
</li>
</ol>
</li>
<li><p>集合间的使用</p>
<ol>
<li>sdiff sinter sunion</li>
</ol>
<p>​    sdiff key1 key2 # 算出两个集合的差集</p>
<p>​    sinter key1 key2 # 算出两个集合的交集</p>
<p>​    sunion key1 key2 # 算法两个集合的并集</p>
</li>
<li><p>tips</p>
<p>sadd = 添加标签</p>
<p>spop /srandMember = 获取随机数</p>
<p>sadd + sinter = 做一些社交相关的业务</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>list 有序集合</p>
<ol>
<li><p>结构</p>
<p>​    key score value</p>
</li>
<li><p>特点</p>
<ol>
<li>无重复元素</li>
<li>有序</li>
<li>element score</li>
</ol>
</li>
<li><p>重要api</p>
<ol>
<li>zadd key score element # 添加元素（可以是多对 score 可以重复 element不能重复）O(logN)</li>
<li>zrem key element # 删除元素 可以多个 O(1)</li>
<li>zscore key element # 返回元素的分数 O(1) </li>
<li>zincrby key increSocre element  # 增加或减少element的分数 O(1)</li>
<li>zcard key # 返回元素的总个数   O(1)</li>
<li>zrank key element # 获取element在集合中的排名  ，从小到大 起点是0  O(1)  </li>
<li>zrange key start end 【withscores】 # 返回指定索引范围内的升序元素， 按照排名进行排序 O(logN + m)  </li>
<li>zrangebyscore key minScore maxScore withscores】  # 返回指定分数范围内的升序元素【分值】，按照分值进行排序   O(logN + m)  </li>
<li>zcount key minScores maxScore # 返回有序集合内在指定分数范围的个数 O(logN + m)  </li>
<li>zremrangebyrank key start end # 删除指定排名内的升序元素 O(logN + m)  </li>
<li>zremrangebyscore by minScore maxScore # 删除指定分值内的升序元素 O(logN + m)  </li>
</ol>
</li>
<li><p>实战</p>
<ol>
<li>排行榜 </li>
</ol>
</li>
<li><p>查缺补漏</p>
<ol>
<li>zrevrank  </li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="瑞士军刀-redis"><a href="#瑞士军刀-redis" class="headerlink" title="瑞士军刀 redis"></a>瑞士军刀 redis</h2><h3 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h3><ol>
<li><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><ol>
<li>过程  发送 排队 执行 返回结果</li>
<li>慢查询是发生在第三阶段 </li>
<li>客户端超时不一定慢，但慢查询是客户端超时的一个可能因素</li>
</ol>
</li>
<li><h4 id="两个配置"><a href="#两个配置" class="headerlink" title="两个配置"></a>两个配置</h4><ol>
<li><p>slowlog-max-len</p>
<ol>
<li><p>先进先出的队列</p>
</li>
<li><p>固定长度</p>
</li>
<li><p>保存在内存内  </p>
<img src="/images/redis/image-20201016175532537.png" alt="image-20201016175532537" style="zoom: 50%;" />
</li>
</ol>
</li>
<li><p>slowlog-log-slower-than</p>
<ol>
<li>慢查询的阈值（单位：微秒）</li>
<li>slowlog-log-slower-than=0 记录所有的命令 ps（因为客户端不会显示执行的时间，这时候可以将改配置记录为0 ，然后看一下慢查询中执行的时间）</li>
<li>slowlog-log-slower-than&lt;0 不记录任何命令</li>
</ol>
</li>
<li><p>配置方法</p>
<ol>
<li><p>默认值</p>
<ol>
<li>config get slowlog-max-len= 128 默认值 </li>
<li>config get slowlog-log-slower-than=10000 10ms</li>
</ol>
</li>
<li><p>修改配置文件重启（不推荐）</p>
</li>
<li><p>动态配置</p>
<ol>
<li>config set slowlog-max-len 1000</li>
<li>config set slowlog-log-slower-than=1000</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<ol start="3">
<li><h4 id="三个命令"><a href="#三个命令" class="headerlink" title="三个命令"></a>三个命令</h4><ol>
<li>slowlog get [n] : 获取慢查询队列</li>
<li>showlog len ： 获取慢查询队列的长度</li>
<li>showlog reset ： 清空慢查询队列</li>
</ol>
</li>
<li><h4 id="运维经验"><a href="#运维经验" class="headerlink" title="运维经验"></a>运维经验</h4><ol>
<li>slowlog-max-len 不要设置的过大，slowlog-log-slower-than默认是10ms，通常设置为1ms</li>
<li>slowlog-log-slower-than 不要设置的过小，通常设置在1000左右</li>
<li>理解命令的生命周期</li>
<li>定期持久化慢查询（因为慢查询是存在内存当中的，这样我们就能查到历史的慢查询，这些数据是非常重要的，可以使用一些开源的第三方方法来实现这个功能）</li>
</ol>
<h3 id="pipeline"><a href="#pipeline" class="headerlink" title="pipeline"></a>pipeline</h3></li>
<li><p>什么是流水线</p>
<ol>
<li><p>正常redis执行一条命令的时间= 客户端发送请求和获取请求算一次网络时间，+ 一次命令在客户端执行的时间</p>
<p>如果多次执行redis 命令就会浪费很多网络时间，所以我们将多次命令可以打包成pipeline，然后在服务端计算n次</p>
<p>将结果顺序返回，这样</p>
<p>1次pipeline(n条命令)=1次网络时间+ n次命令执行时间</p>
<p>注意：</p>
<p>​        redis的命令时间是微秒级别的</p>
<p>​        pipeline每次条数要控制（网络）</p>
</li>
</ol>
</li>
<li><p>客户端实现</p>
</li>
<li><p>与原生操作对比</p>
<ol>
<li>他不是原子操作</li>
<li>客户端将pipeline的命令发送到服务端之后 会将pipeline中的命令进行拆分的</li>
</ol>
</li>
<li><p>使用建议</p>
<ol>
<li>注意每次pipeline携带的数据量</li>
<li>pipeline每次只能作用在一个redis节点上</li>
<li>M操作与pipeline的区别</li>
</ol>
<h3 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h3></li>
<li><p>角色</p>
<ol>
<li>发布者 publisher</li>
<li>订阅者 subscriber</li>
</ol>
<h3 id="bitmap"><a href="#bitmap" class="headerlink" title="bitmap"></a>bitmap</h3><h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><h3 id="Geo"><a href="#Geo" class="headerlink" title="Geo"></a>Geo</h3></li>
</ol>
<h3 id="开发运维常见问题"><a href="#开发运维常见问题" class="headerlink" title="开发运维常见问题"></a>开发运维常见问题</h3><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><ol>
<li><h4 id="命令实现"><a href="#命令实现" class="headerlink" title="命令实现"></a>命令实现</h4><ol>
<li>slaveof  ip port     异步去执行复制 </li>
<li>取消复制<ol>
<li>slaveof no more 不在成为从节点  </li>
</ol>
</li>
</ol>
</li>
<li><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><ol>
<li>slaveif ip port</li>
<li>slave-read-only yes 只做读操作 </li>
</ol>
</li>
<li><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><table>
<thead>
<tr>
<th align="center">方式</th>
<th align="center">命令</th>
<th align="center">配置</th>
</tr>
</thead>
<tbody><tr>
<td align="center">优点</td>
<td align="center">不需要重启</td>
<td align="center">统一配置</td>
</tr>
<tr>
<td align="center">缺点</td>
<td align="center">不便于管理</td>
<td align="center">需要重启</td>
</tr>
</tbody></table>
</li>
<li><h4 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h4><p>redis&gt; info replication 查看分片的状态</p>
<p>主从复制的配置 实际上是从节点先flush本身的数据 然后在通过网络传输将master节点的rdb文件复制过来 然后再加载到内存当中</p>
</li>
<li><h4 id="全量复制和部分复制"><a href="#全量复制和部分复制" class="headerlink" title="全量复制和部分复制"></a>全量复制和部分复制</h4><ol>
<li><p>当不知道master节点的run id是多少 或者master节点重启或其他情况 run id会发生改变 这样都会出发slave节点全量复制</p>
</li>
<li><p>部分复制是要看 info replication</p>
<p>​    </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">10.49.1.43:6379&gt; info replication</span><br><span class="line"><span class="meta">#</span><span class="bash"> Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:1</span><br><span class="line">slave0:ip=192.168.16.74,port=6379,state=online,offset=102936066,lag=1</span><br><span class="line">master_replid:134e809e3fddd112cdb3235e0a0f15a167ea65b5</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:102936066</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:101887491</span><br><span class="line">repl_backlog_histlen:1048576</span><br><span class="line"></span><br><span class="line">10.49.1.121:6379&gt; info replication</span><br><span class="line"><span class="meta">#</span><span class="bash"> Replication</span></span><br><span class="line">role:slave</span><br><span class="line">master_host:192.168.51.59</span><br><span class="line">master_port:6379</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:1</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:421179470</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_replid:5267ce41ab6dcb2bb525b5279df006259e835153</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:421179470</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:420130895</span><br><span class="line">repl_backlog_histlen:1048576</span><br></pre></td></tr></table></figure>

<p>从节点会定时上报自己的状态到主节点 这样master就知道slave 的偏移情况，如果offset是差别比较多的情况下 ，证明你的主从复制是有问题的，有可能是阻塞 网络 或者是缓存区域有没有满的情况 </p>
</li>
<li><p>全量复制 首先slave先将获取到的rdb文件加载到内存中，加载完成后 ，然后通过偏移量的对比 将这个期间写入的值同步给slave节点</p>
<p>​    <img src="/images/redis/image-20201020165104374.png" alt="image-20201020165104374"></p>
</li>
</ol>
</li>
</ol>
<pre><code>     1. 1 redis 2.8之前是sync  2.8之后是psync  ，是完成全量复制和部分复制的一个功能，需要两个参数 一个是run id 一个是偏移量 offset ，完成全量复制之后 在将offset之后的写入数据同步到slave上，如果第一次不知道run id是多少 也不知道偏移量是多少 那么 run id 就传？offset 填 1
     2. master节点会告诉slave节点的run id和偏移量
     3. salve 会保存master的一个基本信息
     4. master 执行 持久化相关的bgsave，生一个快照 rdb文件
     5. 在生成rdb发给slave之后 实际上redis 还有一个复制缓存区
     6. 发送缓存区的数据
     7. flush 老数据
     8. 加载rdb和缓存区的数据

  4. 全量复制的开销

     1. bgsave 的时间
     2. RDB文件的网络传输时间
     3. 从节点清空数据时间
     4. 从节点加载rdb时间
     5. 可能的aof重写时间

     有一个场景就是slave在进行全量复制的过程中 master和slave之间发生了网络抖动，这样在网络抖动期间操作的数据 slave是不知道的，所以2.8之前会再进行一次全量复制 但是全量复制的开销也是比较大的 所以2.8之后 出现了部分复制，将这个损失降到最低

  5. 部分复制

     1. 连接断开
     2. master在写的时候会写一份复制到缓冲区的命令
     3. 网络抖动结束 slave继续连接master
     4. slave会执行一个psync命令 告诉master 自己的offset和run id
     5. offset在master有一个队列的概念 如果offset不在master的队列期间内 证明已经错过了很多数据，会进行全量复制，
     6. 如果再范围内，那么会将offset到队列结尾的数据同步给slave ，这样master和slave就达到了一致，后面的那些

  6. 故障处理

     1. 主从结构故障
        1. slave故障-宕机  改成连接其他的slave节点就可
        2. master故障宕机 找一个slave 选择成master  执行slaveof no one，其他的节点执行slave of new master，如果故障发生了 每一秒都很重要 最好能脚本化
        3. 可以使用redis sentinel来进行故障转移

  7. 主从复制

     1. 优点

        1. 实现高可用，分布式基础
        2. 数据备份
        3. 读写分离

     2. 可能遇到的问题

        1. 读写分离
        2. 主从配置不一致
        3. 规避全量复制
        4. 规避复制风暴

     3. 读写分离

        1. 读流量分摊到从节点

        2. 可能遇到的问题

           1. 复制数据的延迟 
           2. 读到过期的数据
           3. 从节点故障

        3. 配置不一致

           1. 主从节点的maxmemory 不一致，丢失数据， 从节点的内存比主节点小会触发最大内存的淘汰策略，将数据进行淘汰，如果过期的数据比较多，那么会优先剔出出去过期的数据，即使oom也不会报错，但是如果当slave晋升成为主节点的时候 就会因为内存不够从而淘汰一些数据 
           2. 例如数据结构优化参数(例如hash-max-ziplist-entries)： 内存不一致 

        4. 规避全量复制

           1. 产生的条件 

              1. 第一次全量复制  不可避免

                 ​    小主节点 低峰 （maxmemory 设置的小 或者在低峰的时候去复制）

              2. 节点运行的id 不匹配

                 1. 主节点重启（运行id变化）
                 2. 故障转移，例如哨兵或者集群 slave晋升为主节点

              3. 复制积压缓冲区不足  （1MB）判断主从的offset 如果没命中就需要进行全量复制

                 1. 网络中断，部分复制无法满足
                 2. 增大复制缓存去配置rel_backlog_size ，网络增强

        5. 规避复制风暴

           1. 单节点复制风暴

              1. 问题：主节点重启 ，多从节点复制

              2. 解决：更换网络拓扑&lt;img src=&quot;/images/redis/image-20201021214920029.png&quot; alt=&quot;image-20201021214920029&quot; style=&quot;zoom:33%;&quot; /&gt;

                 这样对于master来说会减轻他的压力，如果不考虑读写分离 那么完全可以在master节点挂掉之后 将slave节点晋升 然后在给它加一个slave 节点就可以了

           2. 单机器复制风暴

              1. 机器宕机之后 大量全量复制 ，&lt;img src=&quot;/images/redis/image-20201021215320889.png&quot; alt=&quot;image-20201021215320889&quot; style=&quot;zoom: 33%;&quot; /&gt;

                 ​    masterA 会进行大量的bgsave 然后传输rdb文件，很有可能会造成内存池满和大量的网络开销或者带宽池满的情况 

              2. 解决： 我们将master节点分数到多机器上 </code></pre>
]]></content>
  </entry>
  <entry>
    <title>知识必备</title>
    <url>/2020/08/28/%E7%9F%A5%E8%AF%86%E5%BF%85%E5%A4%87/</url>
    <content><![CDATA[<p>###</p>
<p>为什么打算出来面试呢</p>
<p>​    现在自己的技术成长有碰到瓶颈、加上一直对您公司钦慕有加</p>
<h3 id="redis-hash是怎么解决hash冲突的"><a href="#redis-hash是怎么解决hash冲突的" class="headerlink" title="redis hash是怎么解决hash冲突的"></a>redis hash是怎么解决hash冲突的</h3><p>  链地址法</p>
<p>Redis 的哈希表使用链地址法（separate chaining）来解决键冲突： 每个哈希表节点都有一个 <code>next</code> 指针， 多个哈希表节点可以用 <code>next</code> 指针构成一个单向链表， 被分配到同一个索引上的多个节点可以用这个单向链表连接起来， 这就解决了键冲突的问题。</p>
<h3 id="redis的持久化"><a href="#redis的持久化" class="headerlink" title="redis的持久化"></a>redis的持久化</h3><ol>
<li><p>使用rdb，是周期性的对redis进行持久化操作，一般默认时间是5min，</p>
</li>
<li><p>使用了aof，是根据redis的每条写命令进行持久化操作，一般是append only的形式，同时也可以通过rewrite的方式来对aof的日志进行重构redis  的数据集</p>
<p>通过rdb 和aof都可以将redis中的内存数据持久化到磁盘上来，然后将这些数据备份到aws 的s3或者其他的云服务上去，一旦redis挂了，或者服务器的内存和磁盘上的数据都丢失了，可以从云服务上拷贝之前的数据，放到指定目录中，然后启动redis，redis就会自动根据持久化数据文件中的数据，去恢复内存中的数据，继续对外提供服务。</p>
<p>如果同时使用aof和rdb两种持久化机制，那么在redis重启的时候，会使用aof来重构数据，因为aof的数据会更加完整</p>
</li>
</ol>
<p>   rdb的优缺点：</p>
<p>   rdb会生成多个数据文件，每个数据文件都代表了某一时刻中redis中的数据，这个多个数据的方式非常时候做冷备份。</p>
<p>   rdb对redis对外提供的读写服务非常小，因为redis 提供了bgsave的command，主线程可以fork一个子线程去执行磁盘io的持久化操作，进行rdb的持久化</p>
<p>   相对于aof来说，直接基于rdb数据文件来重启和恢复redis进程会更加快速。</p>
<p>   如果想要在redis出现故障的时候，尽可能少的丢失数据，rdb没有aof好，一般来说rdb的文件一般是每隔5分钟生成一次，或者更长的时间生成一次，这样在进行redis恢复的时候就要考虑可能要丢失最新5分钟的数据</p>
<p>   rdb每次在fork子进程来进行rdb快照数据文件生成的时候，如果文件特别大，可能会导致对客户端提供的服务暂停数毫秒，甚至数秒</p>
<p>   aof的优缺点</p>
<p>   ​    aof可以很好的保证数据不丢失，一般aof会每隔一秒通过后台线程执行一次fsync操作，最多丢失1秒钟的数据</p>
<p>   aof日志以append only模式写入，所以没有任何磁盘寻址的开销。写入性能非常高而且文件性能不容易被损坏，即使损坏也很容易修复。</p>
<p>   aof日志文件即使过大的时候 出现后台的重写操作，也不会影响客户端的读写。因为在rewrite log的时候，会对其进行指导压缩，创建出一份需要恢复的数据的最小日志出来，在创建新日志文件的时候，老的日志文件照常写入，当新的merge后的日志文件ready的时候 再交换新老日志文件即可</p>
<p>   aof日志文件记录的命令非常可读，也非常适合灾难性的误删除的紧急恢复，比如某人不小心使用flushall的命令清空所有数据，只有这个时候rewrite还没有发生，那么就可以拷贝aof文件，将最后一条的fluashll 命令删除，然后在将该aof文件放回去，通过恢复机制，自动恢复所有数据</p>
<p>   对于同一份日志文件来说，aof的文件要比rdb的文件更大</p>
<p>   aof开启后，支持redis的写的qps会比支持rdb写的qps低，因为aof一般会配置成每秒fsync一次日志，其实性能还是很高的，如果支持实时写入的化 那么qps会大降</p>
<h3 id="redis的string-底层实现"><a href="#redis的string-底层实现" class="headerlink" title="redis的string 底层实现"></a>redis的string 底层实现</h3><p>​    embstr  小于39个字节</p>
<p>​    long 长整型  在做自增自减</p>
<p>​    raw 大于39的字节的字符串</p>
<p>Redis会根据当前值的类型和长度决定使用哪种内部编码实现。</p>
<h3 id="redis-hash的结构"><a href="#redis-hash的结构" class="headerlink" title="redis hash的结构"></a>redis hash的结构</h3><p>哈希类型的内部编码有两种：</p>
<ul>
<li><p>ziplist（压缩列表）：</p>
<p>条件：</p>
<ol>
<li>当哈希类型元素个数小于hash-max-ziplist-entries配置（默认512个）</li>
<li>所有值都小于hash-max-ziplist-value配置（默认64字节）</li>
</ol>
</li>
<li><p>hashtable（哈希表）：当哈希类型无法满足ziplist的条件时使用hashtable</p>
</li>
</ul>
<p>Redis使用ziplist作为哈希的内部实现，ziplist使用更加紧凑的结构实现多个元素的连续存储，所以在节省内存方面比hashtable更加优秀。</p>
<p>使用hashtable作为哈希的内部实现，ziplist的读写效率会下降，而hashtable的读写时间复杂度为O（1）。</p>
<h3 id="redis-为什么是单线程及高并发快的原因"><a href="#redis-为什么是单线程及高并发快的原因" class="headerlink" title="redis 为什么是单线程及高并发快的原因"></a>redis 为什么是单线程及高并发快的原因</h3><ol>
<li>redis是基于内存的。读写都非常快</li>
<li>redis是单线程的，减少了上下文切换的时间</li>
<li>redis使用了io多路复用计数，可以并发的处理连接、非阻塞io内部实现了epoll，采用了epoll+自己实现的简单事件框架。epoll中的读写、关闭、连接都转化成了事件、然后采用了epoll的多路复用的特效 绝不在io上浪费一点事件 </li>
</ol>
<p>io多路复用主要有三种计数    select/poll/epoll  </p>
<p>​    select的时间复杂度是）O（n），它仅仅知道了io事件发生了，但是不知道是哪个流，只能挨个轮训，同时处理的流越多，无差别轮训的时间越长，是无差别轮训</p>
<p>​    poll 的时间复杂度也是O（n），它和select没啥区别，也是将用户传入的数组拷贝到内核空间、然后查询fb对应的设备状态。它比select的优点是因为他没有最大连接数的限制，原因是因为他是基于链表存储的，使用的是忙轮训，而select是基于数组存储的，默认是2048</p>
<p>epoll 可以理解为event poll，不同于忙轮训和无差别轮训。epoll会把哪个流发生了怎样的io事件通知我们（内部调用了callback函数）、所以我们说epoll实际上是事件驱动的，每个事件关联着fd，此时我们对这些流的操作都是有意义的 ，内存拷贝 利用 mmap（）文件映射内存加速与内核空间的消息传递；（降低了复制开销）</p>
<p>redis使用的epool</p>
<h3 id="btree和b-tree的区别"><a href="#btree和b-tree的区别" class="headerlink" title="btree和b+tree的区别"></a>btree和b+tree的区别</h3><p>B树的特点：<br>（1）所有键值分布在整个树中<br>（2）任何关键字出现且只出现在一个节点中<br>（3）搜索有可能在非叶子节点结束<br>（4）在关键字全集内做一次查找，性能逼近二分查找算法</p>
<p>B+树与B树的不同在于：<br>（1）所有关键字存储在叶子节点，非叶子节点不存储真正的data<br>（2）为所有叶子节点增加了一个链指针</p>
<p>为什么mysql的索引使用B+树而不是B树呢？？<br> （1）B+树更适合外部存储(一般指磁盘存储),由于内节点(非叶子节点)不存储data，所以一个节点可以存储更多的内节点，每个节点能索引的范围更大更精确。也就是说使用B+树单次磁盘IO的信息量相比较B树更大，IO效率更高。<br> （2）mysql是关系型数据库，经常会按照区间来访问某个索引列，B+树的叶子节点间按顺序建立了链指针，加强了区间访问性，所以B+树对索引列上的区间范围查询很友好。而B树每个节点的key和data在一起，无法进行查询非</p>
<h3 id="数据库的分库分表"><a href="#数据库的分库分表" class="headerlink" title="数据库的分库分表"></a>数据库的分库分表</h3><ol>
<li>​    原因：<ol>
<li>用户请求量太大 单机器tps、io、内存都是有限的，解决办法：分散请求到多个服务器上，因为用户请求和执行sql本质是一样的，都是请求一个资源，只是用户请求还会经过网关 路由 http服务器等</li>
<li>单表太大 curd都成问题 索引膨胀、查询超时， 解决办法 拆分成更多更小的表</li>
<li>单库太大 单个数据库的处理能力是有限的，单库所在服务器上磁盘空间不足；单库上操作的io瓶颈 解决办法：拆分成更多的小库</li>
</ol>
</li>
<li>垂直拆分<ol>
<li>垂直分表：将不常用的字段拆分到一个新表中，一般是针对那种几百列的大表，避免了数据量太大造成 跨页的问题</li>
<li>垂直分库： 针对一个系统中不同业务进行拆分、比如user一个库、商品一个库、订单一个库，然后将这些库不要放在同一个服务器上，防止单个数据库的处理能力成为瓶颈、而且对单个服务器的磁盘、内存、tps等都会相互有影响</li>
</ol>
</li>
<li>水平拆分<ol>
<li>水平分表  ：针对订单量这种大表，按照规则（range、hash 取模等）但是这些表还是再同一个库中，库级别的数据库操作还是有瓶颈</li>
<li>水平分库分表：将单张表的数据切分到多个服务器上去，每隔服务器具有相应的库与表，只是表中数据集合不同。</li>
<li>切分规则：<ol>
<li>range </li>
<li>hash</li>
<li>地理区域</li>
<li>时间</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="tcp-三次握手和挥手"><a href="#tcp-三次握手和挥手" class="headerlink" title="tcp 三次握手和挥手"></a>tcp 三次握手和挥手</h3><ol>
<li><p>三次握手</p>
<ol>
<li>发送端 发送一个SYN=1，seq=n 到接收端</li>
<li>接收端 发送SYN=1 ACK=1 ，seq=y，ack=n+1</li>
<li>发送端发送 SYN=1 ack=y+1,seq=n+1</li>
</ol>
</li>
<li><p>四次挥手</p>
<ol>
<li>客户端发送FIN=1，seq=n establish状态</li>
<li>服务端收到 发送 ACK=1，ack=n+1 ，seq=v wait close</li>
<li>服务端发送FIN=1，ack=n+1，seq=w ，ACK=1 fin2 wait</li>
<li>客户端发送 ACK=1，ack=w+1，seq=n+1 closed</li>
</ol>
<h2 id="为什么需要四次挥手"><a href="#为什么需要四次挥手" class="headerlink" title="为什么需要四次挥手"></a>为什么需要四次挥手</h2><p>因为关闭连接时，当收到FIN报文通知时 紧紧表示 对方没有数据发送给你了；但是未必你所有的数据都发送给对方了，所以你可未必马上会关闭socket，再发送FIN报文时给对方表示你同意关闭连接了，所以这里的ack报文和FIN报文是分开发送的</p>
</li>
</ol>
<h3 id="为什么需要三次握手"><a href="#为什么需要三次握手" class="headerlink" title="为什么需要三次握手"></a>为什么需要三次握手</h3><p>​    防止已过期的连接突然又传到服务器发生错误</p>
<p>​    也发送client发送的请求因为网络延迟没有发送到服务端，但是当server接收到之后，如果没有三次握手，server是直接发送数据到client，这样会造成server资源的浪费</p>
<p>mq的优势   </p>
<h3 id="ActiveMQ-RabbitMQ-KafKa对比"><a href="#ActiveMQ-RabbitMQ-KafKa对比" class="headerlink" title="ActiveMQ RabbitMQ KafKa对比"></a>ActiveMQ RabbitMQ KafKa对比</h3><ol>
<li>tps比较 kafka最高 RabbitMq次之 activityMq最差</li>
<li>吞吐量对比 Kafka最高，因为内部采用的是消息批处理、零拷贝机制，数据的获取和存储是本地磁盘顺序批量操作，具有O（1）的复杂度，消息的处理效率很高，rabbitMq的吞吐量稍逊与kafka，因为他们的出发点不一样，rabbitMq支持对这消息的可靠性传递、支持事物、不支持批量操作；基于存储的可靠性的要求可以采用内存或者硬盘</li>
<li>在架构方面 rabbitmq遵循amqp协议，rabbitmq的broker由exchange、binding、queue组成，其中exchange和binding组成了消息的路由键；客户端Producer通过channel和server进行通信，consumer从queue获取消息进行消费（长连接，queue有消息就会推送到consumer端，consumer循环从输入流读取数据）rabbitmq以broker为中心，有消息确认机制，kafka 遵从一般的mq结构，producer、consumer、borker，以consumer为中心，消息的消费信息保存在客户端的consumer上，consumer根据消费的点，从broker上批量pull数据，无消息确认机制</li>
<li>在可用性方面： rabbitmq支持mirror的queue，主queue失效，mirror queue接管、kafka的broker支持主备模式，activeMq也支持主备模式</li>
<li>在集群负载均衡方向：kafka采用的zookeeper对集群中broker和consumer进行管理，可以注册topic到zookeeper上，通过zookeeper的协调机制，producer保存对应的broker信息，可以随机或者轮询发送到broker上、并且producer可以基于语义指定分片，消息发送到broker的某分片上。rabbitmq的负载均衡需要单独的loadbalanceer进行支持</li>
</ol>
<p>activeMq和rabbitMq的区别 mq的高可用 <a href="https://cloud.tencent.com/developer/article/1460173">https://cloud.tencent.com/developer/article/1460173</a></p>
<h3 id="消息丢失怎么处理"><a href="#消息丢失怎么处理" class="headerlink" title="消息丢失怎么处理"></a>消息丢失怎么处理</h3><ol>
<li>​    生产者丢失 增加重试 重试间隔改长 防止一次网络波动就三次都失败了</li>
<li>消费者丢失》消息被追加到分区parton的时候都会分配一个特定的偏移量offset，消费者拉取到分区的某个消息后 会自动提交offset，我们要把自动提交改为手动提交</li>
<li>kafka丢失消息 ：引用多副本机制，设置acks=all</li>
</ol>
<h3 id="redis的高可用"><a href="#redis的高可用" class="headerlink" title="redis的高可用"></a>redis的高可用</h3><p>​    cluster 模式 3主3从</p>
<h3 id="mysql是如何进行主从同步的"><a href="#mysql是如何进行主从同步的" class="headerlink" title="mysql是如何进行主从同步的"></a>mysql是如何进行主从同步的</h3><p>​    在master机器上操作：当master数据发送变化时，该事件变化会按照顺序写入到bin-log中，当slave连接到master的时候，master机器会为slave开启binlog dump线程。当master的binlog发送变化的时候，bin log dump线程或通知slave，并将相应的bin log内容发送给slave</p>
<p>在slave机器上操作，当主从同步开启的时候，slave会创建两个线程：io线程、该线程连接到master机器、master机器上的bin log dump线程会将binlog的内容发送给该io线程、该io线程接收到binlog内容后，再将内容写入到relay log；sql线程，该线程读取io线程写入到的relay log，并且根据relay log的内容对于slave数据库做相应的操作。</p>
<h3 id="输入一个网址后面做了哪些事"><a href="#输入一个网址后面做了哪些事" class="headerlink" title="输入一个网址后面做了哪些事"></a>输入一个网址后面做了哪些事</h3><ol>
<li>域名解析<ol>
<li>从浏览器里找ip </li>
<li>从hosts文件里找ip</li>
<li>从路由器缓存里找ip</li>
<li>从dns缓存里查找</li>
<li>从域名解析器里找ip</li>
</ol>
</li>
<li>tcp连接</li>
<li>springmvc请求过程</li>
<li>浏览器解析</li>
<li>绘制网页</li>
</ol>
<p>###分布式锁的实现</p>
<ol>
<li><p>redis set key value px milliseconds nx    </p>
</li>
<li><p>redis setnx+lua</p>
<p>前者的核心命令实现如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">   </span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>获取锁<br> set resource_name unique_value NX PX 30000</li>
<li>释放锁(lua脚本中一定要比较value 防止误解锁)<br>  if redis.call(“get”,KEYS[1])==ARGV[1] then<br>   return redis.call(“del”,KEYS[1])<br>  else<br>   return 0<br>  end  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">实现这类锁有三个需要值得注意的地方</span><br><span class="line"></span><br><span class="line">1. set命令要使用set key value px millionseconds nx；</span><br><span class="line">2. value要具有唯一性</span><br><span class="line">3. 释放锁时要比较value 防止误解锁</span><br><span class="line"></span><br><span class="line">但是这类锁的最大缺点就是它加锁时只作用在一个redis节点上、即使这个redis通过sentinel保证高可用，如果master节点由于发送了主从切换，那么就会出现锁丢失的情况：</span><br><span class="line"></span><br><span class="line">1. 在redis的master节点拿到了锁</span><br><span class="line">2. 但是这个加锁的key还没有同步到slave节点</span><br><span class="line">3. master故障 发生故障转移。slave升级为master节点</span><br><span class="line">4. 导致锁丢失</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li><p>redis作者antiirez又提出了一种基于分布式环境下更高级的分布式锁实现方式：以redis集群有N个master节点为例，每个节点完全相互独立不存在主从复制或者其他集群的协调机制。</p>
<p>为了获取锁，客户端应该执行以下操作：</p>
<ol>
<li>获取当前的unix时间，以毫秒为单位</li>
<li>依次尝试从5个实例，使用相同的key和具有唯一性的value例如uuid+threadId获取锁，当想redis请求获取锁的时候，客户端应该设置一个网络连接和响应超时时间，这个响应超时时间应该小于锁的失效时间，例如你的锁的失效时间为10s，则超时时间应该在5-50ms之间。这样能够避免服务器redis已经挂掉的情况下，客户端还在死死的等待响应结果，如果服务没有在规定的时间内响应，客户端应该尽快尝试去另外一个redis实例请求获取锁</li>
<li>客户端使用当前时间减去开始获取锁的时间就是获取锁使用的时间。当且仅当从大多数N/2+1个redis节点都获取锁，并且使用时间小于获取锁的失效时间，锁才算获取成功</li>
<li>如果获得了锁，key的真正有效时间等于有效时间减去获取锁的时间</li>
<li>如果因为某些原因，获取锁失败了，客户端应该在所有的redis实例上解锁，防止某些节点获取到锁但是客户端没有得到响应而导致接下来一段时间不能重新获取锁</li>
</ol>
</li>
<li><p>但是假设我们有5个redis实例a，b，c，d，e，线程A分别加锁，然后a，b，c加锁成功，因为网络分区问题，d，e失败。同时，线程B也加锁，因为网络分区问题，a，b加锁失败，但是d，e加锁成功。这时候，显然线程A会获得锁，但是如果这时候c的master挂了，然后切换成了slave，slave中没有A加锁的信息，恰巧这时线程B对c加锁的命令到了，那线程B就会加锁成功，这时候，线程A和B都给三个节点加锁成功了，他们同时拥有锁。所以我认为redlock仍然没有解决这个问题，只是让这个问题更不容易发生了</p>
<ol>
<li>解决办法指定加锁顺序, 按顺序加锁</li>
</ol>
</li>
</ol>
<p>http状态码</p>
<p>200 状态正确</p>
<p>301 永久的定向</p>
<p>302 临时定向</p>
<p>400  参数错误</p>
<p>410 has gone 路由已经备转移了</p>
<p>500  server error</p>
<p>502 nginx gateway</p>
<p>504 timeout</p>
<h2 id="作业帮面试"><a href="#作业帮面试" class="headerlink" title="作业帮面试"></a>作业帮面试</h2><h4 id="channel是如何使用的"><a href="#channel是如何使用的" class="headerlink" title="channel是如何使用的"></a>channel是如何使用的</h4><h4 id="线程、协程、进程之间的区别"><a href="#线程、协程、进程之间的区别" class="headerlink" title="线程、协程、进程之间的区别"></a>线程、协程、进程之间的区别</h4><p>进程：进程就是应用程序的启动实例，拥有代码和打开的文件资源、数据资源、独立的内存空间。</p>
<p>线程：是进程的执行单位，一个进程至少有一个主线程和多个子线程</p>
<p>对于操作系统来讲，线程是最小的执行单元，进程是最小的资源管理单元</p>
<p>协程：像线程在进程中一样，协程也在线程中拥有自己独立的占空间，不被操作系统内核所管理，而完全是由程序所控制</p>
<h2 id="字节准备"><a href="#字节准备" class="headerlink" title="字节准备"></a>字节准备</h2><h3 id="说说go的优点"><a href="#说说go的优点" class="headerlink" title="说说go的优点"></a>说说go的优点</h3><ol>
<li>go的性能是Python的35倍</li>
<li>性能 （因为golang是机器代码） 编译后的文件可以直接放在机器上执行</li>
<li>开发的过程中 无效的字段或者包名引用 会强制提醒错误，有fmt 统一代码的格式</li>
<li>并发支持  channel和goroutine的性能很出色，可以非常方便的启动一个协程，很容易的生出数百万个goroutine</li>
<li>内置运行时gc，是通过三色法来对垃圾进行回收，可以满足大多数关于垃圾收集的请求</li>
<li>简单易学，非常容易上手</li>
<li>可以返回多个值，虽然java也支持（最多支持三个）</li>
<li>非常节省内存 1.12之前一个goroutinue的内存大概占用2kb，而一个java线程默认是2mb，1.17之后已经改为8kb了</li>
<li>接口的实现非常方便，可以通过内嵌struct来实现继承</li>
<li>if…;… {} 可以将变量的作用域放在if内 很棒</li>
<li>单元测试和并发测试都很方便</li>
</ol>
<p>缺点是</p>
<ol>
<li>缺乏框架、 没有像java那种开发小项目使用springboot springcloud 这种比较成熟的框架、不过对于goweb开发 有beego 、gin等、对于分布式有gomicro、gokit，</li>
<li>错误处理，经常要对错误进行判断 </li>
<li>使用的用法很多坑，比如slice传递的是引用不是副本 ，如果调用的func 不会对slice进行修改传递本身是没问题，如果需要修改就需要考虑使用copy（src，dest）来进行， 如果知道要slice要存储的空间是多少，在初始化的时候要使用 make([]int，nums)来声明，防止在append过程中会发生扩容操作。<br>nil切片、空切片、零切片的区别，var str []int 这种是nil切片 ，序列化之后是null，var str = []int{} 这种是空切片，序列化之后是[] 空数组，零切片就是 make([]int,10) 初始化之后 底层数组存储的数据都是0，官方不推荐创建空切片、也不推荐nil切片和nil进行对比</li>
<li>map中struct的单个字段 是非法的，因为map中的元素是不能寻址的</li>
</ol>
<h3 id="谈谈golang的csp模型"><a href="#谈谈golang的csp模型" class="headerlink" title="谈谈golang的csp模型"></a>谈谈golang的csp模型</h3><p>​    不同于java的通过多线程共享内存来通信，而golang是以通信的方式共享内存，用于描述两个对立并发的实体，通过共享的通信（channel）进行通信的并发模型，而且它还有一个好处，它不关心发送消息的实体，而关心发送消息的channel，channel是可以单独被创建并在线程中进行传递的，类似于boss-worker模式。一个实体通过消息发送到channel中，然后又监听channel的实体处理，两个实体之间是匿名的，这样达到了实体之间的解耦，其中channel是同步的一个消息被发送到channal中，最终一定要被另一个实体消费掉，有些类似于阻塞队列，其实csp的模型底层就是通过goroutinue和channel实现的</p>
<h3 id="说说GMP模型"><a href="#说说GMP模型" class="headerlink" title="说说GMP模型"></a>说说GMP模型</h3><p>G groutinue M workThread processer（上下文或者是cpu）</p>
<p>单核情况下一所有的goroutine都运行在同一个工作线程M0上，每一个工作线程都维护一个上下文P，任何时刻一个上下文只有一个goroutine，其他的goroutine在runqueue中等待，一个goroutinue运行完之后会让出自己的时间片，返回到runqueue中，当运行中的goroutine阻塞时，会再启动一个新的线程M1，P转到新的线程中去执行，当M0返回时，它回尝试从其他的线程中偷取一个上下文过来，如果偷取不到 那么就会被放入到线程缓存中，把自己上面的goroutine都放在global runqueue中，上下文会定期检查global runqueue</p>
<h3 id="死锁产生的四个必要条件"><a href="#死锁产生的四个必要条件" class="headerlink" title="死锁产生的四个必要条件"></a>死锁产生的四个必要条件</h3><ol>
<li>互斥</li>
<li>请求与保持</li>
<li>不可剥夺</li>
<li>循环等待</li>
</ol>
<h3 id="说说goGC的三色法"><a href="#说说goGC的三色法" class="headerlink" title="说说goGC的三色法"></a>说说goGC的三色法</h3><p>初始的时候 gc将引用的对象标记为灰色，然后继续扫描，如果其他对象被这些灰色标记的对象引用就会将灰色对象标记为黑色，然后将被引用的标记为灰色，直到灰色标记的对象不存在，此时gc回收白色对象，最后将黑色对象变为白色对象，并且重复之前所有过程。</p>
<h3 id="gc和用户逻辑是如何并行的呢？"><a href="#gc和用户逻辑是如何并行的呢？" class="headerlink" title="gc和用户逻辑是如何并行的呢？"></a>gc和用户逻辑是如何并行的呢？</h3><p>标记清除法的stw操作就是runtime把所有的线程都冻结掉，这样就意味着所有的用户逻辑都是暂停的，这样所有的对象都不会被修改了，这时候去扫描绝对是安全的，</p>
<p>Go是如何剪短这个过程的呢？标记和清除算法包含两部分逻辑：标记和清除。我们知道golang三色标记法最后只剩下黑色和白色两种对象，如果不碰触黑色对象，只清除白色对象 ，肯定不会影响用户逻辑的 所以：清除操作和用户逻辑是可以并发的。</p>
<p>这个时候你可能会问 那标记是怎么和用户逻辑并发的呢？用户逻辑经常会生成对象或者改变对象的引用，为了解决这个问题 go引入了写屏障：该屏障之前的写操作和之后的写操作相比 ，先被系统其他组件感知，通俗的讲：就是gc跑的过程中，可以监控对象的内存修改，并重新对对象进行标记，在上述的情况中 新生城的对象一律会被标记为灰色。就是说一旦gc开始起来，无论创建对象还是对象的引用改变，都会先变为灰色。</p>
<h3 id="mysql的事务"><a href="#mysql的事务" class="headerlink" title="mysql的事务"></a>mysql的事务</h3><ol>
<li>读未提交</li>
<li>读已提交</li>
<li>可重复读</li>
<li>串行化</li>
</ol>
<h3 id="mysql的脏读、幻读、不可重复读"><a href="#mysql的脏读、幻读、不可重复读" class="headerlink" title="mysql的脏读、幻读、不可重复读"></a>mysql的脏读、幻读、不可重复读</h3><p>脏读是事物A读取到了事物B未提交的数据</p>
<p>幻读：事物A查 select count（1）的两次结果不一致，事物B insert数据 加表锁</p>
<p>不可重复读：事物A 查询的两次row的data数据不一致，事物B 进行delete update 数据  加行锁就可以 mvcc 可解决</p>
<h3 id="mysql的执行顺序"><a href="#mysql的执行顺序" class="headerlink" title="mysql的执行顺序"></a>mysql的执行顺序</h3><p>开始-&gt;FROM子句-&gt;WHERE子句-&gt;GROUP BY子句-&gt;HAVING子句-&gt;ORDER BY子句-&gt;SELECT子句-&gt;LIMIT子句-&gt;最终结果 </p>
<h3 id="当向MySQL发送一个请求的时候，MySQL到底做了什么："><a href="#当向MySQL发送一个请求的时候，MySQL到底做了什么：" class="headerlink" title="当向MySQL发送一个请求的时候，MySQL到底做了什么："></a>当向MySQL发送一个请求的时候，MySQL到底做了什么：</h3><ol>
<li>客户端发送一条查询给服务器。</li>
<li>服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段。</li>
<li>服务器端进行SQL解析、预处理，再由优化器生成对应的执行计划。</li>
<li>MySQL根据优化器生成的执行计划，再调用存储引擎的API来执行查询。</li>
<li>将结果返回给客户端。</li>
</ol>
<h2 id="字节面试"><a href="#字节面试" class="headerlink" title="字节面试"></a>字节面试</h2><h3 id="说说你负责的项目"><a href="#说说你负责的项目" class="headerlink" title="说说你负责的项目"></a>说说你负责的项目</h3><h3 id="redis-主从复制是怎么实现的-master和是slave是如何复制的，谁来触发的"><a href="#redis-主从复制是怎么实现的-master和是slave是如何复制的，谁来触发的" class="headerlink" title="redis 主从复制是怎么实现的 master和是slave是如何复制的，谁来触发的"></a>redis 主从复制是怎么实现的 master和是slave是如何复制的，谁来触发的</h3><ol>
<li>​    slave执行slaveof ip port ，连接master节点</li>
<li>fsync ？ -1 因为不知道runid 和offset </li>
<li>master节点返回runid 和offset </li>
<li>master 执行bgsave 生成rdb文件</li>
<li>发送rdb文件到salve节点</li>
<li>slave记录master节点信息，flush db </li>
<li>发送offset之后queue中的数据</li>
<li>然后加载rdb文件和缓存区中的数据</li>
</ol>
<h3 id="rdb和aof"><a href="#rdb和aof" class="headerlink" title="rdb和aof"></a>rdb和aof</h3><h3 id="mysql是怎么调优的https-studygolang-com-articles-14865"><a href="#mysql是怎么调优的https-studygolang-com-articles-14865" class="headerlink" title="mysql是怎么调优的https://studygolang.com/articles/14865"></a>mysql是怎么调优的<a href="https://studygolang.com/articles/14865">https://studygolang.com/articles/14865</a></h3><ol>
<li>可以使用explain关键字来查看语句的性能</li>
</ol>
<p>all：表示全表查询</p>
<p>range，说明使用的是有范围的索引查询</p>
<p>index： 这里说明使用了索引，这种情况下，如果extra列中的值是Using Index，这种情况是索引覆盖，覆盖索引的含义就是我们要查询的数据，索引都已经存在了，这种情况下就不需要回表取数据了</p>
<p>ref：说明条件使用了索引，但是不是主键和unique，所以即使使用了索引 但是索引值不唯一 存在重复</p>
<p>eq_ref:相当于ref来说就是使用了唯一索引，对于每一个索引的键值，只有唯一的一条匹配记录</p>
<p>const/system :单表中最多有一条匹配行，查询起来非常迅速、所以这个匹配行中的其他列值可以在优化器中当做常量来处理，例如主键或者唯一索引来进行查询。</p>
<p>index_merge :说明使用了索引合并的方法，当使用了索引合并时就说明需要检查下创建的索引是否为单列索引。</p>
<ol start="2">
<li>索引失效的情况<ol>
<li>条件中使用null 或者is not null</li>
<li>使用了%like mysql时左匹配</li>
<li>使用多列索引需要时建立索引的顺序，如果跳过第一个索引直接使用后面的索引，也会导致索引失败，因为mysql时最左匹配</li>
<li>条件中包含or 只有所有列都是单独索引时才会使用索引</li>
</ol>
</li>
<li>如何建立有效的索引<ol>
<li>如果需要索引很长的字符串 此时需要考虑前缀索引</li>
<li>使用多列索引</li>
<li>选择合适的索引顺序</li>
<li>使用覆盖索引  减少select(*)的操作</li>
<li>使用索引扫描来做排序</li>
<li>减少重复冗余已经未使用的索引</li>
<li>减少索引和数据碎片  可以使用optimize table来重新导入或者整理数据</li>
</ol>
</li>
</ol>
<h3 id="mysql-创建索引的语句"><a href="#mysql-创建索引的语句" class="headerlink" title="mysql 创建索引的语句"></a>mysql 创建索引的语句</h3><p>create index index_name on tables(key)</p>
<p>alter table table_name add index(colum_name)</p>
<h3 id="go的sync-下了解吗？说下sync-once-和waitgroup"><a href="#go的sync-下了解吗？说下sync-once-和waitgroup" class="headerlink" title="go的sync 下了解吗？说下sync.once 和waitgroup"></a>go的sync 下了解吗？说下sync.once 和waitgroup</h3><h3 id="lru算法实现"><a href="#lru算法实现" class="headerlink" title="lru算法实现"></a>lru算法实现</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"># 双向链表加hashmap</span><br><span class="line"><span class="keyword">type</span> LinkNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    key, val  <span class="keyword">int</span></span><br><span class="line">    pre, next *LinkNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">    m          <span class="keyword">map</span>[<span class="keyword">int</span>]*LinkNode</span><br><span class="line">    <span class="built_in">cap</span>        <span class="keyword">int</span></span><br><span class="line">    head, tail *LinkNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="mysql和redis的区别"><a href="#mysql和redis的区别" class="headerlink" title="mysql和redis的区别"></a>mysql和redis的区别</h3><h3 id="innodb和myisam的区别"><a href="#innodb和myisam的区别" class="headerlink" title="innodb和myisam的区别"></a>innodb和myisam的区别</h3><ol>
<li>innodb支持事物、myisam不支持事物</li>
<li>innodb支持行锁、myisam支持表锁</li>
<li>innodb时聚集索引 myisam是非聚集索引</li>
<li>innodb支持外键、myisam不支持</li>
<li>innodb 如果select count*  from会全表扫描 myisam不会</li>
</ol>
<h3 id="redis-hash扩容："><a href="#redis-hash扩容：" class="headerlink" title="redis hash扩容："></a>redis hash扩容：</h3><p>单线程渐进式rehash ht[0]，是存放数据的table，作为非扩容时容器。ht[1]，只有正在进行扩容时才会使用，它也是存放数据的table，长度为ht[0]的两倍。<br>扩容时，单线程A负责把数据从ht[0] copy到ht[1] 中。如果这时有其他线程进行读操作：会先去ht[0]中找，找不到再去ht[1]中找。进行写操作：直接写在ht[1]中。进行删除操作：与读类似。<br>多线程协同式rehash，线程A在扩容把数据从oldTable搬到到newTable，这时其他线程，进行get操作：这个线程知道数据存放在oldTable或是newTable中，直接取即可。进行写操作：如果要写的桶位，已经被线程A搬运到了newTable。那么这个线程知道正在扩容，它也一起帮着扩容，扩容完成后才进行put操作，进行删除操作：与写一致。</p>
<h3 id="redis-redlock-实现原理-为什么需要这个"><a href="#redis-redlock-实现原理-为什么需要这个" class="headerlink" title="redis redlock 实现原理 为什么需要这个"></a>redis redlock 实现原理 为什么需要这个</h3><p>因为单节点redis nx 会存在丢失的可能性、为了防止锁丢失需要重新获取</p>
<h3 id="session和cookie的区别是什么？"><a href="#session和cookie的区别是什么？" class="headerlink" title="session和cookie的区别是什么？"></a>session和cookie的区别是什么？</h3><ol>
<li>由于HTTP协议是无状态的协议，在需要持久化用户的状态时，需要某种机制来识别，session是放在服务端的，cookie是放在客户端的。</li>
<li>第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。</li>
<li>Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。</li>
</ol>
<h3 id="说说视频聊天的这个项目-还有luck-quiz的这个项目"><a href="#说说视频聊天的这个项目-还有luck-quiz的这个项目" class="headerlink" title="说说视频聊天的这个项目 还有luck quiz的这个项目"></a>说说视频聊天的这个项目 还有luck quiz的这个项目</h3><p>new-meet是用户通过购买金币来和线上主播进行一对一视频聊天的服务、同时会采用通话流转、假主播流量吸引、勾引话术推送消息来吸引用户进行直播。我主要前期参与了用户模块、用户和主播like模块的设计、视频通话的过程梳理、已经近期对优质主播的流向倾斜和新主播流量扶持策略的设计。用户模块设计了限制用户单点登录，对jwt进行了简化，将用户id、过期时间、用户设备id 通过aes加密生成一个authkey、每次用户请求需要再header中添加入authkey、然后解密出来，使用责任链模式，通过设计router的正则来校验authkey，比如有些拉取数据通道的接口是和 用户无关的，就不需要校验authkey。 这个业务最主要的通话流程的设计，然后最近为了提升通话的时间和接通率 我又设计了一个主播流量倾斜和新主播流量扶持的策略。前期因为印度市场被下架 我们又设计了一个异构的框架、所有的请求被客户端加密之后，然后再异构框架进行解密 没有问题再发送到我真正的server服务。这样google是不知道我们在传输过程中因为壳包相似的接口名称和参数而进行app封杀下架。</p>
<p>luck_quiz项目是基于beego框架研发的，主要有用户模块、答题、乐透、幸运转盘、刮刮卡兑换模块组成、用户可以在参与玩游戏的过程中获取金币、现金奖励，然后兑换aws或者paypal的充值卡。我们是在用户游戏的过程中通过查看奖励添或者解锁游戏次数来添加广告进行获利、其中我负责的是整个产品的研发的推动、其中答题模块是相对复杂的。</p>
<p>题目生成的策略是相对复杂的，题目本身有几个纬度的、难度、题目类型、奖励类型、初期用户拉取的题目是相对简单的，然后出现现金奖励的概率也会很大、然后需要每个人生成的题目不要和其他人一样，用户的现金到0-4、4-8、8-12、12以上、现金出现的奖励会越来越小直至不出现、同时题目的难度也会越来越难。这就需要我们每次再生成题目列表的时候实时计算了。<br>方案一： 使用mysql not in（性能太差）<br>方案二： 了解到 其实是给用户下发的题目和题库的题目做差集，使用redis sdiff 命令 redis key是这样的，因为sdiff key1 key2 ，<br>key1 key2 如果不在同一个slot上，就会发出redis 错误，所以开始用{}，先计算key的hash，将answer 用{}括起来，使其<br>落在同一个slot上,题库的题目 {answer}:load-questions:%questionType ,用户看过的题目 {answer}:load-questions-by:%userId<br>能到达预期目的<br>方案三： 方案二虽然能达到预期目的，但是随着</p>
<p>用户量的增加、单个slot的容量总是有限的，所以在用户注册的时候，给每个用户都会将题库复制一份，<br>rediskey 与userId进行绑定,题库的题目 answer:load-questions:{userId}:questionType ,用户看过的题目 answer:load-questions-by:{userId}<br>这样解决了单个slot内存过于庞大的问题这个还有一个好处就是差集的计算都交给了redis 的机器去操作<br>方案四：使用bitset 指令 SETBIT key offset value 复杂度 O(1)<br>一个bit位来表示某个元素对应的值或者状态,其中的key就是对应元素本身。我们知道8个bit可以组成一个Byte，所以bitmap本身会极大的节省储存空间。之前存储一个questionId是int64类型 ，大概的空间占用计算公式是：($offset/8/1024/1024)MB，也就是说8388608 个题目在redis里才会占用1mb的内存空间， offset 标识题目id，0 标识未打过，1标识已经答过。 Xor</p>
<h3 id="说说你觉得收获最大的项目是哪个-怎么去处理的"><a href="#说说你觉得收获最大的项目是哪个-怎么去处理的" class="headerlink" title="说说你觉得收获最大的项目是哪个 怎么去处理的"></a>说说你觉得收获最大的项目是哪个 怎么去处理的</h3><p>答题的这个模块吧，当时是使用火焰图对这个接口进行了分析 go tool pprof -http=:8080 火焰图文件，解析数据生成调用栈、分析程序响应变慢时，哪个函数占据了更多的处理时间。可以更直观的定位问题，因为再涉及到接口优化的过程中、发现了之前封装go公共基础库的性能不好、然后自己做了优化、接口的响应时间从2s优化到了300ms。 还有对go字符串调优也做了一个测试，字符串拼接、fmt.Sprintf、stringbuilder、byte.buff 来处理，使用go test -bench=. -run=none 可以看出StringBuilder是最快的 899 ns/op， bytes.buffer次之，string += 拼的方式性较差，fmt.Sprintf()的方式性能最差是17347 ns/op。，你可以使用bytes.Buffer来优化：一定程度上避免上面每进行一次拼接操作就重新申请新的内存空间存放中间字符串的问题。但这里依然有一个小问题： byte.String() 会有一次 []byte -&gt; string 类型转换。而这个操作是会进行一次内存分配和内容拷贝的。<br><br>如果你现在已经在使用 golang 1.10, 那么你还有一个更好的选择：strings.Builder</p>
<ul>
<li>1、与byte.Buffer思路类似，既然 string 在构建过程中会不断的被销毁重建，那么就尽量避免这个问题，底层使用一个 buf []byte 来存放字符串的内容。</li>
<li>2、对于写操作，就是简单的将byte写入到 buf 即可。</li>
<li>3、为了解决bytes.Buffer.String()存在的[]byte -&gt; string类型转换和内存拷贝问题，这里使用了一个unsafe.Pointer的存指针转换操作，实现了直接将buf []byte转换为 string类型，同时避免了内存充分配的问题</li>
</ul>
<p>结论：<br></p>
<ul>
<li>golang中的string类型也是只读且不可变的。因此，这种拼接字符串的方式会导致大量的string创建、销毁和内存分配。如果你拼接的字符串比较多的话，这显然不是一个正确的姿势。</li>
<li>fmt.springf() 内部使用 []byte 实现，不像直接运算符这种会产生很多临时的字符串，但是内部的逻辑比较复杂，有很多额外的判断，还用到了 interface</li>
<li>go1.10之前推荐使用buffer 、go1.10以后推荐使用builder</li>
</ul>
<h3 id="常用算法的时间复杂度"><a href="#常用算法的时间复杂度" class="headerlink" title="常用算法的时间复杂度"></a>常用算法的时间复杂度</h3><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><table>
<thead>
<tr>
<th align="left">算法</th>
<th align="left">数据结构</th>
<th align="left">时间复杂度</th>
<th align="left">最坏情况下的辅助空间复杂度</th>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left"></td>
<td align="left"></td>
<td align="left">最佳</td>
<td align="left">平均</td>
<td align="left">最差</td>
<td align="left">最差</td>
</tr>
<tr>
<td align="left"><a href="http://en.wikipedia.org/wiki/Quicksort">快速排序</a></td>
<td align="left">数组</td>
<td align="left"><code>O(n log(n))</code></td>
<td align="left"><code>O(n log(n))</code></td>
<td align="left"><code>O(n^2)</code></td>
<td align="left"><code>O(n)</code></td>
</tr>
<tr>
<td align="left"><a href="http://en.wikipedia.org/wiki/Merge_sort">归并排序</a></td>
<td align="left">数组</td>
<td align="left"><code>O(n log(n))</code></td>
<td align="left"><code>O(n log(n))</code></td>
<td align="left"><code>O(n log(n))</code></td>
<td align="left"><code>O(n)</code></td>
</tr>
<tr>
<td align="left"><a href="http://en.wikipedia.org/wiki/Heapsort">堆排序</a></td>
<td align="left">数组</td>
<td align="left"><code>O(n log(n))</code></td>
<td align="left"><code>O(n log(n))</code></td>
<td align="left"><code>O(n log(n))</code></td>
<td align="left"><code>O(1)</code></td>
</tr>
<tr>
<td align="left"><a href="http://en.wikipedia.org/wiki/Bubble_sort">冒泡排序</a></td>
<td align="left">数组</td>
<td align="left"><code>O(n)</code></td>
<td align="left"><code>O(n^2)</code></td>
<td align="left"><code>O(n^2)</code></td>
<td align="left"><code>O(1)</code></td>
</tr>
<tr>
<td align="left"><a href="http://en.wikipedia.org/wiki/Insertion_sort">插入排序</a></td>
<td align="left">数组</td>
<td align="left"><code>O(n)</code></td>
<td align="left"><code>O(n^2)</code></td>
<td align="left"><code>O(n^2)</code></td>
<td align="left"><code>O(1)</code></td>
</tr>
<tr>
<td align="left"><a href="http://en.wikipedia.org/wiki/Selection_sort">选择排序</a></td>
<td align="left">数组</td>
<td align="left"><code>O(n^2)</code></td>
<td align="left"><code>O(n^2)</code></td>
<td align="left"><code>O(n^2)</code></td>
<td align="left"><code>O(1)</code></td>
</tr>
<tr>
<td align="left"><a href="http://en.wikipedia.org/wiki/Bucket_sort">桶排序</a></td>
<td align="left">数组</td>
<td align="left"><code>O(n+k)</code></td>
<td align="left"><code>O(n+k)</code></td>
<td align="left"><code>O(n^2)</code></td>
<td align="left"><code>O(nk)</code></td>
</tr>
<tr>
<td align="left"><a href="http://en.wikipedia.org/wiki/Radix_sort">基数排序</a></td>
<td align="left">数组</td>
<td align="left"><code>O(nk)</code></td>
<td align="left"><code>O(nk)</code></td>
<td align="left"><code>O(nk)</code></td>
<td align="left"><code>O(n+k)</code></td>
</tr>
</tbody></table>
<p>探探</p>
<ol>
<li>一亿个数找10个重复出现最多的 桶排序 </li>
<li>301 302 304 405 http状态<ol>
<li>301 永久</li>
<li>302 临时</li>
<li>304 ）服务器端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回304Modified（服务器端资源未改变，可直接使用客户端未过期的缓存）</li>
<li>405 method not allowed ，请求的方法不对 </li>
<li>415 请求的content-type不支持</li>
</ol>
</li>
<li>客户端主动断开还是服务端主动断开 通过tcp的状态可以判断</li>
<li>zookper注意事项</li>
</ol>
<p>京东一面：</p>
<p>redis 主从同步</p>
<p>lru实现</p>
<p>csp</p>
<p>gmp</p>
<p>三色回收算法</p>
<p>golang的内存分配</p>
<h3 id="Go内存分配流程总结"><a href="#Go内存分配流程总结" class="headerlink" title="Go内存分配流程总结"></a>Go内存分配流程总结</h3><p>对象分三种：</p>
<ul>
<li>微小对象，size &lt; 16B</li>
<li>一般小对象， 16 bytes &lt; size &lt;= 32k</li>
<li>大对象 size &gt; 32k</li>
</ul>
<p>分配方式分三种：</p>
<ul>
<li>tinny allocations (size &lt; 16 bytes，no pointers) 微型分配器分配。</li>
<li>small allocations ( size &lt;= 32k) 正常分配；首先通过计算使用的大小规格，然后使用 mcache 中对应大小规格的块分配</li>
<li>large allocations (size &gt; 32k) 大对象分配；直接通过<code>mheap</code>分配。这些大对象的申请是以一个全局锁为代价的，因此任何给定的时间点只能同时供一个 P 申请。</li>
</ul>
<p>对象分配：</p>
<ul>
<li>size范围在在( size &lt; 16B)，不包含指针的对象。 <code>mcache</code>上的微型分配器分配</li>
<li>size范围在(0 &lt; size &lt; 16B)， 包含指针的对象：正常分配</li>
<li>size范围在(16B &lt; size &lt;= 32KB)， : 正常分配</li>
<li>size范围在( size &gt; 32KB) : 大对象分配</li>
</ul>
<p>分配顺序：</p>
<ul>
<li>首先通过计算使用的大小规格。</li>
<li>然后使用<code>mcache</code>中对应大小规格的块分配。</li>
<li>如果<code>mcentral</code>中没有可用的块，则向<code>mheap</code>申请，并根据算法找到最合适的<code>mspan</code>。</li>
<li>如果申请到的<code>mspan</code> 超出申请大小，将会根据需求进行切分，以返回用户所需的页数。剩余的页构成一个新的 mspan 放回 mheap 的空闲列表。</li>
<li>如果 mheap 中没有可用 span，则向操作系统申请一系列新的页（最小 1MB）。</li>
</ul>
<p>Go的内存分配的核心思想可以分为以下几点：</p>
<ul>
<li>每次从操作系统申请一大块儿的内存，由Go来对这块儿内存做分配，减少系统调用</li>
<li>内存分配算法采用Google的<code>TCMalloc算法</code>。算法比较复杂，究其原理可自行查阅。其核心思想就是把内存切分的非常的细小，分为多级管理，以降低锁的粒度。</li>
<li>回收对象内存时，并没有将其真正释放掉，只是放回预先分配的大块内存中，以便复用。只有内存闲置过多的时候，才会尝试归还部分内存给操作系统，降低整体开销</li>
</ul>
<h4 id="内存管理组件"><a href="#内存管理组件" class="headerlink" title="内存管理组件"></a>内存管理组件</h4><p>go的内存管理组件主要有：<code>mspan</code>、<code>mcache</code>、<code>mcentral</code>和<code>mheap</code></p>
<ul>
<li><code>mspan</code>为内存管理的基础单元，直接存储数据的地方。</li>
<li><code>mcache</code>：每个运行期的goroutine都会绑定的一个<code>mcache</code>(具体来讲是绑定的GMP并发模型中的P，所以可以无锁分配<code>mspan</code>，后续还会说到)，<code>mcache</code>会分配goroutine运行中所需要的内存空间(即<code>mspan</code>)。</li>
<li><code>mcentral</code>为所有<code>mcache</code>切分好后备的<code>mspan</code></li>
<li><code>mheap</code>代表Go程序持有的所有堆空间。还会管理闲置的span，需要时向操作系统申请新内存。</li>
</ul>
<p>字节教育</p>
<p>如何判断一个channel是否关闭</p>
<p>interface和nil怎么判断</p>
<p>interface的底层是什么</p>
<p>redlock 解决什么问题 还存在什么问题</p>
<p>分布式锁还有其他的解决办法吗，mysql和zk怎么实现的</p>
<p>java中的引用有哪些 四种 强 弱 虚 软</p>
<p>jd</p>
<p>多线程打印</p>
<p>两个字符串最长公共子串</p>
<p>csp</p>
<p>三色回收算法</p>
<p>GMP</p>
<p>注册中心的原理是什么</p>
<p>微服务之间消息通信使用的协议</p>
<p>zookper是如何注册提供服务的</p>
<h3 id="滴滴："><a href="#滴滴：" class="headerlink" title="滴滴："></a>滴滴：</h3><h4 id="redis集群如何扩展"><a href="#redis集群如何扩展" class="headerlink" title="redis集群如何扩展"></a>redis集群如何扩展</h4><p>已有集群为6个节点127.0.0.1:7000 - 127.0.0.1:7005，3组主从节点。现要增加第4组主从节点127.0.0.1:7006，127.0.0.1:7007.</p>
<p>1.创建一个新的主节点127.0.0.1:7006。命令里需要指定一个已有节点以便于获取集群信息，本例是指定的127.0.0.1:7000。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster add-node 127.0.0.1:7006 127.0.0.1:7000</span><br></pre></td></tr></table></figure>

<p>2.将127.0.0.1:7007创建为127.0.0.1:7006的从节点。命令里需要指定一个已有节点以便于获取集群信息，本例是指定的127.0.0.1:7000。因为，集群会自动为从节点数最少的主节点创建从节点，所以这里不需要指定主节点。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster add-node 127.0.0.1:7007 127.0.0.1:7000 --cluster-slave</span><br></pre></td></tr></table></figure>

<p>当然也可以指定主节点</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster add-node 127.0.0.1:7007 127.0.0.1:7000 --cluster-slave --cluster-master-id e44678abed249e22482559136bf45280fd3ac281</span><br></pre></td></tr></table></figure>

<p>7006的node ID可以由如下命令获取</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@dev redis-cluster]# ./redis-cli -p 7006 cluster nodes | grep myself</span><br><span class="line">e44678abed249e22482559136bf45280fd3ac281 127.0.0.1:7006@17006 myself,master - 0 1586936487000 0 connected</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>reshard slots. 因为redis 5现在还不支持自动平衡slot，所以需要自行计算需要移动的slot数量，并手动执行命令。这个例子，需要从3组已有的主节点上各移动1365个slot到新的主节点127.0.0.1:7006，以达到均衡。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster reshard 127.0.0.1:7000 --cluster-from e1a033e07f0064e6400825b4ddbcd6680c032d10 --cluster-to e44678abed249e22482559136bf45280fd3ac281 --cluster-slots 1365 --cluster-yes</span><br><span class="line">redis-cli --cluster reshard 127.0.0.1:7000 --cluster-from ad2f42a9068b6b7d11174f6770ae4d51e4f536d6 --cluster-to e44678abed249e22482559136bf45280fd3ac281 --cluster-slots 1365 --cluster-yes</span><br><span class="line">redis-cli --cluster reshard 127.0.0.1:7000 --cluster-from dbf8c247a5657b7a78890becb94a22f3482f5eca --cluster-to e44678abed249e22482559136bf45280fd3ac281 --cluster-slots 1365 --cluster-yes</span><br></pre></td></tr></table></figure>

<p>需要指出的是上述3条命令不能放在一个脚本里连续执行，需要间隔一定时间，否则集群可能会报错：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ERR] Nodes don&#x27;t agree about configuration!</span><br></pre></td></tr></table></figure>

<p>4.reshard完成后，查看集群状态，可以看到127.0.0.1:7006作为主节点存储了3段slot分别是 0-1364 5461-6825 10923-12287</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:7000&gt; cluster nodes</span><br><span class="line">5ca679d3fa5606d8c247595fc4eca622e6ec962c 127.0.0.1:7004@17004 slave e1a033e07f0064e6400825b4ddbcd6680c032d10 0 1586938032000 5 connected</span><br><span class="line">ad2f42a9068b6b7d11174f6770ae4d51e4f536d6 127.0.0.1:7003@17003 master - 0 1586938031000 8 connected 6826-10922</span><br><span class="line">620320cd85531d16f9508cf4c55c283186b3febb 127.0.0.1:7001@17001 slave ad2f42a9068b6b7d11174f6770ae4d51e4f536d6 0 1586938031875 8 connected</span><br><span class="line">dbf8c247a5657b7a78890becb94a22f3482f5eca 127.0.0.1:7005@17005 master - 0 1586938032375 7 connected 1365-5460</span><br><span class="line">cbb1740c5affb7e1d688d8433a9c7df70e87ecd7 127.0.0.1:7000@17000 myself,slave dbf8c247a5657b7a78890becb94a22f3482f5eca 0 1586938031000 1 connected</span><br><span class="line">391d622c24df9121b3c712c0d8a97ca985783ac3 127.0.0.1:7007@17007 slave e44678abed249e22482559136bf45280fd3ac281 0 1586938031000 9 connected</span><br><span class="line">e44678abed249e22482559136bf45280fd3ac281 127.0.0.1:7006@17006 master - 0 1586938031574 9 connected 0-1364 5461-6825 10923-12287</span><br><span class="line">e1a033e07f0064e6400825b4ddbcd6680c032d10 127.0.0.1:7002@17002 master - 0 1586938032375 3 connected 12288-16383</span><br></pre></td></tr></table></figure>

<h4 id="redis-缓存穿透-击穿-血崩"><a href="#redis-缓存穿透-击穿-血崩" class="headerlink" title="redis 缓存穿透 击穿 血崩"></a>redis 缓存穿透 击穿 血崩</h4><ol>
<li>redis 穿透<ol>
<li>什么是？是指缓存和数据库中都没有的数据，而用户不断发起请求，我们数据库的 id 都是1开始自增上去的，如发起为id值为 -1 的数据或 id 为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大，严重会击垮数据库。</li>
<li>如何避免：我会在接口层增加校验，比如用户鉴权校验，参数做校验，不合法的参数直接代码Return，比如：id 做基础校验，id &lt;=0的直接拦截等 <ol>
<li>缓存空值，然后设置一个较短的过期时间</li>
<li>使用布隆过滤器：说法一：使用布隆过滤器,将所有可能存在的数据哈希到一个足够大的bitmap中,一定不存在与数据库的数据会被这个bitmap拦截掉。说法二：当一个查询请求过来，先经过布隆过滤器进行查，如果判断请求查询值存在 则继续查，如果判断查询的请求值不存在，直接丢弃</li>
</ol>
</li>
</ol>
</li>
<li>redis击穿<ol>
<li>什么是？缓存中没有数据但数据库中有。由于并发用户特别多同时，没有读取到数据，都同时去数据库取数据。造成数据库压力瞬间增大。</li>
<li>解决：<ol>
<li>热点数据永不过期</li>
<li>加分布式锁</li>
<li>设置一个watcher进行锁续期</li>
</ol>
</li>
</ol>
</li>
<li>redis 雪崩<ol>
<li>什么是？某一个时间段里缓存集中过期失效。</li>
<li>解决： 不同的对象设置不同的过期时间,或者过期时间加一个随机因子,尽量分散时间</li>
</ol>
</li>
</ol>
<h4 id="如何熔断"><a href="#如何熔断" class="headerlink" title="如何熔断"></a>如何熔断</h4><p><strong>降级一般而言指的是我们自身的系统出现了故障而降级。而熔断一般是指依赖的外部接口出现故障的情况断绝和外部接口的关系。</strong></p>
<p>例如你的A服务里面的一个功能依赖B服务，这时候B服务出问题了，返回的很慢。这种情况可能会因为这么一个功能而拖慢了A服务里面的所有功能，因此我们这时候就需要熔断！即当发现A要调用这B时就直接返回错误(或者返回其他默认值啊啥的)，就不去请求B了。我这还是举了两个服务的调用，有些那真的是一环扣一环，出问题不熔断，那真的是会雪崩。</p>
<h4 id="如何限流"><a href="#如何限流" class="headerlink" title="如何限流"></a>如何限流</h4><p>​    方法：漏桶和令牌桶</p>
<p>​     核心的三个方法：</p>
<ol>
<li>wait/waitN  当使用 Wait 方法消费 Token 时，如果此时桶内 Token 数组不足 (小于 N)，那么 Wait 方法将会<strong>阻塞</strong>一段时间，直至 Token 满足条件。如果充足则直接返回。</li>
<li>allow/allowN 截止到某一时刻，目前桶中数目是否至少为 n 个，满足则返回 true，同时从桶中消费 n 个 token。反之返回不消费 Token，false。 通常对应这样的线上场景，如果请求速率过快，就直接丢掉某些请求。</li>
<li>reserve/reserveN</li>
</ol>
<p>总结起来：如果要让自己的系统不被打垮，用令牌桶。如果保证被别人的系统不被打垮，用漏桶算法。</p>
<h4 id="负载均衡得方式有哪些"><a href="#负载均衡得方式有哪些" class="headerlink" title="负载均衡得方式有哪些"></a>负载均衡得方式有哪些</h4><ol>
<li>​    算法：<ol>
<li>轮询法</li>
<li>随机</li>
<li>源地址hash</li>
<li>加权轮询</li>
<li>加权随机 与加权轮询法一样，加权随机法也根据后端机器的配置，系统的负载分配不同的权重。不同的是，它是按照权重随机请求后端服务器，而非顺序。</li>
<li>最小连接数 最小连接数算法比较灵活和智能，由于后端服务器的配置不尽相同，对于请求的处理有快有慢，它是根据后端服务器当前的连接情况，动态地选取其中当前 积压连接数最少的一台服务器来处理当前的请求，尽可能地提高后端服务的利用效率，将负责合理地分流到每一台服务器。</li>
</ol>
</li>
<li>实现方式<ol>
<li>重定向</li>
<li>反向代理</li>
<li>数据链路返回</li>
</ol>
</li>
</ol>
<p>redis redlock解决了什么问题 还有什么问题<br>redis slot为什么要是16384个<br>你项目的技术难点是什么</p>
<p>学而思：</p>
<p>zookper的注册发现</p>
<p>移出node如何通知client</p>
<p>gmp模型 goroutine阻塞会创建新的线程吗</p>
<p>redis rehash是主线程执行的，只不过每次会复制一点</p>
<p>redis 删除set 大量元素时 可以异步执行 only。。。</p>
<p>nginx是进程还是线程  master-worker模式</p>
<p>redis hash的底层</p>
<p>redis hash或者set 移出一千万哥元素怎么操作呢</p>
<p>如何平滑升级</p>
<p>defer recover  能捕捉到其他协程的panic吗  不能 只能监听当前协程的</p>
<p>context包 todo cancel timeout的底层实现</p>
<p>redis的集群模式有哪些</p>
<p>分布式锁的实现 redis和zk还有mysql</p>
<p>slice底层的坑</p>
<p>使用过哪些锁</p>
<p>waitgroup的原理</p>
<p>redis cli 指定一个机器 或者的key不在当前节点怎么处理？ proxy 提前计算出这个key</p>
<p>秒杀如何设计？限流</p>
<h2 id="最右"><a href="#最右" class="headerlink" title="最右"></a>最右</h2><p>jwt原理</p>
<p>currenthashmap原理</p>
<p>mysql死锁</p>
<p>cas原理 CAS是英文单词<strong>CompareAndSwap</strong>的缩写，中文意思是：比较并替换。CAS需要有3个操作数：内存地址V，旧的预期值A，即将要更新的目标值B。</p>
<p>synchronize原理</p>
<p>i++ 的从内核考虑</p>
]]></content>
      <categories>
        <category>知识必备</category>
      </categories>
      <tags>
        <tag>知识必备</tag>
      </tags>
  </entry>
</search>
