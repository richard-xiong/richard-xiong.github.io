<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XingServer</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://richard-xiong.github.io/"/>
  <updated>2020-08-09T13:49:52.060Z</updated>
  <id>https://richard-xiong.github.io/</id>
  
  <author>
    <name>Richard</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="https://richard-xiong.github.io/2020/08/09/hello-world/"/>
    <id>https://richard-xiong.github.io/2020/08/09/hello-world/</id>
    <published>2020-08-09T13:48:37.159Z</published>
    <updated>2020-08-09T13:49:52.060Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>连接mysql的脚本</title>
    <link href="https://richard-xiong.github.io/2020/08/07/%E8%BF%9E%E6%8E%A5mysql%E7%9A%84%E8%84%9A%E6%9C%AC/"/>
    <id>https://richard-xiong.github.io/2020/08/07/%E8%BF%9E%E6%8E%A5mysql%E7%9A%84%E8%84%9A%E6%9C%AC/</id>
    <published>2020-08-06T22:29:04.000Z</published>
    <updated>2020-08-09T13:49:52.066Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h3><p><code>mysql的服务器地址： 127.0.0.1  mysql的端口: 3306 mysql的用户: root mysq的密码: abcdefg</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql -h 127.0.0.1 -P 3306 -u root  -pabcdefg databaseName;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基本属性&quot;&gt;&lt;a href=&quot;#基本属性&quot; class=&quot;headerlink&quot; title=&quot;基本属性&quot;&gt;&lt;/a&gt;基本属性&lt;/h3&gt;&lt;p&gt;&lt;code&gt;mysql的服务器地址： 127.0.0.1  mysql的端口: 3306 mysql的用户: root my
      
    
    </summary>
    
    
      <category term="linux" scheme="https://richard-xiong.github.io/categories/linux/"/>
    
      <category term="mysql" scheme="https://richard-xiong.github.io/categories/linux/mysql/"/>
    
    
      <category term="shell" scheme="https://richard-xiong.github.io/tags/shell/"/>
    
      <category term="mysql" scheme="https://richard-xiong.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>k8s--pod的状态为evicted</title>
    <link href="https://richard-xiong.github.io/2020/08/07/k8s-pod%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%BAevicted/"/>
    <id>https://richard-xiong.github.io/2020/08/07/k8s-pod%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%BAevicted/</id>
    <published>2020-08-06T22:08:43.000Z</published>
    <updated>2020-08-09T13:49:52.068Z</updated>
    
    <content type="html"><![CDATA[<h3 id="遇到问题–k8s–pod的状态为evicted"><a href="#遇到问题–k8s–pod的状态为evicted" class="headerlink" title="遇到问题–k8s–pod的状态为evicted"></a>遇到问题–k8s–pod的状态为evicted</h3><p>eviction，即驱赶的意思，意思是当节点出现异常时，kubernetes将有相应的机制驱赶该节点上的Pod。多见于资源不足时导致的驱赶。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>排查资源和异常原因，防止新的驱赶产生。使用如下命令删除旧驱赶的遗留</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods | grep Evicted | awk &#x27;&#123;print $1&#125;&#x27; | xargs kubectl delete pod</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;遇到问题–k8s–pod的状态为evicted&quot;&gt;&lt;a href=&quot;#遇到问题–k8s–pod的状态为evicted&quot; class=&quot;headerlink&quot; title=&quot;遇到问题–k8s–pod的状态为evicted&quot;&gt;&lt;/a&gt;遇到问题–k8s–pod的状态为e
      
    
    </summary>
    
    
      <category term="k8s" scheme="https://richard-xiong.github.io/categories/k8s/"/>
    
    
      <category term="linux" scheme="https://richard-xiong.github.io/tags/linux/"/>
    
      <category term="k8s" scheme="https://richard-xiong.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>寻找数组的中心索引</title>
    <link href="https://richard-xiong.github.io/2020/08/07/leetcode%20%E6%95%B0%E7%BB%84-%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E7%B4%A2%E5%BC%95/"/>
    <id>https://richard-xiong.github.io/2020/08/07/leetcode%20%E6%95%B0%E7%BB%84-%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E7%B4%A2%E5%BC%95/</id>
    <published>2020-08-06T22:08:43.000Z</published>
    <updated>2020-08-09T13:49:52.069Z</updated>
    
    <content type="html"><![CDATA[<p>###</p><h3 id="寻找数组的中心索引"><a href="#寻找数组的中心索引" class="headerlink" title="寻找数组的中心索引"></a>寻找数组的中心索引</h3><p>给定一个整数类型的数组 nums，请编写一个能够返回数组 “中心索引” 的方法。</p><p>我们是这样定义数组 中心索引 的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。</p><p>如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。</p><p>示例 1：</p><p>输入：<br>nums = [1, 7, 3, 6, 5, 6]<br>输出：3<br>解释：<br>索引 3 (nums[3] = 6) 的左侧数之和 (1 + 7 + 3 = 11)，与右侧数之和 (5 + 6 = 11) 相等。<br>同时, 3 也是第一个符合要求的中心索引。<br>示例 2：</p><p>输入：<br>nums = [1, 2, 3]<br>输出：-1<br>解释：<br>数组中不存在满足此条件的中心索引。</p><p>说明：</p><p>nums 的长度范围为 [0, 10000]。<br>任何一个 nums[i] 将会是一个范围在 [-1000, 1000]的整数。</p><p>Go</p><p>作者：力扣 (LeetCode)<br>链接：<a href="https://leetcode-cn.com/leetbook/read/array-and-string/yf47s/">https://leetcode-cn.com/leetbook/read/array-and-string/yf47s/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">解法一</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pivotIndex</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    result:=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> result &lt; <span class="built_in">len</span>(nums) &#123;</span><br><span class="line"></span><br><span class="line">        left:=<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span>&#123;</span><br><span class="line">            <span class="keyword">var</span> sum <span class="keyword">int</span></span><br><span class="line">            <span class="keyword">for</span> _,item :=<span class="keyword">range</span> nums[<span class="number">0</span>:result] &#123;</span><br><span class="line">                sum+=item</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum</span><br><span class="line">        &#125;</span><br><span class="line">        right:=<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span>&#123;</span><br><span class="line">            <span class="keyword">var</span> sum <span class="keyword">int</span></span><br><span class="line">            <span class="keyword">for</span> _,item  :=<span class="keyword">range</span> nums[result+<span class="number">1</span>:] &#123;</span><br><span class="line">                sum+=item</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> right() == left() &#123;</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">        result ++</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行结果：</p><p>通过</p><p>显示详情</p><p>执行用时：336 ms, 在所有 Go 提交中击败了6.46%的用户</p><p>内存消耗：5.8 MB, 在所有 Go 提交中击败了93.18%的用户</p><p>方法二：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pivotIndex</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    result := <span class="number">0</span></span><br><span class="line">    readAll := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        gte0 := <span class="literal">false</span></span><br><span class="line">        lte0 := <span class="literal">false</span></span><br><span class="line">        <span class="keyword">for</span> _, item := <span class="keyword">range</span> nums &#123;</span><br><span class="line">            <span class="keyword">if</span> item &gt;= <span class="number">0</span> &#123;</span><br><span class="line">                gte0 = <span class="literal">true</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lte0 = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> gte0 &amp;&amp; lte0 &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    loadAll := readAll()</span><br><span class="line">    <span class="keyword">for</span> result &lt; <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">        <span class="keyword">var</span> left <span class="keyword">int</span></span><br><span class="line">        <span class="keyword">var</span> right <span class="keyword">int</span></span><br><span class="line">        <span class="keyword">if</span> result &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> _, item := <span class="keyword">range</span> nums[:result] &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> item == <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">                left += item</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> _, item := <span class="keyword">range</span> nums[result+<span class="number">1</span>:] &#123;</span><br><span class="line">            <span class="keyword">if</span> item == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            right += item</span><br><span class="line">            <span class="keyword">if</span> right &gt; left &amp;&amp; !loadAll &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> left == right &#123;</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">        result++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显示详情</p><p>执行用时：424 ms, 在所有 Go 提交中击败了5.26%的用户</p><p>内存消耗：5.8 MB, 在所有 Go 提交中击败了100.00%的用户</p><p>解法三：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pivotIndex</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> _,item:=<span class="keyword">range</span> nums &#123;</span><br><span class="line">        sum+=item</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> leftSum <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> index,item:=<span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> leftSum==sum-item-leftSum &#123;</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">        &#125;</span><br><span class="line">        leftSum+=item</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：24 ms, 在所有 Go 提交中击败了82.78%的用户</p><p>内存消耗：6 MB, 在所有 Go 提交中击败了86.36%的用户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###&lt;/p&gt;
&lt;h3 id=&quot;寻找数组的中心索引&quot;&gt;&lt;a href=&quot;#寻找数组的中心索引&quot; class=&quot;headerlink&quot; title=&quot;寻找数组的中心索引&quot;&gt;&lt;/a&gt;寻找数组的中心索引&lt;/h3&gt;&lt;p&gt;给定一个整数类型的数组 nums，请编写一个能够返回数组 “中
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://richard-xiong.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="https://richard-xiong.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/leetcode/"/>
    
      <category term="数组" scheme="https://richard-xiong.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="algorithm" scheme="https://richard-xiong.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>合并区间</title>
    <link href="https://richard-xiong.github.io/2020/08/07/leetcode%20%E6%95%B0%E7%BB%84-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/"/>
    <id>https://richard-xiong.github.io/2020/08/07/leetcode%20%E6%95%B0%E7%BB%84-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/</id>
    <published>2020-08-06T22:08:43.000Z</published>
    <updated>2020-08-11T03:12:37.102Z</updated>
    
    <content type="html"><![CDATA[<h3 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h3><p>给出一个区间的集合，请合并所有重叠的区间。</p><p>示例 1:</p><p>输入: [[1,3],[2,6],[8,10],[15,18]]<br>输出: [[1,6],[8,10],[15,18]]<br>解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].<br>示例 2:</p><p>输入: [[1,4],[4,5]]<br>输出: [[1,5]]<br>解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。</p><p>Go</p><p>作者：力扣 (LeetCode)<br>链接：<a href="https://leetcode-cn.com/leetbook/read/array-and-string/c5tv3/">https://leetcode-cn.com/leetbook/read/array-and-string/c5tv3/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>思路： 安装数组中第一数排序 然后合并  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;合并区间&quot;&gt;&lt;a href=&quot;#合并区间&quot; class=&quot;headerlink&quot; title=&quot;合并区间&quot;&gt;&lt;/a&gt;合并区间&lt;/h3&gt;&lt;p&gt;给出一个区间的集合，请合并所有重叠的区间。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;p&gt;输入: [[1,3],[2,6],[8,
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://richard-xiong.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="https://richard-xiong.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/leetcode/"/>
    
      <category term="数组" scheme="https://richard-xiong.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="algorithm" scheme="https://richard-xiong.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>搜索插入位置</title>
    <link href="https://richard-xiong.github.io/2020/08/07/leetcode%20%E6%95%B0%E7%BB%84-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/"/>
    <id>https://richard-xiong.github.io/2020/08/07/leetcode%20%E6%95%B0%E7%BB%84-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</id>
    <published>2020-08-06T22:08:43.000Z</published>
    <updated>2020-08-09T13:49:52.073Z</updated>
    
    <content type="html"><![CDATA[<h3 id="搜索插入位置"><a href="#搜索插入位置" class="headerlink" title="搜索插入位置"></a>搜索插入位置</h3><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。</p><p>示例 1:</p><p>输入: [1,3,5,6], 5<br>输出: 2<br>示例 2:</p><p>输入: [1,3,5,6], 2<br>输出: 1<br>示例 3:</p><p>输入: [1,3,5,6], 7<br>输出: 4<br>示例 4:</p><p>输入: [1,3,5,6], 0<br>输出: 0</p><p>作者：力扣 (LeetCode)<br>链接：<a href="https://leetcode-cn.com/leetbook/read/array-and-string/cxqdh/">https://leetcode-cn.com/leetbook/read/array-and-string/cxqdh/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchInsert</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> nums[<span class="number">0</span>] &gt; target &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> nums[<span class="built_in">len</span>(nums)<span class="number">-1</span>] &lt; target &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> index := <span class="number">0</span>; index &lt; <span class="built_in">len</span>(nums)<span class="number">-1</span>; index++ &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[index] == target &#123;</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> index+<span class="number">1</span> &gt;<span class="built_in">len</span>(nums) &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> nums[index+<span class="number">1</span>] == target &#123;</span><br><span class="line">            <span class="keyword">return</span> index +<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> nums[index] &lt; target &amp;&amp; target &lt; nums[index+<span class="number">1</span>] &#123;</span><br><span class="line">            <span class="keyword">return</span> index + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个题目主要是考二分查找 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchInsert</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n:=<span class="built_in">len</span>(nums)</span><br><span class="line">    left,right:=<span class="number">0</span>,n<span class="number">-1</span></span><br><span class="line">    ans:=n</span><br><span class="line">    <span class="keyword">for</span> left&lt;=right &#123;</span><br><span class="line">        mid:=(right-left)&gt;&gt;<span class="number">1</span>+left</span><br><span class="line">        <span class="keyword">if</span> target&lt;= nums[mid] &#123;</span><br><span class="line">            right=mid<span class="number">-1</span></span><br><span class="line">            ans=mid</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            left=mid+<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  ans</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;搜索插入位置&quot;&gt;&lt;a href=&quot;#搜索插入位置&quot; class=&quot;headerlink&quot; title=&quot;搜索插入位置&quot;&gt;&lt;/a&gt;搜索插入位置&lt;/h3&gt;&lt;p&gt;给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://richard-xiong.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="https://richard-xiong.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/leetcode/"/>
    
      <category term="数组" scheme="https://richard-xiong.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="algorithm" scheme="https://richard-xiong.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>zip&amp;unzip的使用</title>
    <link href="https://richard-xiong.github.io/2020/08/07/zip-unzip%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://richard-xiong.github.io/2020/08/07/zip-unzip%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2020-08-06T22:03:55.000Z</published>
    <updated>2020-08-09T13:49:52.064Z</updated>
    
    <content type="html"><![CDATA[<h3 id="zip的使用"><a href="#zip的使用" class="headerlink" title="zip的使用"></a>zip的使用</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zip -r myfile.zip ./*</span><br><span class="line">将当前目录下的所有文件和文件夹全部压缩成myfile.zip文件,－r表示递归压缩子目录下所有文件.</span><br></pre></td></tr></table></figure><h3 id="unzip-的使用"><a href="#unzip-的使用" class="headerlink" title="unzip 的使用"></a>unzip 的使用</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unzip -o -d /home/sunny myfile.zip</span><br><span class="line">把myfile.zip文件解压到 /home/sunny/</span><br><span class="line">-o:不提示的情况下覆盖文件；</span><br><span class="line">-d:-d /home/sunny 指明将文件解压缩到/home/sunny目录下；</span><br></pre></td></tr></table></figure><h3 id="对已有zip包的更改"><a href="#对已有zip包的更改" class="headerlink" title="对已有zip包的更改"></a>对已有zip包的更改</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zip -d myfile.zip smart.txt</span><br><span class="line">删除压缩文件中smart.txt文件</span><br><span class="line">zip -m myfile.zip ./rpm_info.txt</span><br><span class="line">向压缩文件中myfile.zip中添加rpm_info.txt文件</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;zip的使用&quot;&gt;&lt;a href=&quot;#zip的使用&quot; class=&quot;headerlink&quot; title=&quot;zip的使用&quot;&gt;&lt;/a&gt;zip的使用&lt;/h3&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gut
      
    
    </summary>
    
    
      <category term="linux" scheme="https://richard-xiong.github.io/categories/linux/"/>
    
      <category term="运维" scheme="https://richard-xiong.github.io/categories/linux/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="linux" scheme="https://richard-xiong.github.io/tags/linux/"/>
    
      <category term="zip" scheme="https://richard-xiong.github.io/tags/zip/"/>
    
      <category term="unzip" scheme="https://richard-xiong.github.io/tags/unzip/"/>
    
  </entry>
  
  <entry>
    <title>algorithm-希尔排序</title>
    <link href="https://richard-xiong.github.io/2020/08/07/algorithm-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    <id>https://richard-xiong.github.io/2020/08/07/algorithm-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</id>
    <published>2020-08-06T21:56:21.000Z</published>
    <updated>2020-08-13T13:46:36.639Z</updated>
    
    <content type="html"><![CDATA[<h3 id="希尔排序的思路"><a href="#希尔排序的思路" class="headerlink" title="希尔排序的思路"></a>希尔排序的思路</h3><p><strong>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</strong></p><p>序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。</p><p><img src="https://images2015.cnblogs.com/blog/1024555/201611/1024555-20161128110416068-1421707828.png" alt="img"></p><p>上代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">    <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> length = <span class="number">15</span></span><br><span class="line">    <span class="keyword">var</span> list []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以时间戳为种子生成随机数，保证每次运行数据不重复</span></span><br><span class="line">    r := rand.New(rand.NewSource(time.Now().UnixNano()))</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length; i++ &#123;</span><br><span class="line">        list = <span class="built_in">append</span>(list, <span class="keyword">int</span>(r.Intn(<span class="number">1000</span>)))</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(list)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里就以n/2为增量z</span></span><br><span class="line">    gap := <span class="number">2</span></span><br><span class="line">    step := length / gap</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> step &gt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="comment">// 这里按步长开始每个分组的排序</span></span><br><span class="line">        <span class="keyword">for</span> i := step; i &lt; length; i++ &#123;</span><br><span class="line">            <span class="comment">// 将按步长分组的子队列用直接插入排序算法进行排序</span></span><br><span class="line">            insertionSortByStep(list, step)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 完成一轮后再次缩小增量</span></span><br><span class="line">        step /= gap</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出每轮缩小增量各组排序后的结果</span></span><br><span class="line">        fmt.Println(list)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里把上篇直接选择排序的算法抽出来，并将步长从1改成step</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertionSortByStep</span><span class="params">(tree []<span class="keyword">int</span>, step <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := step; i &lt; <span class="built_in">len</span>(tree); i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := i; j &gt;= step &amp;&amp; tree[j] &lt; tree[j-step]; j -= step &#123;</span><br><span class="line">            tree[j], tree[j-step] = tree[j-step], tree[j]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><p>最坏情况：O($ \log n^2$)<br>最好情况:    O($ \log 2n$)<br>平均情况：  O($ \log 2/3n$)  </p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>因为没有借助额外的空间 空间浮渣度为<code>O(1)</code></p><p>Shell排序比冒泡排序快5倍，比插入排序大致快2倍。Shell排序比起QuickSort，MergeSort，HeapSort慢很多。但是它相对比较简单，它适合于数据量在5000以下并且速度并不是特别重要的场合。它对于数据量较小的数列重复排序是非常好的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;希尔排序的思路&quot;&gt;&lt;a href=&quot;#希尔排序的思路&quot; class=&quot;headerlink&quot; title=&quot;希尔排序的思路&quot;&gt;&lt;/a&gt;希尔排序的思路&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://richard-xiong.github.io/categories/algorithm/"/>
    
      <category term="sort" scheme="https://richard-xiong.github.io/categories/algorithm/sort/"/>
    
    
      <category term="algorithm" scheme="https://richard-xiong.github.io/tags/algorithm/"/>
    
      <category term="希尔排序" scheme="https://richard-xiong.github.io/tags/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    
      <category term="sort" scheme="https://richard-xiong.github.io/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>algorithm-归并排序</title>
    <link href="https://richard-xiong.github.io/2020/08/07/algorithm-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>https://richard-xiong.github.io/2020/08/07/algorithm-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</id>
    <published>2020-08-06T21:56:21.000Z</published>
    <updated>2020-08-13T13:20:52.600Z</updated>
    
    <content type="html"><![CDATA[<h3 id="归并排序的思路"><a href="#归并排序的思路" class="headerlink" title="归并排序的思路"></a>归并排序的思路</h3><p>将一排数据，进行左右不断地进行划分（递[归]），然后再对比左右两边的数据后再(合[并])，这就是”归并排序“。</p><blockquote><p>注意：[左右]对比，是指左的第一个元素，与右边的第一个元素进行对比，哪个小，就先放到结果的第一位，然后左或右取出了元素的那边的索引进行++，没有取出的元素的，则不用进行++。 比较完后，还要分别将左，右的剩余的元素，追加到结果列的后面</p></blockquote><h2 id="归并排序-MergeSort"><a href="#归并排序-MergeSort" class="headerlink" title="归并排序(MergeSort)"></a>归并排序(MergeSort)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">import <span class="string">&quot;time&quot;</span></span><br><span class="line">import number <span class="string">&quot;github.com/emacsist/go-common/helper/number&quot;</span></span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    data := number.GenerateInt(100000, 100000)</span><br><span class="line">    start := makeTimestamp()</span><br><span class="line">    // fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, data)</span><br><span class="line">    data = mergeSort(data)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;cost %v ms \n&quot;</span>, makeTimestamp()-start)</span><br><span class="line">    // fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">func makeTimestamp() int64 &#123;</span><br><span class="line">    <span class="built_in">return</span> time.Now().UnixNano() / int64(time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func mergeSort(data []int) []int &#123;</span><br><span class="line">    <span class="keyword">if</span> len(data) &lt;= 1 &#123;</span><br><span class="line">        <span class="built_in">return</span> data</span><br><span class="line">    &#125;</span><br><span class="line">    //递[归]</span><br><span class="line">    middle := len(data) / 2</span><br><span class="line">    //不断地进行左右对半划分</span><br><span class="line">    left := mergeSort(data[:middle])</span><br><span class="line">    right := mergeSort(data[middle:])</span><br><span class="line">    //合[并]</span><br><span class="line">    <span class="built_in">return</span> merge(left, right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func merge(left, right []int) (result []int) &#123;</span><br><span class="line">    l, r := 0, 0</span><br><span class="line"></span><br><span class="line">    // 注意：[左右]对比，是指左的第一个元素，与右边的第一个元素进行对比，哪个小，就先放到结果的第一位，然后左或右取出了元素的那边的索引进行++</span><br><span class="line">    <span class="keyword">for</span> l &lt; len(left) &amp;&amp; r &lt; len(right) &#123;</span><br><span class="line">        //从小到大排序.</span><br><span class="line">        <span class="keyword">if</span> left[l] &gt; right[r] &#123;</span><br><span class="line">            result = append(result, right[r])</span><br><span class="line">            //因为处理了右边的第r个元素，所以r的指针要向前移动一个单位</span><br><span class="line">            r++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = append(result, left[l])</span><br><span class="line">            //因为处理了左边的第l个元素，所以l的指针要向前移动一个单位</span><br><span class="line">            l++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 比较完后，还要分别将左，右的剩余的元素，追加到结果列的后面(不然就漏咯）。</span><br><span class="line">    result = append(result, left[l:]...)</span><br><span class="line">    result = append(result, right[r:]...)</span><br><span class="line">    <span class="built_in">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><p>假设解决最后的子问题用时为常数c，则对于n个待排序记录来说整个问题的规模为<code>cn</code>。</p><p><img src="https://img-blog.csdn.net/20170909101802866?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMzYzMDY0NzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>从这个递归树可以看出，第一层时间代价为cn，第二层时间代价为<code>cn/2+cn/2=cn…..</code>每一层代价都是<code>cn</code>，总共有<code>logn+1</code>层。所以总的时间代价为<code>cn*(logn+1)</code>.时间复杂度是<code>o(nlogn)</code>.</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>需要使用辅助数组的长度和待排序的数组相同 ，因此空间复杂度还是<code>O(n)</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;归并排序的思路&quot;&gt;&lt;a href=&quot;#归并排序的思路&quot; class=&quot;headerlink&quot; title=&quot;归并排序的思路&quot;&gt;&lt;/a&gt;归并排序的思路&lt;/h3&gt;&lt;p&gt;将一排数据，进行左右不断地进行划分（递[归]），然后再对比左右两边的数据后再(合[并])，这就是”归
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://richard-xiong.github.io/categories/algorithm/"/>
    
      <category term="sort" scheme="https://richard-xiong.github.io/categories/algorithm/sort/"/>
    
    
      <category term="algorithm" scheme="https://richard-xiong.github.io/tags/algorithm/"/>
    
      <category term="sort" scheme="https://richard-xiong.github.io/tags/sort/"/>
    
      <category term="归并排序" scheme="https://richard-xiong.github.io/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>algorithm-插入排序</title>
    <link href="https://richard-xiong.github.io/2020/08/07/algorithm-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>https://richard-xiong.github.io/2020/08/07/algorithm-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</id>
    <published>2020-08-06T21:56:21.000Z</published>
    <updated>2020-08-13T12:56:31.096Z</updated>
    
    <content type="html"><![CDATA[<h3 id="插入排序的思路"><a href="#插入排序的思路" class="headerlink" title="插入排序的思路"></a>插入排序的思路</h3><p>它的基本思想是将一个记录<strong>插入</strong>到已经排好序的有序表中，从而一个新的、记录数增1的有序表。</p><p>直接的例子就是玩扑克的时候，想象一下，分牌的时候，大家轮流的从一组牌中抽取最上面的一张，然后将它以某种顺序插入到我们的左手中。比如，我们想要从小到大排列我们的扑克牌。</p><p>标准方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertionSort</span><span class="params">(data []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    lo, hi := <span class="number">0</span>, <span class="built_in">len</span>(data) <span class="comment">// 获取数组的长度</span></span><br><span class="line">    <span class="keyword">for</span> i := lo + <span class="number">1</span>; i &lt; hi; i++ &#123; <span class="comment">// </span></span><br><span class="line">        <span class="keyword">for</span> j := i; j &gt; lo &amp;&amp; data[j] &lt; data[j<span class="number">-1</span>]; j-- &#123;</span><br><span class="line">            data[j], data[j<span class="number">-1</span>] = data[j<span class="number">-1</span>], data[j]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法 就是如果后面有一个需要前插操作的数值，找到指定位置之后还会继续和它前面的数值进行比较，针对这一点我们可以优化一下</p><p>优化一：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertionSort</span><span class="params">(data []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    lo, hi= <span class="number">0</span>, <span class="built_in">len</span>(data)</span><br><span class="line">    <span class="keyword">for</span> i := lo + <span class="number">1</span>; i &lt; hi; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := i; j &gt; lo; j-- &#123;</span><br><span class="line">            <span class="keyword">if</span>  data[j] &lt; data[j<span class="number">-1</span>]&#123;</span><br><span class="line">                data[j], data[j<span class="number">-1</span>] = data[j<span class="number">-1</span>], data[j]</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><p>在最坏情况下，数组完全逆序，插入第2个元素时要考察前1个元素，插入第3个元素时，要考虑前2个元素，……，插入第N个元素，要考虑前 <code>N - 1</code> 个元素。因此，最坏情况下的比较次数是 <code>1 + 2 + 3 + ... + (N - 1)</code>，等差数列求和，结果为 <code>N^2 / 2</code>，所以最坏情况下的复杂度为 <code>O(N^2)</code>。</p><p>最好情况下，数组已经是有序的，每插入一个元素，只需要考查前一个元素，因此最好情况下，插入排序的时间复杂度为<code>O(N)</code>。</p><p>平均时间复杂度  <code>(O(N^2)+O(n))/2=O(n^2)</code></p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>因为没有借助额外的空间 空间浮渣度为<code>O(1)</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;插入排序的思路&quot;&gt;&lt;a href=&quot;#插入排序的思路&quot; class=&quot;headerlink&quot; title=&quot;插入排序的思路&quot;&gt;&lt;/a&gt;插入排序的思路&lt;/h3&gt;&lt;p&gt;它的基本思想是将一个记录&lt;strong&gt;插入&lt;/strong&gt;到已经排好序的有序表中，从而一个新的、
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://richard-xiong.github.io/categories/algorithm/"/>
    
      <category term="sort" scheme="https://richard-xiong.github.io/categories/algorithm/sort/"/>
    
    
      <category term="algorithm" scheme="https://richard-xiong.github.io/tags/algorithm/"/>
    
      <category term="sort" scheme="https://richard-xiong.github.io/tags/sort/"/>
    
      <category term="插入排序" scheme="https://richard-xiong.github.io/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>redis cluster 批量删除key</title>
    <link href="https://richard-xiong.github.io/2020/08/07/redis-cluster%20%E6%89%B9%E9%87%8F%E5%88%A0%E9%99%A4key/"/>
    <id>https://richard-xiong.github.io/2020/08/07/redis-cluster%20%E6%89%B9%E9%87%8F%E5%88%A0%E9%99%A4key/</id>
    <published>2020-08-06T21:56:21.000Z</published>
    <updated>2020-08-10T06:21:31.910Z</updated>
    
    <content type="html"><![CDATA[<p>步骤一：</p><p>使用redis nodes 命令 获取master 节点的信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; CLUSTER NODES</span><br><span class="line">47a3cfa636a42217fdde923ad0af975520557fc3 127.0.0.1:6379@16379 myself,slave 73981099d52abe7ed040e9f5c7a30abd4509e4d4 0 1597031768000 0 connected</span><br><span class="line">73981099d52abe7ed040e9f5c7a30abd4509e4d4 127.0.0.1:6379@16379 master - 0 1597031770200 1 connected 0-5460</span><br><span class="line">dfa8c3b9608b9a8e0e663f63c272a4645ccf91bb 127.0.0.1:6379@16379 master - 0 1597031771201 3 connected 10923-16383</span><br><span class="line">f8415a623f17b45a503d0257ee1e6fbd963317af 127.0.0.1:6379@16379 slave dfa8c3b9608b9a8e0e663f63c272a4645ccf91bb 0 1597031770000 3 connected</span><br><span class="line">0b6a6f7ae9283fb0328b6a2a4494411809c4b8c0 127.0.0.1:6379@16379 slave aebe29e94d12609693530f93ede90be1b5163146 0 1597031772202 2 connected</span><br><span class="line">aebe29e94d12609693530f93ede90be1b5163146 127.0.0.1:6379@16379 master - 0 1597031770000 2 connected 5461-10922</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>步骤二：</p><p>编写 批量删除key的脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">redis_ser01=xx.xxx.x.xxx</span><br><span class="line"></span><br><span class="line">redis_ser02=127.0.0.1</span><br><span class="line"></span><br><span class="line">redis_ser03=127.0.0.2 </span><br><span class="line"></span><br><span class="line">port=6379</span><br><span class="line"></span><br><span class="line">redis-cli -c -h $redis_ser01 -p $port keys $1 | xargs -i redis-cli -h $redis_ser01 -p $port del &#123;&#125;</span><br><span class="line"></span><br><span class="line">redis-cli -c -h $redis_ser02 -p $port keys $1 | xargs -i redis-cli -h $redis_ser02 -p $port del &#123;&#125;</span><br><span class="line"></span><br><span class="line">redis-cli -c -h $redis_ser03 -p $port keys $1 | xargs -i redis-cli -h $redis_ser03 -p $port del &#123;&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;步骤一：&lt;/p&gt;
&lt;p&gt;使用redis nodes 命令 获取master 节点的信息&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/
      
    
    </summary>
    
    
      <category term="linux" scheme="https://richard-xiong.github.io/categories/linux/"/>
    
      <category term="运维" scheme="https://richard-xiong.github.io/categories/linux/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="redis" scheme="https://richard-xiong.github.io/categories/linux/%E8%BF%90%E7%BB%B4/redis/"/>
    
    
      <category term="linux" scheme="https://richard-xiong.github.io/tags/linux/"/>
    
      <category term="redis" scheme="https://richard-xiong.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>文件夹复制cp</title>
    <link href="https://richard-xiong.github.io/2020/08/07/%E6%96%87%E4%BB%B6%E5%A4%B9%E5%A4%8D%E5%88%B6cp/"/>
    <id>https://richard-xiong.github.io/2020/08/07/%E6%96%87%E4%BB%B6%E5%A4%B9%E5%A4%8D%E5%88%B6cp/</id>
    <published>2020-08-06T21:56:21.000Z</published>
    <updated>2020-08-09T13:49:52.066Z</updated>
    
    <content type="html"><![CDATA[<h3 id="文件夹复制"><a href="#文件夹复制" class="headerlink" title="文件夹复制"></a>文件夹复制</h3><ol><li><p>正常的复制命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cp -rf /www/cms.whd.com/conf/  mycms/</span><br><span class="line">-r 是递归的意思，会把问价下的子文件目录都会复制</span><br><span class="line">-f 参数是强制复制，比如你在a文件中有个文件名叫b，然后你把c文件夹里面的另一个文件名叫做b的复制到a里面，这个时候回冲突，然后会提示你要不要继续复制，加上-f就不会提示你了。</span><br><span class="line"></span><br><span class="line">但是当我们执行上面的那个命令时还是会提示你要不要覆盖</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>直接使用命令实习 (推荐)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> \cp -rf &#x2F;www&#x2F;cms.whd.com&#x2F;conf&#x2F;  &#x2F;www&#x2F;cms.manager&#x2F;core&#x2F;conf&#x2F;</span><br><span class="line">如果写在脚本中可以使用下面的方式 $(pwd) 或者 $&#96;pwd&#96; 来获取当前的目录路径</span><br><span class="line"> \cp -rf &#x2F;www&#x2F;cms.whd.com&#x2F;conf&#x2F; $(pwd)&#x2F;target&#x2F;cms.manager&#x2F;bdp&#x2F;core&#x2F;conf&#x2F;</span><br><span class="line">我们看到 只是在命令前加了一个反斜杠（\），这样就不会再次确认了，而且只在命令中起作用比较好。</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;文件夹复制&quot;&gt;&lt;a href=&quot;#文件夹复制&quot; class=&quot;headerlink&quot; title=&quot;文件夹复制&quot;&gt;&lt;/a&gt;文件夹复制&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;正常的复制命令&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;tabl
      
    
    </summary>
    
    
      <category term="linux" scheme="https://richard-xiong.github.io/categories/linux/"/>
    
      <category term="运维" scheme="https://richard-xiong.github.io/categories/linux/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="linux" scheme="https://richard-xiong.github.io/tags/linux/"/>
    
      <category term="cp" scheme="https://richard-xiong.github.io/tags/cp/"/>
    
  </entry>
  
  <entry>
    <title>nginx的使用</title>
    <link href="https://richard-xiong.github.io/2020/08/07/nginx%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://richard-xiong.github.io/2020/08/07/nginx%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2020-08-06T21:20:18.000Z</published>
    <updated>2020-08-09T13:49:52.069Z</updated>
    
    <content type="html"><![CDATA[<h3 id="正向代理与反向代理"><a href="#正向代理与反向代理" class="headerlink" title="正向代理与反向代理"></a>正向代理与反向代理</h3><ol><li><p>我们常说的代理服务器（多指 VPN），一般就是正向代理。它的特点有：隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端请求的服务都由代理服务器代替来请求；「正向代理」指一对一或多对一，Server 不知道请求的 Client 都是哪些人。</p><img src="/images/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86.png" alt="正向代理" style="zoom:33%;" /></li><li><p>反向代理恰好跟正向代理相反。同时反向代理一般是负载均衡的一个原理。按照上面所说，正向代理是一对一或多对一，那么反向代理就是一对多</p></li></ol><img src="/images/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86.png" alt="反向代理" style="zoom:33%;" /><p><strong>两者的区别在于代理的对象不一样：正向代理代理的对象是客户端，反向代理代理的对象是服务端。</strong></p><h3 id="nginx的使用"><a href="#nginx的使用" class="headerlink" title="nginx的使用"></a>nginx的使用</h3><h4 id="启动nginx"><a href="#启动nginx" class="headerlink" title="启动nginx"></a>启动nginx</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./nginx -c nginx.conf</span><br></pre></td></tr></table></figure><h4 id="重启nginx"><a href="#重启nginx" class="headerlink" title="重启nginx"></a>重启nginx</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./nginx -s reload</span><br></pre></td></tr></table></figure><h4 id="nginx-conf配置熟知"><a href="#nginx-conf配置熟知" class="headerlink" title="nginx.conf配置熟知"></a>nginx.conf配置熟知</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">user root; # 表示nginx是用root用户启动的</span><br><span class="line">worker_processes auto; # 设置nginx的线程数 默认是机器内核的数量</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="获取真实ip"><a href="#获取真实ip" class="headerlink" title="获取真实ip"></a>获取真实ip</h4><ol><li><p>这个功能依赖于http_realip_module  在安装nginx的时候 需要带上 <code>--with-http_realip_module</code> </p></li><li><p>查看已安装的nginx是否支持这个模块</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">./tools/nginx/sbin/nginx -V</span><br><span class="line"><span class="meta">&gt;</span></span><br><span class="line">nginx version: nginx/1.12.2</span><br><span class="line">built by gcc 7.3.1 20180303 (Red Hat 7.3.1-5) (GCC)</span><br><span class="line">built with OpenSSL 1.1.0h  27 Mar 2018</span><br><span class="line">TLS SNI support enabled</span><br><span class="line">configure arguments: --prefix=/home/work/tools/nginx --with-http_ssl_module --with-http_sub_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_stub_status_module --with-stream=dynamic --with-compat --with-pcre=/home/work/pcre-8.40 --with-zlib=/home/work/zlib-1.2.11 --with-openssl=/home/work/openssl-1.1.0h</span><br></pre></td></tr></table></figure></li></ol><h4 id="设置server"><a href="#设置server" class="headerlink" title="设置server"></a>设置server</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name  xxx.xx.com; # 绑定域名</span><br><span class="line">    access_log  /data/logs/nginx-access.log  main;</span><br><span class="line">    error_log   /data/logs/nginx-error.log;</span><br><span class="line">    location / &#123; # 设置反向代理的location </span><br><span class="line">             real_ip_header X-Forwarded-For; </span><br><span class="line">             set_real_ip_from x.x.x.x/x; # Ip/network of the reverse proxy (or ip received into REMOTE_ADDR)</span><br><span class="line">             proxy_set_header Host $host;</span><br><span class="line">             proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">             proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">             proxy_pass http://localhost:8080;  # 设置要反向代理的地址</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;正向代理与反向代理&quot;&gt;&lt;a href=&quot;#正向代理与反向代理&quot; class=&quot;headerlink&quot; title=&quot;正向代理与反向代理&quot;&gt;&lt;/a&gt;正向代理与反向代理&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;我们常说的代理服务器（多指 VPN），一般就是正向代理。它的特点有
      
    
    </summary>
    
    
      <category term="linux" scheme="https://richard-xiong.github.io/categories/linux/"/>
    
      <category term="运维" scheme="https://richard-xiong.github.io/categories/linux/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="linux" scheme="https://richard-xiong.github.io/tags/linux/"/>
    
      <category term="nginx" scheme="https://richard-xiong.github.io/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>端口占用</title>
    <link href="https://richard-xiong.github.io/2020/08/07/%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8/"/>
    <id>https://richard-xiong.github.io/2020/08/07/%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8/</id>
    <published>2020-08-06T20:44:15.000Z</published>
    <updated>2020-08-09T13:49:52.074Z</updated>
    
    <content type="html"><![CDATA[<h3 id="查看端口占用"><a href="#查看端口占用" class="headerlink" title="查看端口占用"></a>查看端口占用</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mac使用lsof 查看端口8080是否被占用 </span></span><br><span class="line">lsof -i:8080</span><br><span class="line"><span class="meta">&gt;</span></span><br><span class="line">COMMAND PID          USER   FD   TYPE            DEVICE SIZE/OFF NODE NAME</span><br><span class="line">BaiduHi 444 mengfanxing_g   54u  IPv4 0xa65d4596444d7d5      0t0  TCP localhost:63023-&gt;123.125.115.205:http-alt (ESTABLISHED)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> linux 使用netstat 查看8080是佛被占用</span></span><br><span class="line">netstat -anp| grep 8080</span><br><span class="line"><span class="meta">&gt;</span></span><br><span class="line">(Not all processes could be identified, non-owned process info</span><br><span class="line"> will not be shown, you would have to be root to see it all.)</span><br><span class="line">tcp6       0      0 :::8080                 :::*                    LISTEN      25263/./new-meet-ro</span><br><span class="line">tcp6       0      0 x.x.x.x:33316      117.78.7.65:8080        ESTABLISHED 26598/java</span><br><span class="line">tcp6       0      0 x.x.x.x:33236      117.78.7.65:8080        ESTABLISHED 26509/java</span><br></pre></td></tr></table></figure><h3 id="根据pid查看进程"><a href="#根据pid查看进程" class="headerlink" title="根据pid查看进程"></a>根据pid查看进程</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用lsof 查看pid=25263的进程</span></span><br><span class="line">lsof -i: grep 25263</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> new-meet- 25263 work    6u  IPv6 1043683416      0t0  TCP *:webcache (LISTEN)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用netstat 查看pid=25263的进程</span></span><br><span class="line">netstat -nap | grep 25263</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> (Not all processes could be identified, non-owned process info</span></span><br><span class="line"> will not be shown, you would have to be root to see it all.)</span><br><span class="line">tcp6       0      0 :::8080                 :::*                    LISTEN      25263/./new-meet-ro</span><br></pre></td></tr></table></figure><h3 id="查看远程端口是否打开"><a href="#查看远程端口是否打开" class="headerlink" title="查看远程端口是否打开"></a>查看远程端口是否打开</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用nc 来检查单个端口</span></span><br><span class="line">nc -zv 127.0.0.1 22</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">  Connection to 127.0.0.1 port 22 [tcp/ssh] succeeded!</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用nc 来检查一段打开的端口范围</span></span><br><span class="line">nc -zv 127.0.0.1 22-24</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Connection to 127.0.0.1 port 22 [tcp/ssh] succeeded!</span></span><br><span class="line">nc: connectx to 127.0.0.1 port 23 (tcp) failed: Connection refused</span><br><span class="line">nc: connectx to 127.0.0.1 port 24 (tcp) failed: Connection refused</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;查看端口占用&quot;&gt;&lt;a href=&quot;#查看端口占用&quot; class=&quot;headerlink&quot; title=&quot;查看端口占用&quot;&gt;&lt;/a&gt;查看端口占用&lt;/h3&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gut
      
    
    </summary>
    
    
      <category term="linux" scheme="https://richard-xiong.github.io/categories/linux/"/>
    
      <category term="运维" scheme="https://richard-xiong.github.io/categories/linux/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="linux" scheme="https://richard-xiong.github.io/tags/linux/"/>
    
      <category term="port" scheme="https://richard-xiong.github.io/tags/port/"/>
    
  </entry>
  
  <entry>
    <title>修改linux时区</title>
    <link href="https://richard-xiong.github.io/2020/08/06/%E4%BF%AE%E6%94%B9linux%E6%97%B6%E5%8C%BA/"/>
    <id>https://richard-xiong.github.io/2020/08/06/%E4%BF%AE%E6%94%B9linux%E6%97%B6%E5%8C%BA/</id>
    <published>2020-08-06T14:23:47.000Z</published>
    <updated>2020-08-09T13:49:52.071Z</updated>
    
    <content type="html"><![CDATA[<h3 id="查看当前时区"><a href="#查看当前时区" class="headerlink" title="查看当前时区"></a>查看当前时区</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date -R</span><br></pre></td></tr></table></figure><h3 id="修改时区为东八区"><a href="#修改时区为东八区" class="headerlink" title="修改时区为东八区"></a>修改时区为东八区</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;查看当前时区&quot;&gt;&lt;a href=&quot;#查看当前时区&quot; class=&quot;headerlink&quot; title=&quot;查看当前时区&quot;&gt;&lt;/a&gt;查看当前时区&lt;/h3&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gut
      
    
    </summary>
    
    
      <category term="linux" scheme="https://richard-xiong.github.io/categories/linux/"/>
    
      <category term="运维" scheme="https://richard-xiong.github.io/categories/linux/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="linux" scheme="https://richard-xiong.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>vim的常用命令</title>
    <link href="https://richard-xiong.github.io/2020/08/06/vim%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://richard-xiong.github.io/2020/08/06/vim%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2020-08-06T14:19:31.000Z</published>
    <updated>2020-08-09T13:49:52.068Z</updated>
    
    <content type="html"><![CDATA[<h3 id="vim-多行注释"><a href="#vim-多行注释" class="headerlink" title="vim 多行注释"></a>vim 多行注释</h3><ol><li>首先按 esc 进入命令<strong>行</strong>模式下，按下 Ctrl + v ，进入列（也叫区块）模式;</li><li>在<strong>行</strong>首使用上下键选择需要<strong>注释</strong>的<strong>多行</strong>;</li><li>按下键盘（大写） “I” 键，进入插入模式；</li><li>然后输入<strong>注释</strong>符（ “//”、“#”     等）;</li><li>最后按下 “Esc” 键。 注：在按下 esc 键后，会稍等一会才会出现<strong>注释</strong>，不要着急~~时间很短的</li></ol><h3 id="vim-多行取消注释"><a href="#vim-多行取消注释" class="headerlink" title="vim 多行取消注释"></a>vim 多行取消注释</h3><ol><li>Ctrl + v 进入块选择模式</li><li>选中你要删除的行首的注释符号，注意// 要选中两个</li><li>选好之后按d即可删除注释</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;vim-多行注释&quot;&gt;&lt;a href=&quot;#vim-多行注释&quot; class=&quot;headerlink&quot; title=&quot;vim 多行注释&quot;&gt;&lt;/a&gt;vim 多行注释&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;首先按 esc 进入命令&lt;strong&gt;行&lt;/strong&gt;模式下，按下 Ctr
      
    
    </summary>
    
    
      <category term="vim" scheme="https://richard-xiong.github.io/categories/vim/"/>
    
    
      <category term="linux" scheme="https://richard-xiong.github.io/tags/linux/"/>
    
      <category term="vim" scheme="https://richard-xiong.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>Go 语言学习笔记 Gin框架(五)</title>
    <link href="https://richard-xiong.github.io/2020/08/06/Go-%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Gin%E6%A1%86%E6%9E%B6-%E4%BA%94/"/>
    <id>https://richard-xiong.github.io/2020/08/06/Go-%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Gin%E6%A1%86%E6%9E%B6-%E4%BA%94/</id>
    <published>2020-08-05T19:39:57.000Z</published>
    <updated>2020-08-09T13:49:52.065Z</updated>
    
    <content type="html"><![CDATA[<h1 id="gin-router的使用"><a href="#gin-router的使用" class="headerlink" title="gin router的使用"></a>gin router的使用</h1><h2 id="gin简单的router-启动一个http服务"><a href="#gin简单的router-启动一个http服务" class="headerlink" title="gin简单的router 启动一个http服务"></a>gin简单的router 启动一个http服务</h2><h3 id="基本的router-注册"><a href="#基本的router-注册" class="headerlink" title="基本的router 注册"></a>基本的router 注册</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helloHandler</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">        <span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello q1mi!&quot;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line">    r.GET(<span class="string">&quot;/hello&quot;</span>, helloHandler)</span><br><span class="line">    <span class="keyword">if</span> err := r.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;startup service failed, err:%v\n&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：</p><p>适用于路由条目比较少的简单项目或者项目demo。</p><h3 id="路由拆分成单独文件或者包"><a href="#路由拆分成单独文件或者包" class="headerlink" title="路由拆分成单独文件或者包"></a>路由拆分成单独文件或者包</h3><p>当项目的规模增大后就不太适合继续在项目的<code>main.go</code>文件中去实现路由注册相关逻辑了，我们会倾向于把路由部分的代码都拆分出来，形成一个单独的文件或包：</p><p>我们在<code>routers.go</code>文件中定义并注册路由信息：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helloHandler</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">        <span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello q1mi!&quot;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setupRouter</span><span class="params">()</span> *<span class="title">gin</span>.<span class="title">Engine</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line">    r.GET(<span class="string">&quot;/hello&quot;</span>, helloHandler)</span><br><span class="line">    <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure><p>此时<code>main.go</code>中调用上面定义好的<code>setupRouter</code>函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := setupRouter()</span><br><span class="line">    <span class="keyword">if</span> err := r.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;startup service failed, err:%v\n&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此时的目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gin_demo</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── main.go</span><br><span class="line">└── routers.go</span><br></pre></td></tr></table></figure><p>把路由部分的代码单独拆分成包的话也是可以的，拆分后的目录结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gin_demo</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── main.go</span><br><span class="line">└── routers</span><br><span class="line">    └── routers.go</span><br></pre></td></tr></table></figure><p><code>routers/routers.go</code>需要注意此时<code>setupRouter</code>需要改成首字母大写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> routers</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helloHandler</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">        <span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello q1mi!&quot;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SetupRouter 配置路由信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetupRouter</span><span class="params">()</span> *<span class="title">gin</span>.<span class="title">Engine</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line">    r.GET(<span class="string">&quot;/hello&quot;</span>, helloHandler)</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main.go</code>文件内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;gin_demo/routers&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := routers.SetupRouter()</span><br><span class="line">    <span class="keyword">if</span> err := r.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;startup service failed, err:%v\n&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="路由拆分成多个文件"><a href="#路由拆分成多个文件" class="headerlink" title="路由拆分成多个文件"></a>路由拆分成多个文件</h3><p>当我们的业务规模继续膨胀，单独的一个<code>routers</code>文件或包已经满足不了我们的需求了，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetupRouter</span><span class="params">()</span> *<span class="title">gin</span>.<span class="title">Engine</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line">    r.GET(<span class="string">&quot;/hello&quot;</span>, helloHandler)</span><br><span class="line">  r.GET(<span class="string">&quot;/xx1&quot;</span>, xxHandler1)</span><br><span class="line">  ...</span><br><span class="line">  r.GET(<span class="string">&quot;/xx30&quot;</span>, xxHandler30)</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们把所有的路由注册都写在一个<code>SetupRouter</code>函数中的话就会太复杂了。</p><p>我们可以分开定义多个路由文件，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gin_demo</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── main.go</span><br><span class="line">└── routers</span><br><span class="line">    ├── blog.go</span><br><span class="line">    └── shop.go</span><br></pre></td></tr></table></figure><p><code>routers/shop.go</code>中添加一个<code>LoadShop</code>的函数，将shop相关的路由注册到指定的路由器：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadShop</span><span class="params">(e *gin.Engine)</span></span>  &#123;</span><br><span class="line">    e.GET(<span class="string">&quot;/hello&quot;</span>, helloHandler)</span><br><span class="line">  e.GET(<span class="string">&quot;/goods&quot;</span>, goodsHandler)</span><br><span class="line">  e.GET(<span class="string">&quot;/checkout&quot;</span>, checkoutHandler)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>routers/blog.go</code>中添加一个`LoadBlog的函数，将blog相关的路由注册到指定的路由器：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadBlog</span><span class="params">(e *gin.Engine)</span></span> &#123;</span><br><span class="line">    e.GET(<span class="string">&quot;/post&quot;</span>, postHandler)</span><br><span class="line">  e.GET(<span class="string">&quot;/comment&quot;</span>, commentHandler)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在main函数中实现最终的注册逻辑如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line">    routers.LoadBlog(r)</span><br><span class="line">    routers.LoadShop(r)</span><br><span class="line">    <span class="keyword">if</span> err := r.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;startup service failed, err:%v\n&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="路由拆分到不同的APP"><a href="#路由拆分到不同的APP" class="headerlink" title="路由拆分到不同的APP"></a>路由拆分到不同的APP</h3><p>有时候项目规模实在太大，那么我们就更倾向于把业务拆分的更详细一些，例如把不同的业务代码拆分成不同的APP。</p><p>因此我们在项目目录下单独定义一个<code>app</code>目录，用来存放我们不同业务线的代码文件，这样就很容易进行横向扩展。大致目录结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">gin_demo</span><br><span class="line">├── app</span><br><span class="line">│   ├── blog</span><br><span class="line">│   │   ├── handler.go</span><br><span class="line">│   │   └── router.go</span><br><span class="line">│   └── shop</span><br><span class="line">│       ├── handler.go</span><br><span class="line">│       └── router.go</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── main.go</span><br><span class="line">└── routers</span><br><span class="line">    └── routers.go</span><br></pre></td></tr></table></figure><p>其中<code>app/blog/router.go</code>用来定义post相关路由信息，具体内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Routers</span><span class="params">(e *gin.Engine)</span></span> &#123;</span><br><span class="line">    e.GET(<span class="string">&quot;/post&quot;</span>, postHandler)</span><br><span class="line">    e.GET(<span class="string">&quot;/comment&quot;</span>, commentHandler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>app/shop/router.go</code>用来定义shop相关路由信息，具体内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Routers</span><span class="params">(e *gin.Engine)</span></span> &#123;</span><br><span class="line">    e.GET(<span class="string">&quot;/goods&quot;</span>, goodsHandler)</span><br><span class="line">    e.GET(<span class="string">&quot;/checkout&quot;</span>, checkoutHandler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>routers/routers.go</code>中根据需要定义<code>Include</code>函数用来注册子app中定义的路由，<code>Init</code>函数用来进行路由的初始化操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Option <span class="function"><span class="keyword">func</span><span class="params">(*gin.Engine)</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> options = []Option&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册app的路由配置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Include</span><span class="params">(opts ...Option)</span></span> &#123;</span><br><span class="line">    options = <span class="built_in">append</span>(options, opts...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Init</span><span class="params">()</span> *<span class="title">gin</span>.<span class="title">Engine</span></span> &#123;</span><br><span class="line">    r := gin.New()</span><br><span class="line">    <span class="keyword">for</span> _, opt := <span class="keyword">range</span> options &#123;</span><br><span class="line">        opt(r)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main.go</code>中按如下方式先注册子app中的路由，然后再进行路由的初始化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 加载多个APP的路由配置</span></span><br><span class="line">    routers.Include(shop.Routers, blog.Routers)</span><br><span class="line">    <span class="comment">// 初始化路由</span></span><br><span class="line">    r := routers.Init()</span><br><span class="line">    <span class="keyword">if</span> err := r.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;startup service failed, err:%v\n&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;gin-router的使用&quot;&gt;&lt;a href=&quot;#gin-router的使用&quot; class=&quot;headerlink&quot; title=&quot;gin router的使用&quot;&gt;&lt;/a&gt;gin router的使用&lt;/h1&gt;&lt;h2 id=&quot;gin简单的router-启动一个http
      
    
    </summary>
    
    
      <category term="go" scheme="https://richard-xiong.github.io/categories/go/"/>
    
      <category term="gin" scheme="https://richard-xiong.github.io/categories/go/gin/"/>
    
    
      <category term="router" scheme="https://richard-xiong.github.io/tags/router/"/>
    
      <category term="gin" scheme="https://richard-xiong.github.io/tags/gin/"/>
    
  </entry>
  
  <entry>
    <title>Go 语言学习笔记 Gin框架(四)</title>
    <link href="https://richard-xiong.github.io/2020/08/06/Go-%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Gin%E6%A1%86%E6%9E%B6-%E5%9B%9B/"/>
    <id>https://richard-xiong.github.io/2020/08/06/Go-%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Gin%E6%A1%86%E6%9E%B6-%E5%9B%9B/</id>
    <published>2020-08-05T19:39:57.000Z</published>
    <updated>2020-08-09T13:49:52.063Z</updated>
    
    <content type="html"><![CDATA[<h1 id="gin获取请求的参数信息"><a href="#gin获取请求的参数信息" class="headerlink" title="gin获取请求的参数信息"></a>gin获取请求的参数信息</h1><p>【注】c 就是func中的参数(c  *gin.Contex)</p><h2 id="1-从uri-path中获取"><a href="#1-从uri-path中获取" class="headerlink" title="[1].从uri-path中获取"></a>[1].从uri-path中获取</h2><p>请求:</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">curl -X GET \</span><br><span class="line">  http://localhost:8080/v1/order/1 \</span><br><span class="line">  -H &#x27;Postman-Token: e4d0bf85-df6b-4ab0-bcca-1feb5a76f531&#x27; \</span><br><span class="line">  -H &#x27;cache-control: no-cache&#x27;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>获取uri-path参数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id:=c.Param(<span class="string">&quot;id&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="2-从parameters中获取"><a href="#2-从parameters中获取" class="headerlink" title="[2].从parameters中获取"></a>[2].从parameters中获取</h2><p>请求：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET \</span><br><span class="line">  http://localhost:8080/v1/order?firstname=Jack&amp;lastname=ma \</span><br><span class="line">  -H &#x27;Postman-Token: e4d0bf85-df6b-4ab0-bcca-1feb5a76f531&#x27; \</span><br><span class="line">  -H &#x27;cache-control: no-cache&#x27;  </span><br></pre></td></tr></table></figure><p>获取parameters参数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">firstName := c.DefaultQuery(<span class="string">&quot;firstName&quot;</span>, <span class="string">&quot;Guest&quot;</span>)  <span class="comment">//如果读取不到firstName会给赋值一个默认的值 Guest</span></span><br><span class="line">lastName := c.Query(<span class="string">&quot;lastName&quot;</span>)<span class="comment">// 读取 lastName的值，如果读取不到返回空字符串</span></span><br><span class="line"><span class="comment">// c.Query(&quot;lastname&quot;) 等价于 c.Request.URL.Query().Get(&quot;lastname&quot;)</span></span><br></pre></td></tr></table></figure><h2 id="3-从Multipart-Urlencoded-Form中获取"><a href="#3-从Multipart-Urlencoded-Form中获取" class="headerlink" title="[3].从Multipart/Urlencoded Form中获取"></a>[3].从Multipart/Urlencoded Form中获取</h2><p>请求:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST \</span><br><span class="line">  &#x27;http://localhost:8080/v1/order/1/10010?pkg=test.1&#x27; \</span><br><span class="line">  -H &#x27;Postman-Token: 49319e4b-fd9a-416e-a69b-5ffb54b12413&#x27; \</span><br><span class="line">  -H &#x27;cache-control: no-cache&#x27; \</span><br><span class="line">  -H &#x27;content-type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW&#x27; \</span><br><span class="line">  -F message=msg</span><br></pre></td></tr></table></figure><p>获取Multipart/Urlencoded Form参数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">message := c.PostForm(<span class="string">&quot;message&quot;</span>) <span class="comment">// 读取 message的值，如果读取不到返回空字符串</span></span><br><span class="line">nick := c.DefaultPostForm(<span class="string">&quot;nick&quot;</span>, <span class="string">&quot;anonymous&quot;</span>) <span class="comment">// 读取nick的值，如果读取不到会给nick赋默认值anonymous</span></span><br></pre></td></tr></table></figure><h2 id="4-从parameter-form-读取map或者array"><a href="#4-从parameter-form-读取map或者array" class="headerlink" title="[4].从parameter/form 读取map或者array"></a>[4].从parameter/form 读取map或者array</h2><p>请求:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl -X PUT \</span><br><span class="line">  &#x27;http://localhost:8080/v1/order/1?idMap[a]=aaa&amp;idMap[b]=bbb&amp;idArr=c1,c2&#x27; \</span><br><span class="line">  -H &#x27;Content-Type: application/x-www-form-urlencoded&#x27; \</span><br><span class="line">  -H &#x27;Postman-Token: a2f3a545-3b19-4a5d-a542-8b83c19ee2f9&#x27; \</span><br><span class="line">  -H &#x27;cache-control: no-cache&#x27; \</span><br><span class="line">  -d &#x27;nameArr=name1&amp;nameArr=name2&amp;nameMap%5Ba%5D=namea&amp;nameMap%5Bb%5D=nameb&amp;undefined=&#x27;</span><br></pre></td></tr></table></figure><p>从parameter获取map,array,从application/x-www-form-urlencoded body中获取map array</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">idMap := c.QueryMap(<span class="string">&quot;idMap&quot;</span>) <span class="comment">//从paramter获取map</span></span><br><span class="line">idArr := c.QueryArray(<span class="string">&quot;idArr&quot;</span>)<span class="comment">//从paramter获取array</span></span><br><span class="line">nameArr := c.PostFormArray(<span class="string">&quot;nameArr&quot;</span>) <span class="comment">// 从form获取map</span></span><br><span class="line">nameMap := c.PostFormMap(<span class="string">&quot;nameMap&quot;</span>)<span class="comment">// 从form获取array</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;gin获取请求的参数信息&quot;&gt;&lt;a href=&quot;#gin获取请求的参数信息&quot; class=&quot;headerlink&quot; title=&quot;gin获取请求的参数信息&quot;&gt;&lt;/a&gt;gin获取请求的参数信息&lt;/h1&gt;&lt;p&gt;【注】c 就是func中的参数(c  *gin.Contex
      
    
    </summary>
    
    
      <category term="go" scheme="https://richard-xiong.github.io/categories/go/"/>
    
      <category term="gin" scheme="https://richard-xiong.github.io/categories/go/gin/"/>
    
    
      <category term="gin" scheme="https://richard-xiong.github.io/tags/gin/"/>
    
  </entry>
  
  <entry>
    <title>Go 语言学习笔记 Gin框架(六)</title>
    <link href="https://richard-xiong.github.io/2020/08/06/Go-%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Gin%E6%A1%86%E6%9E%B6-%E5%85%AD/"/>
    <id>https://richard-xiong.github.io/2020/08/06/Go-%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Gin%E6%A1%86%E6%9E%B6-%E5%85%AD/</id>
    <published>2020-08-05T19:39:57.000Z</published>
    <updated>2020-08-09T13:49:52.074Z</updated>
    
    <content type="html"><![CDATA[<p>#gin与 swagger的集成</p><h2 id="swagger的介绍"><a href="#swagger的介绍" class="headerlink" title="swagger的介绍"></a>swagger的介绍</h2><h3 id="什么是swagger"><a href="#什么是swagger" class="headerlink" title="什么是swagger"></a>什么是swagger</h3><p>Swagger 是一个规范和一套完整的框架，用于生成、描述、调用以及可视化 RESTful 风格的 Web 服务。</p><p>Swagger的总体目标是使客户端和文件系统服务器以同样的速度来更新，方法，参数和模型紧密集成到服务器端的代码中，允许API始终保持同步。</p><p>Swagger 让部署管理和使用API从未如此简单。</p><p>Swagger包括库、编辑器、代码生成器等很多部分，这里我们主要讲一下Swagger Editor。这是一个完全开源的项目，并且它也是一个基于Angular的成功案例，我们可以下载源码并自己部署它，也可以修改它或集成到我们自己的软件中。</p><p>在Swagger Editor中，我们可以基于YAML语法定义我们的RESTful API，然后它会自动生成一篇排版优美的API文档，并且提供实时预览。相信大多数朋友都遇到过这样一个场景：明明调用的是之前约定好的API，拿到的结果却不是想要的。</p><p>可能因为是有人修改了API的接口，却忘了更新文档；或者是文档更新的不及时；又或者是文档写的有歧义，大家的理解各不相同。总之，让API文档总是与API定义同步更新，是一件非常有价值的事。</p><h3 id="自动文档的好处？"><a href="#自动文档的好处？" class="headerlink" title="自动文档的好处？"></a>自动文档的好处？</h3><ol><li><p>不用手动写文档了，通过注解就可以自动化文档</p></li><li><p>文档和代码同步更新，代码更新之后不需要再更新文档</p></li><li><p>浏览器友好</p></li><li><p>使用Swagger框架可以调试API，在浏览器端可以看到更多的<code>request</code>和<code>response</code>信息</p></li></ol><h3 id="自动化文档开发的初衷"><a href="#自动化文档开发的初衷" class="headerlink" title="自动化文档开发的初衷"></a>自动化文档开发的初衷</h3><p>我们需要开发一个API应用，然后需要和手机组的开发人员一起合作，当然我们首先想到的是文档先行，我们也根据之前的经验写了我们需要的API原型文档，我们还是根据github的文档格式写了一些漂亮的文档，但是我们开始担心这个文档如果两边不同步怎么办？因为毕竟是原型文档，变动是必不可少的。手机组有一个同事之前在雅虎工作过，他推荐我看一个swagger的应用，看了swagger的标准和文档化的要求，感觉太棒了，这个简直就是神器啊，通过swagger可以方便的查看API的文档，同时使用API的用户可以直接通过swagger进行请求和获取结果。所以我就开始学习swagger的标准，同时开始进行Go源码的研究，通过Go里面的AST进行源码分析，针对comments解析，然后生成swagger标准的json格式，这样最后就可以和swagger完美结合了。</p><p>这样做的好处有三个：</p><p>注释标准化<br>有了注释之后，以后API代码维护相当方便<br>根据注释自动化生成文档，方便调用的用户查看和测试</p><h2 id="安装swagger"><a href="#安装swagger" class="headerlink" title="安装swagger"></a>安装swagger</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> get -u github.com/swaggo/swag/cmd/swag</span><br></pre></td></tr></table></figure><p>等待安装完成，在我们的终端中执行 <code>swag init</code>，目录为根目录，于 <code>main.go</code> 同目录。</p><p>执行完成后，会在根目录下新建一个 <code>docs</code> 文件夹。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docs</span><br><span class="line">|</span><br><span class="line">|-docs.go</span><br><span class="line">|-swagger.json</span><br><span class="line">|-swagger.yaml</span><br></pre></td></tr></table></figure><p>接下来就可以完善项目了。</p><p>将下面两行放入 <code>initRouter</code> 中的 <code>import</code> 中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">swaggerFiles &quot;github.com&#x2F;swaggo&#x2F;files&quot;</span><br><span class="line">ginSwagger &quot;github.com&#x2F;swaggo&#x2F;gin-swagger&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>选择 <code>Sync packages of GinStudy</code>,此时 <code>IDE</code> 就会自动帮我下载，并添加到 <code>go.mod</code> 中。</p><h2 id="集成swagger"><a href="#集成swagger" class="headerlink" title="集成swagger"></a>集成swagger</h2><p>对 <code>swagger</code> 安装完成后，我们就可以对项目进行集成了。</p><p>在 <code>initRouter</code> 中添加路由，这个路由是对 <code>swagger</code> 的访问地址来进行添加的</p><p>在<code>routers/routers.go</code>的<code>Init</code>方法中添加</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url := ginSwagger.URL(<span class="string">&quot;http://localhost:8080/swagger/doc.json&quot;</span>)</span><br><span class="line">r.GET(<span class="string">&quot;/swagger/*any&quot;</span>, ginSwagger.WrapHandler(swaggerFiles.Handler, url))</span><br></pre></td></tr></table></figure><p>其中 <code>url</code> 定义了 <code>swagger</code> 的 <code>doc.json</code> 路径，我们可以直接访问该 <code>json</code> 来进行查看。</p><p>接下来就是完善文档的时间。</p><p>在 <code>main.go</code> 中 <code>main</code> 方法上添加注释。同时引入我们生成 <code>docs.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @title Gin swagger</span></span><br><span class="line"><span class="comment">// @version 1.0</span></span><br><span class="line"><span class="comment">// @description Gin swagger 示例项目</span></span><br><span class="line"><span class="comment">// @contact.name</span></span><br><span class="line"><span class="comment">// @contact.url https://youngxhui.top</span></span><br><span class="line"><span class="comment">// @contact.email youngxhui@g mail.com</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @license.name Apache 2.0</span></span><br><span class="line"><span class="comment">// @license.url http://www.apache.org/licenses/LICENSE-2.0.html</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @host localhost:8080</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的注释基本都是很好理解的，不做过多解释。</p><p>主要的项目介绍注释就是这些，接下来进行我们的接口方法注释。</p><p>在我们的 <code>handler</code> 中添加注释</p><p>打开 <code>app/user/handler.go</code> ,在 <code>CreateUser</code> 方法上添加。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @Summary 创建用户</span></span><br><span class="line"><span class="comment">// @Tags 用户模块</span></span><br><span class="line"><span class="comment">// @version 1.0</span></span><br><span class="line"><span class="comment">// @Accept application/x-www-form-urlencoded</span></span><br><span class="line"><span class="comment">// @Param name query string true &quot;name&quot;</span></span><br><span class="line"><span class="comment">// @Param age query int true &quot;age&quot;</span></span><br><span class="line"><span class="comment">// @Success 200 object model.UserModel 成功后返回值</span></span><br><span class="line"><span class="comment">// @Router  /v1/users [post]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateUser</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    name := c.Query(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">    age := c.Query(<span class="string">&quot;age&quot;</span>)</span><br><span class="line">    ageInt, _ := strconv.Atoi(age)</span><br><span class="line">    basicHandle := app.BasicController&#123;Ctx: c&#125;</span><br><span class="line">    basicHandle.Ok(userService.Create(name, ageInt, time.Now()))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>@Summary 是对该接口的一个描述</li><li>@Tags 是对接口的标注，同一个 tag 为一组，这样方便我们整理接口</li><li>@Version 表明该接口的版本</li><li>@Accept 表示该该请求的请求类型</li><li>@Param 表示参数 分别有以下参数 参数名词 参数类型 数据类型 是否必须 注释 属性(可选参数),参数之间用空格隔开。</li><li>@Success 表示请求成功后返回，它有以下参数 请求返回状态码，参数类型，数据类型，注释</li><li>@Failure 请求失败后返回，参数同上 (todo)</li><li>@Router 该函数定义了请求路由并且包含路由的请求方式。</li></ul><p>具体参数类型，数据类型等可以查看<a href="https://swaggo.github.io/swaggo.io/declarative_comments_format/api_operation.html">官方文档</a></p><p>其中文档中没有说明的地方这里说明一下，关于 <code>Param</code> 的参数类型有以下几种</p><ul><li>query 形如 <code>\user?username=Jack&amp;age=18</code></li><li>body 需要将数据放到 body 中进行请求</li><li>path 形如 <code>\user\1</code></li><li>formdata 接收的是form表单提交的参数</li></ul><p>不同的参数类型对应的不同请求，请对应使用。</p><p>这样我们就完成了添加接口的文档注释。</p><p>我们对形如 <code>/v1/users/:id</code> 的接口，最后的 id 通过 <code>&#123;&#125;</code> 包裹。</p><p>细心的小伙伴可能会发现我们最后的返回结果为 <code>model.Result</code> ，这是为了我们统一返回结果而新建的一个结构体，方便前端进行解析。具体函数如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> &#123;</span><br><span class="line">    Code    <span class="keyword">int</span>         <span class="string">`json:&quot;code&quot; example:&quot;000&quot;`</span></span><br><span class="line">    Message <span class="keyword">string</span>      <span class="string">`json:&quot;message&quot; example:&quot;请求信息&quot;`</span></span><br><span class="line">    Data    <span class="keyword">interface</span>&#123;&#125; <span class="string">`json:&quot;data&quot; `</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们在对 <code>Result</code> 中的 <code>tag</code> 会有 <code>example</code> ,这个仍旧是 <code>swagger</code> 的标签，用来给该结构体一个示例。</p><p>同理，我们可以对之前的 <code>article</code> 进行注释。</p><p>当我们完成了所有的代码注释时，在控制台中重新执行 <code>swag init</code>，它会根据我们的注释生成 <code>docs.go</code> 及其对应的 json 和 yaml 文件。</p><p>启动我们的项目，访问 <code>http://localhost:8080/swagger/index.html</code> 就可以查看我们的文档,效果如下</p><p><img src="/images/swagger_demo.png" alt="效果图"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#gin与 swagger的集成&lt;/p&gt;
&lt;h2 id=&quot;swagger的介绍&quot;&gt;&lt;a href=&quot;#swagger的介绍&quot; class=&quot;headerlink&quot; title=&quot;swagger的介绍&quot;&gt;&lt;/a&gt;swagger的介绍&lt;/h2&gt;&lt;h3 id=&quot;什么是swagge
      
    
    </summary>
    
    
      <category term="go" scheme="https://richard-xiong.github.io/categories/go/"/>
    
      <category term="gin" scheme="https://richard-xiong.github.io/categories/go/gin/"/>
    
    
      <category term="gin" scheme="https://richard-xiong.github.io/tags/gin/"/>
    
      <category term="swageer" scheme="https://richard-xiong.github.io/tags/swageer/"/>
    
  </entry>
  
  <entry>
    <title>Go 语言学习笔记 Gin框架(二)</title>
    <link href="https://richard-xiong.github.io/2020/08/06/Go-%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Gin%E6%A1%86%E6%9E%B6-%E4%BA%8C/"/>
    <id>https://richard-xiong.github.io/2020/08/06/Go-%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Gin%E6%A1%86%E6%9E%B6-%E4%BA%8C/</id>
    <published>2020-08-05T19:39:39.000Z</published>
    <updated>2020-08-09T13:49:52.065Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用viper读取配置文件"><a href="#使用viper读取配置文件" class="headerlink" title="使用viper读取配置文件"></a>使用viper读取配置文件</h1><p>应用系统的配置信息，一般分为两种，一是经常变化的配置则保存到数据库，另外一种则是不常变化的则以配置文件的形式保存。一般而言，应用系统至少有三组运行环境：开发环境、测试环境、生产环境</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h2 id="青铜时代"><a href="#青铜时代" class="headerlink" title="青铜时代"></a>青铜时代</h2><p>一开始的时候，我针对每个环境配置各自的yaml，在启动的时候根据环境变量读取相应的配置文件，处理代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initConfig</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    env := os.Getenv(<span class="string">&quot;GO_ENV&quot;</span>)</span><br><span class="line">    viper.SetConfigName(env)</span><br><span class="line">    viper.AddConfigPath(<span class="string">&quot;./configs&quot;</span>)</span><br><span class="line">    viper.SetConfigType(<span class="string">&quot;yml&quot;</span>)</span><br><span class="line">    err = viper.ReadInConfig()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    err := initConfig()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(viper.GetString(<span class="string">&quot;db.uri&quot;</span>))</span><br><span class="line">    fmt.Println(viper.GetString(<span class="string">&quot;db.poolSize&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同环境的配置文件如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test</span></span><br><span class="line"><span class="attr">app:</span> <span class="string">viper-test</span></span><br><span class="line"><span class="attr">db:</span></span><br><span class="line">  <span class="attr">uri:</span> <span class="string">postgres://tree:mypwd@127.0.0.1:5432/viper-test?connect_timeout=5&amp;sslmode=disable</span></span><br><span class="line">  <span class="attr">poolSize:</span> <span class="number">100</span></span><br><span class="line"><span class="comment"># production</span></span><br><span class="line"><span class="attr">app:</span> <span class="string">viper-test</span></span><br><span class="line"><span class="attr">db:</span></span><br><span class="line">  <span class="attr">uri:</span> <span class="string">postgres://tree:mypwd@10.1.1.1:5432/viper?connect_timeout=5&amp;sslmode=disable</span></span><br><span class="line">  <span class="attr">poolSize:</span> <span class="number">100</span></span><br></pre></td></tr></table></figure><p>由上面的代码可以看出，因为viper读取的配置只有一份，因此需要在每个配置中将所有的配置都一一填写，而不同环境的配置绝大部分都是相同的，只有小部分是不一致。一开始只有不到10个配置项的时候还好维护，后面配置信息越来越多，几十个的时候就是一个深坑了，看到眼都花了，太难管理。</p><h2 id="白银时代"><a href="#白银时代" class="headerlink" title="白银时代"></a>白银时代</h2><p>各运行环境中的配置90%左右是相同，而剩下的10%才是各环境的差异配置，是否可以将相同的配置以默认值的形式保存，而各环境与默认值不相同的再覆盖呢？查看了一下文档，发现了 <code>viper.SetDefault</code> 的函数，一开始是直接在代码一行行的把默认配置写上，但是这样无法利用yaml的便利，在研究了相关的代码之后，最后调整为如下的处理形式，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initConfig</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    configType := <span class="string">&quot;yml&quot;</span></span><br><span class="line">    defaultPath := <span class="string">&quot;./configs&quot;</span></span><br><span class="line">    v := viper.New()</span><br><span class="line">    <span class="comment">// 从default中读取默认的配置</span></span><br><span class="line">    v.SetConfigName(<span class="string">&quot;default&quot;</span>)</span><br><span class="line">    v.AddConfigPath(defaultPath)</span><br><span class="line">    v.SetConfigType(configType)</span><br><span class="line">    err = v.ReadInConfig()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    configs := v.AllSettings()</span><br><span class="line">    <span class="comment">// 将default中的配置全部以默认配置写入</span></span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> configs &#123;</span><br><span class="line">        viper.SetDefault(k, v)</span><br><span class="line">    &#125;</span><br><span class="line">    env := os.Getenv(<span class="string">&quot;GO_ENV&quot;</span>)</span><br><span class="line">    <span class="comment">// 根据配置的env读取相应的配置信息</span></span><br><span class="line">    <span class="keyword">if</span> env != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        viper.SetConfigName(env)</span><br><span class="line">        viper.AddConfigPath(defaultPath)</span><br><span class="line">        viper.SetConfigType(configType)</span><br><span class="line">        err = viper.ReadInConfig()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此函数将 <code>default.yml</code> 的所有配置读取至一个新的viper实例中，再以 <code>SetDefault</code> 将所有配置写入为默认配置，而各环境配置文件只需要配置差异部分，配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># default</span><br><span class="line">app: viper-test</span><br><span class="line">db:</span><br><span class="line">  uri: postgres:&#x2F;&#x2F;tree:mypwd@127.0.0.1:5432&#x2F;viper-test?connect_timeout&#x3D;5&amp;sslmode&#x3D;disable</span><br><span class="line">  poolSize: 100</span><br><span class="line"># test与default完全一致，为空文件</span><br><span class="line"># production只是数据库连接串不一致，只需要配置此项</span><br><span class="line">db:</span><br><span class="line">  uri: postgres:&#x2F;&#x2F;tree:mypwd@10.1.1.1:5432&#x2F;viper?connect_timeout&#x3D;5&amp;sslmode&#x3D;disable</span><br></pre></td></tr></table></figure><p>通过此调整，不再需要重复的维护相同的配置项，而且也能直观的看出各运行环境的配置差异，减少配置信息的出错概率。</p><hr><h2 id="王者时代"><a href="#王者时代" class="headerlink" title="王者时代"></a>王者时代</h2><p>因为主要是后端程序应用，程序交付一般都是通过docker镜像的形式，配置文件与编译后的应用程序一起打包至镜像中，在多个项目中也使用得挺顺畅。最近有一个项目非运行在docker环境下，因此希望能将配置文件一起打包至应用程序的方式，在了解了几个相关的项目，最终选择了使用 <a href="https://www.jishuwen.com/jump/aHR0cHM6Ly9naXRodWIuY29tL2dvYnVmZmFsby9wYWNrcg==">packr</a> 来将配置文件打包，调整之后的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">func initConfig() (err error) &#123;</span><br><span class="line">    box :&#x3D; packr.NewBox(&quot;.&#x2F;configs&quot;)</span><br><span class="line">    configType :&#x3D; &quot;yml&quot;</span><br><span class="line">    defaultConfig :&#x3D; box.Bytes(&quot;default.yml&quot;)</span><br><span class="line">    v :&#x3D; viper.New()</span><br><span class="line">    v.SetConfigType(configType)</span><br><span class="line">    err &#x3D; v.ReadConfig(bytes.NewReader(defaultConfig))</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    configs :&#x3D; v.AllSettings()</span><br><span class="line">    &#x2F;&#x2F; 将default中的配置全部以默认配置写入</span><br><span class="line">    for k, v :&#x3D; range configs &#123;</span><br><span class="line">        viper.SetDefault(k, v)</span><br><span class="line">    &#125;</span><br><span class="line">    env :&#x3D; os.Getenv(&quot;GO_ENV&quot;)</span><br><span class="line">    &#x2F;&#x2F; 根据配置的env读取相应的配置信息</span><br><span class="line">    if env !&#x3D; &quot;&quot; &#123;</span><br><span class="line">        envConfig :&#x3D; box.Bytes(env + &quot;.yml&quot;)</span><br><span class="line"></span><br><span class="line">        viper.SetConfigType(configType)</span><br><span class="line">        err &#x3D; viper.ReadConfig(bytes.NewReader(envConfig))</span><br><span class="line">        if err !&#x3D; nil &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调整之后，配置文件也编译至程序中，后续可以单执行文件交付，只通过在启动时指定 <code>GO_ENV</code> 则可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;使用viper读取配置文件&quot;&gt;&lt;a href=&quot;#使用viper读取配置文件&quot; class=&quot;headerlink&quot; title=&quot;使用viper读取配置文件&quot;&gt;&lt;/a&gt;使用viper读取配置文件&lt;/h1&gt;&lt;p&gt;应用系统的配置信息，一般分为两种，一是经常变化的配置
      
    
    </summary>
    
    
      <category term="go" scheme="https://richard-xiong.github.io/categories/go/"/>
    
      <category term="gin" scheme="https://richard-xiong.github.io/categories/go/gin/"/>
    
    
      <category term="viper" scheme="https://richard-xiong.github.io/tags/viper/"/>
    
  </entry>
  
</feed>
