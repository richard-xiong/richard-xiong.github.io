<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XingServer</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://richard-xiong.github.io/"/>
  <updated>2020-11-17T12:14:10.047Z</updated>
  <id>https://richard-xiong.github.io/</id>
  
  <author>
    <name>Richard</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://richard-xiong.github.io/2020/11/17/%E7%BB%99%E4%BD%A0100w%E4%B8%AA%E6%95%B0%E5%AD%97%20%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E6%9C%80%E5%A4%A7%E7%9A%84100%E4%B8%AA%E6%95%B0%E5%AD%97%EF%BC%8C%E9%82%A3%E4%B9%88%E4%B8%80%E4%B8%AA%E4%BA%BF%E5%91%A2%20%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86/"/>
    <id>https://richard-xiong.github.io/2020/11/17/%E7%BB%99%E4%BD%A0100w%E4%B8%AA%E6%95%B0%E5%AD%97%20%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E6%9C%80%E5%A4%A7%E7%9A%84100%E4%B8%AA%E6%95%B0%E5%AD%97%EF%BC%8C%E9%82%A3%E4%B9%88%E4%B8%80%E4%B8%AA%E4%BA%BF%E5%91%A2%20%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86/</id>
    <published>2020-11-17T12:14:10.047Z</published>
    <updated>2020-11-17T12:14:10.047Z</updated>
    
    <content type="html"><![CDATA[<h3 id="给你100w个数字-如何获取最大的100个数字，那么一个亿呢-怎么处理"><a href="#给你100w个数字-如何获取最大的100个数字，那么一个亿呢-怎么处理" class="headerlink" title="给你100w个数字 如何获取最大的100个数字，那么一个亿呢 怎么处理"></a>给你100w个数字 如何获取最大的100个数字，那么一个亿呢 怎么处理</h3><h3 id="排序-用哪种排序-他的时间复杂度-最优情况是什么-最差情况是什么样"><a href="#排序-用哪种排序-他的时间复杂度-最优情况是什么-最差情况是什么样" class="headerlink" title="排序 用哪种排序 他的时间复杂度 最优情况是什么 最差情况是什么样"></a>排序 用哪种排序 他的时间复杂度 最优情况是什么 最差情况是什么样</h3><h3 id="你有什么要问面试官的吗？"><a href="#你有什么要问面试官的吗？" class="headerlink" title="你有什么要问面试官的吗？"></a>你有什么要问面试官的吗？</h3><h3 id="您的团队是什么样的？你对您的团队有什么规划吗？有没有定期的做技术分享呢？然后说说自己团队的技术分享是怎么做的"><a href="#您的团队是什么样的？你对您的团队有什么规划吗？有没有定期的做技术分享呢？然后说说自己团队的技术分享是怎么做的" class="headerlink" title="您的团队是什么样的？你对您的团队有什么规划吗？有没有定期的做技术分享呢？然后说说自己团队的技术分享是怎么做的"></a>您的团队是什么样的？你对您的团队有什么规划吗？有没有定期的做技术分享呢？然后说说自己团队的技术分享是怎么做的</h3><h3 id="你对我本次的面试评价觉得怎么样？"><a href="#你对我本次的面试评价觉得怎么样？" class="headerlink" title="你对我本次的面试评价觉得怎么样？"></a>你对我本次的面试评价觉得怎么样？</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;给你100w个数字-如何获取最大的100个数字，那么一个亿呢-怎么处理&quot;&gt;&lt;a href=&quot;#给你100w个数字-如何获取最大的100个数字，那么一个亿呢-怎么处理&quot; class=&quot;headerlink&quot; title=&quot;给你100w个数字 如何获取最大的100个数
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://richard-xiong.github.io/2020/11/10/%E4%BC%B4%E9%B1%BC%E9%9D%A2%E8%AF%95%E9%A2%98%20/"/>
    <id>https://richard-xiong.github.io/2020/11/10/%E4%BC%B4%E9%B1%BC%E9%9D%A2%E8%AF%95%E9%A2%98%20/</id>
    <published>2020-11-10T13:46:28.850Z</published>
    <updated>2020-11-10T13:46:28.850Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个字符串表示的数字 str ， (只包含0-9，没有前导0)， </p><p>再给一个整数K，k &lt;= len(str) </p><p>从str里删掉k个字符，使剩下的字符串表示的数值最小 (原字符串里，每个字符的顺序是不能改变的。)</p><p>str=”351” k=1</p><p>“31”</p><p>str=”3519” k=1</p><p>“319” </p><p>3519 K=2</p><p>319 k=1</p><p>351  359 5193</p><p>str=”3519” k=2</p><p>35 51 </p><p>35 31  39 51 59 19</p><p>结果  len-k</p><p>15分钟</p><p>35991 k=2</p><p>351</p><p>12345  k=3</p><p>func getMin（str string,k int）string{</p><p> max:=-1 </p><p>for （i:=0;i&lt;len-k;i++）{</p><p>if str[i:k] &gt; max{}</p><p>}</p><p>for  k– {</p><p>first:=strconv.atoi(str[0])</p><p>second:=strconv.atoi(str[1]) //i</p><p>if first&lt;second{</p><p> str= str[0]+str[2:]</p><p>391</p><p>}else{</p><p>str= str[1：]</p><p> }</p><p>}</p><p>  return str</p><p>}</p><p>1000万推送量，下游PUSH接口的QPS 1w/s的限制</p><p>\1. 在预定时间内 比如 30分钟推完1000万条push</p><p>\2. 控制推送速率，不能打垮下游RPC接口</p><p><img src="/Users/mengfanxing_g/richard/blog/XingServer/source/_posts/image-20201110214534990.png" alt="image-20201110214534990">                       ![            </p><p>​          <img src="/Users/mengfanxing_g/richard/blog/XingServer/source/_posts/image-20201110214447919.png" alt="11">            </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个字符串表示的数字 str ， (只包含0-9，没有前导0)， &lt;/p&gt;
&lt;p&gt;再给一个整数K，k &amp;lt;= len(str) &lt;/p&gt;
&lt;p&gt;从str里删掉k个字符，使剩下的字符串表示的数值最小 (原字符串里，每个字符的顺序是不能改变的。)&lt;/p&gt;
&lt;p&gt;str=
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>interview-go</title>
    <link href="https://richard-xiong.github.io/2020/11/04/interview-go/"/>
    <id>https://richard-xiong.github.io/2020/11/04/interview-go/</id>
    <published>2020-11-03T16:53:25.000Z</published>
    <updated>2020-11-07T14:52:40.861Z</updated>
    
    <content type="html"><![CDATA[<h4 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h4><h4 id="go基础"><a href="#go基础" class="headerlink" title="go基础"></a>go基础</h4><ol><li><p>说说go的优点</p><ol><li>go的性能是Python的35倍</li><li>性能 （因为golang是机器代码） 编译后的文件可以直接放在机器上执行</li><li>开发的过程中 无效的字段或者包名引用 会强制提醒错误，有fmt 统一代码的格式</li><li>并发支持  channel和goroutine的性能很出色，可以非常方便的启动一个协程，很容易的生出数百万个goroutine</li><li>内置运行时gc，是通过三色法来对垃圾进行回收，可以满足大多数关于垃圾收集的请求</li><li>简单易学，非常容易上手</li><li>可以返回多个值，虽然java也支持（最多支持三个）</li><li>非常节省内存 1.12之前一个goroutinue的内存大概占用2kb，而一个java线程默认是2mb，1.17之后已经改为8kb了</li><li>接口的实现非常方便，可以通过内嵌struct来实现继承</li><li>if…;… {} 可以将变量的作用域放在if内 很棒</li><li>单元测试和并发测试都很方便</li></ol><p>缺点是</p><ol><li>缺乏框架、 没有像java那种开发小项目使用springboot springcloud 这种比较成熟的框架、不过对于goweb开发 有beego 、gin等、对于分布式有gomicro、gokit，</li><li>错误处理，经常要对错误进行判断 </li><li>使用的用法很多坑，比如slice传递的是引用不是副本 ，如果调用的func 不会对slice进行修改传递本身是没问题，如果需要修改就需要考虑使用copy（src，dest）来进行， 如果知道要slice要存储的空间是多少，在初始化的时候要使用 make([]int，nums)来声明，防止在append过程中会发生扩容操作。<br>nil切片、空切片、零切片的区别，var str []int 这种是nil切片 ，序列化之后是null，var str = []int{} 这种是空切片，序列化之后是[] 空数组，领切片就是 make([]int,10) 初始化之后 底层数组存储的数据都是0，官方不推荐创建空切片、也不推荐nil切片和nil进行对比</li><li>map中struct的单个字段 是非法的，因为map中的元素是不能寻址的</li></ol></li><li><p>谈谈golang的csp模型</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;自我介绍&quot;&gt;&lt;a href=&quot;#自我介绍&quot; class=&quot;headerlink&quot; title=&quot;自我介绍&quot;&gt;&lt;/a&gt;自我介绍&lt;/h4&gt;&lt;h4 id=&quot;go基础&quot;&gt;&lt;a href=&quot;#go基础&quot; class=&quot;headerlink&quot; title=&quot;go基础&quot;&gt;&lt;/a
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>interview-golang GC</title>
    <link href="https://richard-xiong.github.io/2020/11/04/interview-golang-GC/"/>
    <id>https://richard-xiong.github.io/2020/11/04/interview-golang-GC/</id>
    <published>2020-11-03T16:04:24.000Z</published>
    <updated>2020-11-03T08:04:57.882Z</updated>
    
    <content type="html"><![CDATA[<p>过去一般采用两种办法：</p><ul><li>内存泄露检测工具。这种工具的原理一般是静态代码扫描，通过扫描程序检测可能出现内存泄露的代码段。然而检测工具难免有疏漏和不足，只能起到辅助作用。</li><li>智能指针。这是 c++ 中引入的自动内存管理方法，通过拥有自动内存管理功能的指针对象来引用对象，是程序员不用太关注内存的释放，而达到内存自动释放的目的。这种方法是采用最广泛的做法，但是对程序开发者有一定的学习成本（并非语言层面的原生支持），而且一旦有忘记使用的场景依然无法避免内存泄露。</li></ul><p>为了解决这个问题，后来开发出来的几乎所有新语言（java，python，php等等）都引入了语言层面的自动内存管理 – 也就是语言的使用者只用关注内存的申请而不必关心内存的释放，内存释放由虚拟机（virtual machine）或运行时（runtime）来自动进行管理。而这种对不再使用的内存资源进行自动回收的行为就被称为垃圾回收。</p><p>常用的垃圾回收的方法:</p><ul><li>引用计数（reference counting）</li></ul><p>这是最简单的一种垃圾回收算法，和之前提到的智能指针异曲同工。对每个对象维护一个引用计数，当引用该对象的对象被销毁或更新时被引用对象的引用计数自动减一，当被引用对象被创建或被赋值给其他对象时引用计数自动加一。当引用计数为0时则立即回收对象。</p><p>这种方法的优点是实现简单，并且内存的回收很及时。这种算法在内存比较紧张和实时性比较高的系统中使用的比较广泛，如ios cocoa框架，php，python等。</p><p>但是简单引用计数算法也有明显的缺点：</p><ol><li>频繁更新引用计数降低了性能。</li></ol><p>一种简单的解决方法就是编译器将相邻的引用计数更新操作合并到一次更新；还有一种方法是针对频繁发生的临时变量引用不进行计数，而是在引用达到0时通过扫描堆栈确认是否还有临时对象引用而决定是否释放。等等还有很多其他方法，具体可以参考这里。</p><ol><li>循环引用。</li></ol><p>当对象间发生循环引用时引用链中的对象都无法得到释放。最明显的解决办法是避免产生循环引用，如cocoa引入了strong指针和weak指针两种指针类型。或者系统检测循环引用并主动打破循环链。当然这也增加了垃圾回收的复杂度。</p><ul><li>标记-清除（mark and sweep）</li></ul><p>标记-清除（mark and sweep）分为两步，标记从根变量开始迭代得遍历所有被引用的对象，对能够通过应用遍历访问到的对象都进行标记为“被引用”；标记完成后进行清除操作，对没有标记过的内存进行回收（回收同时可能伴有碎片整理操作）。这种方法解决了引用计数的不足，但是也有比较明显的问题：每次启动垃圾回收都会暂停当前所有的正常代码执行，回收是系统响应能力大大降低！当然后续也出现了很多mark&amp;sweep算法的变种（如三色标记法）优化了这个问题。</p><ul><li>分代搜集（generation）</li></ul><p>java的jvm 就使用的分代回收的思路。在面向对象编程语言中，绝大多数对象的生命周期都非常短。分代收集的基本思想是，将堆划分为两个或多个称为代（generation）的空间。新创建的对象存放在称为新生代（young generation）中（一般来说，新生代的大小会比 老年代小很多），随着垃圾回收的重复执行，生命周期较长的对象会被提升（promotion）到老年代中（这里用到了一个分类的思路，这个是也是科学思考的一个基本思路）。</p><p>因此，新生代垃圾回收和老年代垃圾回收两种不同的垃圾回收方式应运而生，分别用于对各自空间中的对象执行垃圾回收。新生代垃圾回收的速度非常快，比老年代快几个数量级，即使新生代垃圾回收的频率更高，执行效率也仍然比老年代垃圾回收强，这是因为大多数对象的生命周期都很短，根本无需提升到老年代。</p><p>Golang GC 时会发生什么?</p><p>Golang 1.5后，采取的是“非分代的、非移动的、并发的、三色的”标记清除垃圾回收算法。</p><p>golang 中的 gc 基本上是标记清除的过程：</p><p><a href="https://github.com/KeKe-Li/For-learning-Go-Tutorial/blob/master/src/images/2.jpg"><img src="/images/interview-golang-GC/2.jpg" alt="img"></a></p><p>gc的过程一共分为四个阶段：</p><ol><li>栈扫描（开始时STW）</li><li>第一次标记（并发）</li><li>第二次标记（STW）</li><li>清除（并发）</li></ol><p>整个进程空间里申请每个对象占据的内存可以视为一个图，初始状态下每个内存对象都是白色标记。</p><ol><li>先STW，做一些准备工作，比如 enable write barrier。然后取消STW，将扫描任务作为多个并发的goroutine立即入队给调度器，进而被CPU处理</li><li>第一轮先扫描root对象，包括全局指针和 goroutine 栈上的指针，标记为灰色放入队列</li><li>第二轮将第一步队列中的对象引用的对象置为灰色加入队列，一个对象引用的所有对象都置灰并加入队列后，这个对象才能置为黑色并从队列之中取出。循环往复，最后队列为空时，整个图剩下的白色内存空间即不可到达的对象，即没有被引用的对象；</li><li>第三轮再次STW，将第二轮过程中新增对象申请的内存进行标记（灰色），这里使用了write barrier（写屏障）去记录</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;过去一般采用两种办法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存泄露检测工具。这种工具的原理一般是静态代码扫描，通过扫描程序检测可能出现内存泄露的代码段。然而检测工具难免有疏漏和不足，只能起到辅助作用。&lt;/li&gt;
&lt;li&gt;智能指针。这是 c++ 中引入的自动内存管理方法，通过拥有自动
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>interview-golang常见的并发模型</title>
    <link href="https://richard-xiong.github.io/2020/11/03/interview-golang%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/"/>
    <id>https://richard-xiong.github.io/2020/11/03/interview-golang%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-11-03T14:19:48.000Z</published>
    <updated>2020-11-03T08:00:27.793Z</updated>
    
    <content type="html"><![CDATA[<p>常见的并发模型：</p><ol><li><p>channel</p><p>无缓冲的通道通常指通道的大小为0，也就是说，这种类型的通道再接收之前没有能力保存任何值，它要求发送goroutinue和接收goroutinue同时准备好，才可以完成发送和接收</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;start working&quot;</span>)</span><br><span class="line">        time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">        ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    &lt;-ch</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;finished&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当主 goroutine 运行到 &lt;-ch 接受 channel 的值的时候，如果该 channel 中没有数据，就会一直阻塞等待，直到有值。 这样就可以简单实现并发控制</p></li><li><p>sync.waitGroup</p><p>Goroutine是异步执行的，有的时候为了防止在结束mian函数的时候结束掉Goroutine，所以需要同步等待，这个时候就需要用 WaitGroup了，在 sync 包中，提供了 WaitGroup ，它会等待它收集的所有 goroutine 任务全部完成。在WaitGroup里主要有三个方法:</p><ul><li>Add, 可以添加或减少 goroutine的数量.</li><li>Done, 相当于Add(-1).</li><li>Wait, 执行后会堵塞主线程，直到WaitGroup 里的值减至0.</li></ul><p>在主 goroutine 中 Add(delta int) 索要等待goroutine 的数量。 在每一个 goroutine 完成后 Done() 表示这一个goroutine 已经完成，当所有的 goroutine 都完成后，在主 goroutine 中 WaitGroup 返回</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">var</span> urls = []<span class="keyword">string</span>&#123;</span><br><span class="line">        <span class="string">&quot;http://www.golang.org/&quot;</span>,</span><br><span class="line">        <span class="string">&quot;http://www.google.com/&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, url := <span class="keyword">range</span> urls &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(url <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            http.Get(url)</span><br><span class="line">        &#125;(url)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line">在Golang官网中对于WaitGroup介绍是A WaitGroup must not be copied after first use,在 WaitGroup 第一次使用后，不能被拷贝</span><br><span class="line"></span><br><span class="line">应用示例:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(wg sync.WaitGroup, i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;i:%d&quot;</span>, i)</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;(wg, i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">&quot;exit&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">运行:</span><br><span class="line"></span><br><span class="line">i:<span class="number">1i</span>:<span class="number">3i</span>:<span class="number">2i</span>:<span class="number">0i</span>:<span class="number">4</span>fatal error: all goroutines are asleep - deadlock!</span><br><span class="line"></span><br><span class="line">goroutine <span class="number">1</span> [semacquire]:</span><br><span class="line">sync.runtime_Semacquire(<span class="number">0xc000094018</span>)</span><br><span class="line">        /home/keke/soft/<span class="keyword">go</span>/src/runtime/sema.<span class="keyword">go</span>:<span class="number">56</span> +<span class="number">0x39</span></span><br><span class="line">sync.(*WaitGroup).Wait(<span class="number">0xc000094010</span>)</span><br><span class="line">        /home/keke/soft/<span class="keyword">go</span>/src/sync/waitgroup.<span class="keyword">go</span>:<span class="number">130</span> +<span class="number">0x64</span></span><br><span class="line">main.main()</span><br><span class="line">        /home/keke/<span class="keyword">go</span>/Test/wait.<span class="keyword">go</span>:<span class="number">17</span> +<span class="number">0xab</span></span><br><span class="line">exit status <span class="number">2</span></span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li>context</li></ol><p>通常,在一些简单场景下使用 channel 和 WaitGroup 已经足够了，但是当面临一些复杂多变的网络并发场景下 channel 和 WaitGroup 显得有些力不从心了。 比如一个网络请求 Request，每个 Request 都需要开启一个 goroutine 做一些事情，这些 goroutine 又可能会开启其他的 goroutine，比如数据库和RPC服务。 所以我们需要一种可以跟踪 goroutine 的方案，才可以达到控制他们的目的，这就是Go语言为我们提供的 Context，称之为上下文非常贴切，它就是goroutine 的上下文。 它是包括一个程序的运行环境、现场和快照等。每个程序要运行时，都需要知道当前程序的运行状态，通常Go 将这些封装在一个 Context 里，再将它传给要执行的 goroutine 。</p><p>context 包主要是用来处理多个 goroutine 之间共享数据，及多个 goroutine 的管理。</p><p>context 包的核心是 struct Context，接口声明如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Context carries a deadline, cancelation signal, and request-scoped values</span></span><br><span class="line"><span class="comment">// across API boundaries. Its methods are safe for simultaneous use by multiple</span></span><br><span class="line"><span class="comment">// goroutines.</span></span><br><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Done returns a channel that is closed when this `Context` is canceled</span></span><br><span class="line">    <span class="comment">// or times out.</span></span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Err indicates why this Context was canceled, after the Done channel</span></span><br><span class="line">    <span class="comment">// is closed.</span></span><br><span class="line">    Err() error</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Deadline returns the time when this Context will be canceled, if any.</span></span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Value returns the value associated with key or nil if none.</span></span><br><span class="line">    Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Done() 返回一个只能接受数据的channel类型，当该context关闭或者超时时间到了的时候，该channel就会有一个取消信号</p><p>E rr() 在Done() 之后，返回context 取消的原因。</p><p>Deadline() 设置该context cancel的时间点</p><p>Value() 方法允许 Context 对象携带request作用域的数据，该数据必须是线程安全的。</p><p>Context 对象是线程安全的，你可以把一个 Context 对象传递给任意个数的 gorotuine，对它执行 取消 操作时，所有 goroutine 都会接收到取消信号。</p><p>一个 Context 不能拥有 Cancel 方法，同时我们也只能 Done channel 接收数据。 其中的原因是一致的：接收取消信号的函数和发送信号的函数通常不是一个。 典型的场景是：父操作为子操作操作启动 goroutine，子操作也就不能取消父操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;常见的并发模型：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;channel&lt;/p&gt;
&lt;p&gt;无缓冲的通道通常指通道的大小为0，也就是说，这种类型的通道再接收之前没有能力保存任何值，它要求发送goroutinue和接收goroutinue同时准备好，才可以完成发送和接收&lt;/p&gt;
&lt;fig
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://richard-xiong.github.io/2020/11/02/%E5%AD%9F%E5%87%A1%E6%98%9F%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86/"/>
    <id>https://richard-xiong.github.io/2020/11/02/%E5%AD%9F%E5%87%A1%E6%98%9F%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86/</id>
    <published>2020-11-02T02:37:58.128Z</published>
    <updated>2020-11-02T11:58:16.196Z</updated>
    
    <content type="html"><![CDATA[<p>孟凡星</p><p>电话：17600362123</p><p>邮箱：<a href="mailto:nizhidaoIEdeyisima@gmail.com">nizhidaoIEdeyisima@gmail.com</a>  <a href="mailto:17600362123@yahoo.com">17600362123@yahoo.com</a></p><h2 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h2><p>男 未婚</p><p>27岁</p><p>沈阳大学/本科</p><p>工作经验：4年</p><p>现居住地： 北京</p><p>户口所在地：辽宁-葫芦岛</p><p>求职意向 偏向于go</p><p>期望工作性质 : 全职</p><p>期望月薪 : 35k/月</p><p>期望从事行业 : 计算机软件</p><p>期望从事职业 : 软件开发</p><p>期望工作地点 : 北京</p><p>目前状况 : 我目前处于在职</p><p>自我评价</p><ol><li>老实、踏实、认真、仔细、有责任心是我的做事方式，总会高于领导的要求来严格要求自己，对领导分配的任务能高效及时的完成。</li><li>抗压能力、自学能力强，对在开发中用到的新技术、疑难问题，能够快速的从网上或其他地方获取解决办法，有自己的学习笔记，乐于技术分享</li><li>能指导初级、中级工程师进行开发。</li><li>对工作负责，有集体荣誉感，任劳任怨。</li><li>热爱学习，热衷于技术，经常学习新技术补充自己。</li><li>有带领团队的经验（5-8人）</li><li>对于容器化的部署有丰富的经验</li></ol><h2 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h2><h3 id="2018-7月至今北京小熊博望（百度国际化）"><a href="#2018-7月至今北京小熊博望（百度国际化）" class="headerlink" title="2018.7月至今北京小熊博望（百度国际化）"></a>2018.7月至今北京小熊博望（百度国际化）</h3><h3 id="2017-10月2018-7中国中煤能源股份有限公司"><a href="#2017-10月2018-7中国中煤能源股份有限公司" class="headerlink" title="2017.10月2018.7中国中煤能源股份有限公司"></a>2017.10月2018.7<a href="https://www.baidu.com/link?url=LvM0KE2SlhWwuukv0f2xuySMWmdIx4Qe1WzDvim-m7UkX_HB1ZCZ2muEUsOyB_fE&wd=&eqid=ae8224ba0003a119000000035b4ad478">中国中煤能源股份有限公司</a></h3><p>###2016.3月2017.9北京智慧流科技教育有限公司</p><h2 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h2><p><strong>2018.7-至今</strong></p><p>Meet （视频聊天 reslet netty） </p><p>Sleepiness （轻应用类 springboot）</p><p>SleepinessCMS （sleepiness的cms平台 Vue）</p><p>MaterialPlatform （轻应用类 springboot）</p><p>MaterialPlatformCMS （贴纸平台的cms  Vue）</p><p>输入法主题自动打包 （小工具类 内部使用 Go）</p><p>壁纸SDK (轻应用类 Go)</p><p>壁纸SDKCMS (壁纸cms Vue)</p><p>生酮饮食 (轻应用类 Go)</p><p>场景化sdk （小工具类 Go）</p><p>海外赚 （轻应用类Go）</p><p>海外赚CMS （轻应用类Go 开发中）</p><p>luck-quiz (轻应用类Go)新meet(java)</p><p><strong>2017.10月-2018.7</strong></p><p>Itzh集团的ERP系统 （企业内部管理系统ssm ext）</p><p><strong>2016.10-2017.9</strong></p><p>陕旅英语（k12 dubbo）</p><p>闽教英语（k12 dubbo）</p><p>湘少英语（k12 dubbo）</p><p>粤人英语（k12 dubbo）</p><p>课堂宝 （素材资源上传平台）</p><p><strong>在国际化工作描述 :</strong> </p><ol><li>负责国际化出海产品的开发</li><li>老百度国际化项目的迁移</li><li>Elk集群的部署和维护</li><li>实时分析公司各个产品线的pv、uv 、接口超时情况、日志error报警</li><li>代码review及优化</li><li>线上项目的维护</li><li>Springboot 和golang 对小工具、轻应用产品的开发</li><li>使用AWS CI/CD，云容器的部署、服务上线</li><li>技术分享</li><li>把控各个产品线的工作进度，确保主要产品线的正常迭代&amp;注意组员的工作状态</li><li>负责对招聘新员工进行面试及安排</li></ol><p><strong>meet项目描述</strong> </p><p>这个项目是海外的视频语音聊天软件，由于是全球范围内都有普及，用户可以相互视频或者语音聊天，所以引发了用户的很高兴趣，为了提高用户的体验，缓存用户的数据结构改为了redis hash（对uid取模来分shard），为了可以多条件筛选附近的聊天室，选取了用mongodb来对聊天室进行geo 建模，对于多种匹配策略，复用了工厂的设计模式，通过这个项目的开发，学习了很多，深入的明白了如何写出高质量的代码，实现需求功能如何做技术选型，熟练的使用shell编写脚本，来计算pv uv，编写定时任务（后期我搭建了elastic集群，能够实时的收集各个产品的日志，图形化的展示产品的健康情况，对于错误日志和接口的响应情况进行分析，能够及时发送给rd），后期优化为视频聊天，提供主播对用户一对一服务的聊天、通过对主播的录屏、接通时长还有接通率来给主播进行打分，实现流量倾斜，通过一些假用户的消息下发来吸引用户付费。 目前日pv1400w的pv ，项目部署再aws的eks上，通过pod的性能参数、来考虑是否要增加机器。</p><p><strong>luckquiz项目描述</strong></p><p> 这个是一个基于beego开发的项目，有答题、刮卡、乐透、幸运转盘的小游戏，初期是吸引用户玩游戏来消耗金币、然后通过开广告来获取奖励的生态模式来运作。通过aes对用户和时间戳来加密生成验证用户有效性的token、像答题、刮卡、转盘每天玩的次数都是有次数限制的、而且奖励的金币概率和中奖概率也需要随时用户金币数和现金数的增加而改变。其中答题要求下发给用户的题目信息不允许有重复的，</p><p>方案一： 使用mysql not in（性能太差）<br>方案二： 了解到 其实是给用户下发的题目和题库的题目做差集，使用redis sdiff 命令 redis key是这样的，因为sdiff key1 key2 ，<br>key1 key2 如果不在同一个slot上，就会发出redis 错误，所以开始用{}，先计算key的hash，将answer 用{}括起来，使其<br>落在同一个slot上,题库的题目 {answer}:load-questions:%questionType ,用户看过的题目 {answer}:load-questions-by:%userId<br>能到达预期目的<br>方案三： 方案二虽然能达到预期目的，但是随着用户量的增加、单个slot的容量总是有限的，所以在用户注册的时候，给每个用户都会将题库复制一份，<br>rediskey 与userId进行绑定,题库的题目 answer:load-questions:{userId}:questionType ,用户看过的题目 answer:load-questions-by:{userId}<br>这样解决了单个slot内存过于庞大的问题这个还有一个好处就是差集的计算都交给了redis 的机器去操作<br>方案四：使用bitset 指令 SETBIT key offset value 复杂度 O(1)<br>一个bit位来表示某个元素对应的值或者状态,其中的key就是对应元素本身。我们知道8个bit可以组成一个Byte，所以bitmap本身会极大的节省储存空间。之前存储一个questionId是int64类型 ，大概的空间占用计算公式是：($offset/8/1024/1024)MB，也就是说8388608 个题目在redis里才会占用1mb的内存空间， offset 标识题目id，0 标识未打过，1标识已经答过</p><p><strong>2017.10-月2018.7</strong></p><p><strong>在中煤工作描述 :</strong> </p><ol><li>负责企业内部网站的开发</li><li>对接口的性能进行自测，并对代码调优。</li><li>相关模块接口的开发和单元测试</li><li>代码review</li><li>线上项目的维护&amp;项目进度的推进</li><li>和项目经理确定需求可行性。</li></ol><p><strong>项目描述 :</strong></p><p>这个项目是做集团的ERP系统，这个项目极大的提高了部门领导对项目的审核效率和对资产预算的评估情况，以及资产管理部门对资产分配的了解，项目处对各个项目详细信息的控制情况。 这个项目涉及了资产模块、项目模块和采购模块这三个主要功能、</p><p>个人承担对项目模块的全部开发。这个项目采用的是Ssm架构、通过对mybatis-generator开源框架的修改、自动化生成了对表的业务逻辑的正删改查、和接口的自动化测试脚本和junit测试实例、因为这个项目是企业的办公软件、大多数业务逻辑都是围绕对表的增删改查、</p><p>所以大大的减轻了开发的时间、提高了开发效率。 这个项目的亮点就是解耦很成功、三个主要功能都可以各自拆分开来、整个项目采用的是前后端分离的开发模式、大大的提高了开发效率。通过这个项目我学到了工作流的开发、更重要的是和小组人员的及时沟通</p><p>能减少不必要的开发上的错误、也能提高工作效率、再一次的认识到在开发前小组讨论对业务的熟悉对开发而言的重要及必要性。而且在讨论中能够对自己想法淬炼、增强思维的严谨性。</p><p><strong>项目描述 :</strong> </p><p>专业技能</p><ul><li>微服务的两个派系 阿里系的dubbo 和SpringCloud栈系的SpringBoot。</li><li>云服务      aws 、huawei CI/CD ，docker 和k8s的使用 </li><li>熟练在Linux系统上开发，编写shell脚本</li><li>java golang  python nodejs     </li><li>基本框架 Spring SpringMvc Mybatis Hebinate     JPA vue beego </li><li>服务治理：zookeper </li><li>请求治理：nginx、elb、nlb</li><li>数据库：mysql 、redis 、mangodb、elasticearch oracle sqlserver、sql优化</li><li>前端：html5(熟悉) extjs、jquery、jsp</li><li>高并发基本技能：队列 多线程 </li><li>网络通信：netty 、socket</li><li>爬虫 （jsoup、python）</li></ul><p><strong>教育经历</strong></p><p><strong>2013.09-2017.06</strong> <strong>沈阳大学 |</strong> <strong>计算机科学与技术 |**</strong>本科**</p><p>所获证书</p><ul><li>全国大学生创新创业训练计划项目 国家三等奖</li><li>辽宁省创青春大学生创业比赛  银奖</li><li>辽宁省计算机软件设计大赛-外包组三等奖</li><li>沈阳大学计算机软件设计竞赛 一等奖</li><li>互联网+大学生创新创业大赛     一等奖</li><li>大学生移动应用开发大赛 三等奖</li><li>大学英语四级</li></ul><p>语言能力</p><p><strong>英语 :</strong> <strong>读写能力良好 |</strong> <strong>听说能力良好</strong></p><p><strong>其他：优秀毕业生</strong> <strong>答辩成绩 94</strong></p><p> 孟凡星</p><p>电话：17600362123</p><p>邮箱：<a href="mailto:nizhidaoIEdeyisima@gmail.com">nizhidaoIEdeyisima@gmail.com</a>  <a href="mailto:17600362123@yahoo.com">17600362123@yahoo.com</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;孟凡星&lt;/p&gt;
&lt;p&gt;电话：17600362123&lt;/p&gt;
&lt;p&gt;邮箱：&lt;a href=&quot;mailto:nizhidaoIEdeyisima@gmail.com&quot;&gt;nizhidaoIEdeyisima@gmail.com&lt;/a&gt;  &lt;a href=&quot;mailto:17600
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://richard-xiong.github.io/2020/11/02/%E7%BB%8F%E5%8E%86%E4%BB%8B%E7%BB%8D/"/>
    <id>https://richard-xiong.github.io/2020/11/02/%E7%BB%8F%E5%8E%86%E4%BB%8B%E7%BB%8D/</id>
    <published>2020-11-02T02:37:58.128Z</published>
    <updated>2020-11-02T08:20:41.508Z</updated>
    
    <content type="html"><![CDATA[<p>孟凡星</p><p>电话：17600362123</p><p>邮箱：<a href="mailto:nizhidaoIEdeyisima@gmail.com">nizhidaoIEdeyisima@gmail.com</a>  <a href="mailto:17600362123@yahoo.com">17600362123@yahoo.com</a></p><h2 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h2><p>男 未婚</p><p>27岁</p><p>沈阳大学/本科</p><p>工作经验：4年</p><p>现居住地： 北京</p><p>户口所在地：辽宁-葫芦岛</p><p>求职意向 偏向于go</p><p>期望工作性质 : 全职</p><p>期望月薪 : 35k/月</p><p>期望从事行业 : 计算机软件</p><p>期望从事职业 : 软件开发</p><p>期望工作地点 : 北京</p><p>目前状况 : 我目前处于在职</p><p>自我评价</p><ol><li>老实、踏实、认真、仔细、有责任心是我的做事方式，总会高于领导的要求来严格要求自己，对领导分配的任务能高效及时的完成。</li><li>抗压能力、自学能力强，对在开发中用到的新技术、疑难问题，能够快速的从网上或其他地方获取解决办法，有自己的学习笔记，乐于技术分享</li><li>能指导初级、中级工程师进行开发。</li><li>对工作负责，有集体荣誉感，任劳任怨。</li><li>热爱学习，热衷于技术，经常学习新技术补充自己。</li><li>有带领团队的经验（5-8人）</li><li>对于容器化的部署有丰富的经验</li></ol><h2 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h2><h3 id="2018-7月至今北京小熊博望（百度国际化）"><a href="#2018-7月至今北京小熊博望（百度国际化）" class="headerlink" title="2018.7月至今北京小熊博望（百度国际化）"></a>2018.7月至今北京小熊博望（百度国际化）</h3><h3 id="2017-10月2018-7中国中煤能源股份有限公司"><a href="#2017-10月2018-7中国中煤能源股份有限公司" class="headerlink" title="2017.10月2018.7中国中煤能源股份有限公司"></a>2017.10月2018.7<a href="https://www.baidu.com/link?url=LvM0KE2SlhWwuukv0f2xuySMWmdIx4Qe1WzDvim-m7UkX_HB1ZCZ2muEUsOyB_fE&wd=&eqid=ae8224ba0003a119000000035b4ad478">中国中煤能源股份有限公司</a></h3><p>###2016.3月2017.9北京智慧流科技教育有限公司</p><h2 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h2><p><strong>2018.7-至今</strong></p><p>Meet （视频聊天 reslet netty） </p><p>Sleepiness （轻应用类 springboot）</p><p>SleepinessCMS （sleepiness的cms平台 Vue）</p><p>MaterialPlatform （轻应用类 springboot）</p><p>MaterialPlatformCMS （贴纸平台的cms  Vue）</p><p>输入法主题自动打包 （小工具类 内部使用 Go）</p><p>壁纸SDK (轻应用类 Go)</p><p>壁纸SDKCMS (壁纸cms Vue)</p><p>生酮饮食 (轻应用类 Go)</p><p>场景化sdk （小工具类 Go）</p><p>海外赚 （轻应用类Go）</p><p>海外赚CMS （轻应用类Go 开发中）</p><p>luck-quiz (轻应用类Go)</p><p>新meet(java)</p><p><strong>2017.10月-2018.7</strong></p><p>Itzh集团的ERP系统 （企业内部管理系统ssm ext）</p><p><strong>2016.10-2017.9</strong></p><p>陕旅英语（k12 dubbo）</p><p>闽教英语（k12 dubbo）</p><p>湘少英语（k12 dubbo）</p><p>粤人英语（k12 dubbo）</p><p>课堂宝 （素材资源上传平台）</p><p><strong>在国际化工作描述 :</strong> </p><ol><li>负责国际化出海产品的开发</li><li>老百度国际化项目的迁移</li><li>Elk集群的部署和维护</li><li>实时分析公司各个产品线的pv、uv 、接口超时情况、日志error报警</li><li>代码review及优化</li><li>线上项目的维护</li><li>Springboot 和golang 对小工具、轻应用产品的开发</li><li>使用AWS CI/CD，云容器的部署、服务上线</li><li>技术分享</li><li>把控各个产品线的工作进度，确保主要产品线的正常迭代&amp;注意组员的工作状态</li><li>负责对招聘新员工进行面试及安排</li></ol><p><strong>meet项目描述</strong> </p><p>这个项目是海外的视频语音聊天软件，由于是全球范围内都有普及，用户可以相互视频或者语音聊天，所以引发了用户的很高兴趣，为了提高用户的体验，缓存用户的数据结构改为了redis hash（对uid取模来分shard），为了可以多条件筛选附近的聊天室，选取了用mongodb来对聊天室进行geo 建模，对于多种匹配策略，复用了工厂的设计模式，通过这个项目的开发，学习了很多，深入的明白了如何写出高质量的代码，实现需求功能如何做技术选型，熟练的使用shell编写脚本，来计算pv uv，编写定时任务（后期我搭建了elastic集群，能够实时的收集各个产品的日志，图形化的展示产品的健康情况，对于错误日志和接口的响应情况进行分析，能够及时发送给rd），后期优化为视频聊天，提供主播对用户一对一服务的聊天、通过对主播的录屏、接通时长还有接通率来给主播进行打分，实现流量倾斜，通过一些假用户的消息下发来吸引用户付费。 目前日pv1400w的pv ，项目部署再aws的eks上，通过pod的性能参数、来考虑是否要增加机器。</p><p><strong>luckquiz项目描述</strong></p><p> 这个是一个基于beego开发的项目，有答题、刮卡、乐透、幸运转盘的小游戏，初期是吸引用户玩游戏来消耗金币、然后通过开广告来获取奖励的生态模式来运作。通过aes对用户和时间戳来加密生成验证用户有效性的token、像答题、刮卡、转盘每天玩的次数都是有次数限制的、而且奖励的金币概率和中奖概率也需要随时用户金币数和现金数的增加而改变。其中答题要求下发给用户的题目信息不允许有重复的，</p><p>方案一： 使用mysql not in（性能太差）<br>方案二： 了解到 其实是给用户下发的题目和题库的题目做差集，使用redis sdiff 命令 redis key是这样的，因为sdiff key1 key2 ，<br>key1 key2 如果不在同一个slot上，就会发出redis 错误，所以开始用{}，先计算key的hash，将answer 用{}括起来，使其<br>落在同一个slot上,题库的题目 {answer}:load-questions:%questionType ,用户看过的题目 {answer}:load-questions-by:%userId<br>能到达预期目的<br>方案三： 方案二虽然能达到预期目的，但是随着用户量的增加、单个slot的容量总是有限的，所以在用户注册的时候，给每个用户都会将题库复制一份，<br>rediskey 与userId进行绑定,题库的题目 answer:load-questions:{userId}:questionType ,用户看过的题目 answer:load-questions-by:{userId}<br>这样解决了单个slot内存过于庞大的问题这个还有一个好处就是差集的计算都交给了redis 的机器去操作<br>方案四：使用bitset 指令 SETBIT key offset value 复杂度 O(1)<br>一个bit位来表示某个元素对应的值或者状态,其中的key就是对应元素本身。我们知道8个bit可以组成一个Byte，所以bitmap本身会极大的节省储存空间。之前存储一个questionId是int64类型 ，大概的空间占用计算公式是：($offset/8/1024/1024)MB，也就是说8388608 个题目在redis里才会占用1mb的内存空间， offset 标识题目id，0 标识未打过，1标识已经答过</p><p><strong>2017.10-月2018.7</strong></p><p><strong>在中煤工作描述 :</strong> </p><ol><li>负责企业内部网站的开发</li><li>对接口的性能进行自测，并对代码调优。</li><li>相关模块接口的开发和单元测试</li><li>代码review</li><li>线上项目的维护&amp;项目进度的推进</li><li>和项目经理确定需求可行性。</li></ol><p><strong>项目描述 :</strong></p><p>这个项目是做集团的ERP系统，这个项目极大的提高了部门领导对项目的审核效率和对资产预算的评估情况，以及资产管理部门对资产分配的了解，项目处对各个项目详细信息的控制情况。 这个项目涉及了资产模块、项目模块和采购模块这三个主要功能、</p><p>个人承担对项目模块的全部开发。这个项目采用的是Ssm架构、通过对mybatis-generator开源框架的修改、自动化生成了对表的业务逻辑的正删改查、和接口的自动化测试脚本和junit测试实例、因为这个项目是企业的办公软件、大多数业务逻辑都是围绕对表的增删改查、</p><p>所以大大的减轻了开发的时间、提高了开发效率。 这个项目的亮点就是解耦很成功、三个主要功能都可以各自拆分开来、整个项目采用的是前后端分离的开发模式、大大的提高了开发效率。通过这个项目我学到了工作流的开发、更重要的是和小组人员的及时沟通</p><p>能减少不必要的开发上的错误、也能提高工作效率、再一次的认识到在开发前小组讨论对业务的熟悉对开发而言的重要及必要性。而且在讨论中能够对自己想法淬炼、增强思维的严谨性。</p><p><strong>项目描述 :</strong> </p><p>专业技能</p><ul><li>微服务的两个派系 阿里系的dubbo 和SpringCloud栈系的SpringBoot。</li><li>云服务      aws 、huawei CI/CD ，docker 和k8s的使用 </li><li>熟练在Linux系统上开发，编写shell脚本</li><li>java golang  python nodejs     </li><li>基本框架 Spring SpringMvc Mybatis Hebinate     JPA vue beego </li><li>服务治理：zookeper </li><li>请求治理：nginx、elb、nlb</li><li>数据库：mysql 、redis 、mangodb、elasticearch oracle sqlserver、sql优化</li><li>前端：html5(熟悉) extjs、jquery、jsp</li><li>高并发基本技能：队列 多线程 </li><li>网络通信：netty 、socket</li><li>爬虫 （jsoup、python）</li></ul><p><strong>教育经历</strong></p><p><strong>2013.09-2017.06</strong> <strong>沈阳大学 |</strong> <strong>计算机科学与技术 |**</strong>本科**</p><p>所获证书</p><ul><li>全国大学生创新创业训练计划项目 国家三等奖</li><li>辽宁省创青春大学生创业比赛  银奖</li><li>辽宁省计算机软件设计大赛-外包组三等奖</li><li>沈阳大学计算机软件设计竞赛 一等奖</li><li>互联网+大学生创新创业大赛     一等奖</li><li>大学生移动应用开发大赛 三等奖</li><li>大学英语四级</li></ul><p>语言能力</p><p><strong>英语 :</strong> <strong>读写能力良好 |</strong> <strong>听说能力良好</strong></p><p><strong>其他：优秀毕业生</strong> <strong>答辩成绩 94</strong></p><p> 孟凡星</p><p>电话：17600362123</p><p>邮箱：<a href="mailto:nizhidaoIEdeyisima@gmail.com">nizhidaoIEdeyisima@gmail.com</a>  <a href="mailto:17600362123@yahoo.com">17600362123@yahoo.com</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;孟凡星&lt;/p&gt;
&lt;p&gt;电话：17600362123&lt;/p&gt;
&lt;p&gt;邮箱：&lt;a href=&quot;mailto:nizhidaoIEdeyisima@gmail.com&quot;&gt;nizhidaoIEdeyisima@gmail.com&lt;/a&gt;  &lt;a href=&quot;mailto:17600
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>interview-tcp 三次握手、四次挥手</title>
    <link href="https://richard-xiong.github.io/2020/10/30/interview-tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E3%80%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <id>https://richard-xiong.github.io/2020/10/30/interview-tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E3%80%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</id>
    <published>2020-10-29T21:52:53.000Z</published>
    <updated>2020-10-29T13:54:46.960Z</updated>
    
    <content type="html"><![CDATA[<ol><li>请画出三次握手和四次挥手的示意图</li><li>为什么连接的时候是三次握手？</li><li>什么是半连接队列？</li><li>ISN(Initial Sequence Number)是固定的吗？</li><li>三次握手过程中可以携带数据吗？</li><li>如果第三次握手丢失了，客户端服务端会如何处理？</li><li>SYN攻击是什么？</li><li>挥手为什么需要四次？</li><li>四次挥手释放连接时，等待2MSL的意义?</li></ol><p><img src="/images/interview-tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E3%80%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/v2-67515121626493be9b645be76534007f_r.jpg" alt="preview"></p><h2 id="1-三次握手"><a href="#1-三次握手" class="headerlink" title="1. 三次握手"></a>1. 三次握手</h2><p>三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。</p><p>刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。</p><p>进行三次握手：</p><p>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN©。此时客户端处于 SYN_SEND 状态。</p><p>首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。</p><p>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。</p><p>在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y。</p><p>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。</p><p>确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。</p><p>发送第一个SYN的一端将执行主动打开（active open），接收这个SYN并发回下一个SYN的另一端执行被动打开（passive open）。</p><p>在socket编程中，客户端执行connect()时，将触发三次握手。</p><p><img src="/images/interview-tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E3%80%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/v2-2a54823bd63e16674874aa46a67c6c72_720w.jpg" alt="img"></p><p><strong>1.1 为什么需要三次握手，两次不行吗？</strong></p><p>弄清这个问题，我们需要先弄明白三次握手的目的是什么，能不能只用两次握手来达到同样的目的。</p><p>第一次握手：客户端发送网络包，服务端收到了。</p><p>这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p><p>第二次握手：服务端发包，客户端收到了。</p><p>这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。</p><p>第三次握手：客户端发包，服务端收到了。</p><p>这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</p><p>因此，需要三次握手才能确认双方的接收与发送能力是否正常。</p><p>试想如果是用两次握手，则会出现下面这种情况：</p><blockquote><p>如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。</p></blockquote><p><strong>1.2 什么是半连接队列？</strong></p><p>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。</p><p>当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。</p><p>这里在补充一点关于SYN-ACK 重传次数的问题：</p><p>服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。</p><p>注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s…</p><p><strong>1.3 ISN(Initial Sequence Number)是固定的吗？</strong></p><p>当一端为建立连接而发送它的SYN时，它为连接选择一个初始序号。ISN随时间而变化，因此每个连接都将具有不同的ISN。ISN可以看作是一个32比特的计数器，每4ms加1 。这样选择序号的目的在于防止在网络中被延迟的分组在以后又被传送，而导致某个连接的一方对它做错误的解释。</p><p>三次握手的其中一个重要功能是客户端和服务端交换 ISN(Initial Sequence Number)，以便让对方知道接下来接收数据的时候如何按序列号组装数据。如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。</p><p><strong>1.4 三次握手过程中可以携带数据吗？</strong></p><p>其实第三次握手的时候，是可以携带数据的。但是，第一次、第二次握手不可以携带数据</p><p>为什么这样呢?大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。</p><p>也就是说，第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。</p><p><strong>1.5 SYN攻击是什么？</strong></p><p>服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到SYN洪泛攻击。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS/DDoS 攻击。</p><p>检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -n -p TCP | grep SYN_RECV</span><br></pre></td></tr></table></figure><p>常见的防御 SYN 攻击的方法有如下几种：</p><ul><li>缩短超时（SYN Timeout）时间</li><li>增加最大半连接数</li><li>过滤网关防护</li><li>SYN cookies技术</li></ul><h2 id="2-四次挥手"><a href="#2-四次挥手" class="headerlink" title="2. 四次挥手"></a>2. 四次挥手</h2><p>建立一个连接需要三次握手，而终止一个连接要经过四次挥手（也有将四次挥手叫做四次握手的）。这由TCP的半关闭（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。</p><p>TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，客户端或服务器均可主动发起挥手动作。</p><p>刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：</p><p>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。</p><p>即发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。</p><p>第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。</p><p>即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。</p><p>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。</p><p>即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。</p><p>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</p><p>即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。</p><p>收到一个FIN只意味着在这一方向上没有数据流动。客户端执行主动关闭并进入TIME_WAIT是正常的，服务端通常执行被动关闭，不会进入TIME_WAIT状态。</p><p>在socket编程中，任何一方执行close()操作即可产生挥手操作。</p><p><img src="/images/interview-tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E3%80%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/v2-c7d4b5aca66560365593f57385ce9fa9_720w.jpg" alt="img"></p><p><strong>2.1 挥手为什么需要四次？</strong></p><p>因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。</p><p><strong>2.2 2MSL等待状态</strong></p><p>TIME_WAIT状态也成为2MSL等待状态。每个具体TCP实现必须选择一个报文段最大生存时间MSL（Maximum Segment Lifetime），它是任何报文段被丢弃前在网络内的最长时间。这个时间是有限的，因为TCP报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的TTL字段。</p><p>对一个具体实现所给定的MSL值，处理的原则是：当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在TIME_WAIT状态停留的时间为2倍的MSL。这样可让TCP再次发送最后的ACK以防这个ACK丢失（另一端超时并重发最后的FIN）。</p><p>这种2MSL等待的另一个结果是这个TCP连接在2MSL等待期间，定义这个连接的插口（客户的IP地址和端口号，服务器的IP地址和端口号）不能再被使用。这个连接只能在2MSL结束后才能再被使用。</p><p><strong>2.3 四次挥手释放连接时，等待2MSL的意义?</strong></p><p>MSL是Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p><p>为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。</p><p>两个理由：</p><ul><li>保证客户端发送的最后一个ACK报文段能够到达服务端。</li></ul><p>这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，服务端超时重传FIN+ACK报文段，而客户端能在2MSL时间内收到这个重传的FIN+ACK报文段，接着客户端重传一次确认，重新启动2MSL计时器，最后客户端和服务端都进入到CLOSED状态，若客户端在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到服务端重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则服务端无法正常进入到CLOSED状态。</p><ul><li>防止“已失效的连接请求报文段”出现在本连接中。</li></ul><p>客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。</p><p><strong>2.4 为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？</strong></p><p>理论上，四个报文都发送完毕，就可以直接进入CLOSE状态了，但是可能网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>《TCP/IP详解 卷1:协议》有一张TCP状态变迁图，很具有代表性，有助于大家理解三次握手和四次挥手的状态变化。如下图所示，粗的实线箭头表示正常的客户端状态变迁，粗的虚线箭头表示正常的服务器状态变迁。</p><p><img src="/images/interview-tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E3%80%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/v2-7c402fde8210519feb8f65d41410c205_720w.jpg" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;请画出三次握手和四次挥手的示意图&lt;/li&gt;
&lt;li&gt;为什么连接的时候是三次握手？&lt;/li&gt;
&lt;li&gt;什么是半连接队列？&lt;/li&gt;
&lt;li&gt;ISN(Initial Sequence Number)是固定的吗？&lt;/li&gt;
&lt;li&gt;三次握手过程中可以携带数据吗？&lt;/l
      
    
    </summary>
    
    
    
      <category term="转" scheme="https://richard-xiong.github.io/tags/%E8%BD%AC/"/>
    
  </entry>
  
  <entry>
    <title>interview-进程、线程、协程的区别</title>
    <link href="https://richard-xiong.github.io/2020/10/30/interview-%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://richard-xiong.github.io/2020/10/30/interview-%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2020-10-29T18:03:18.000Z</published>
    <updated>2020-11-08T02:56:19.940Z</updated>
    
    <content type="html"><![CDATA[<p><strong>什么是进程和线程</strong></p><p>进程是什么呢？</p><p>直白地讲，进程就是应用程序的启动实例。比如我们运行一个游戏，打开一个软件，就是开启了一个进程。</p><p>进程拥有代码和打开的文件资源、数据资源、独立的内存空间。</p><p>线程又是什么呢？</p><p>线程从属于进程，是程序的实际执行者。一个进程至少包含一个主线程，也可以有更多的子线程。</p><p>线程拥有自己的栈空间。</p><img src="/images/interview-%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/image-20201029180523682.png" alt="image-20201029180523682" style="zoom:50%;" /><p>有人给出了很好的归纳：</p><p><strong>对操作系统来说，线程是最小的执行单元，进程是最小的资源管理单元。</strong></p><p>无论进程还是线程，都是由操作系统所管理的。</p><p>Java中线程具有五种状态：</p><p><strong>初始化 可运行 运行中 阻塞 销毁</strong></p><p>这五种状态的转化关系如下：</p><img src="/images/interview-%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/image-20201029180545720.png" alt="image-20201029180545720" style="zoom:50%;" /><p>但是，线程不同状态之间的转化是谁来实现的呢？是JVM吗？</p><p>并不是。JVM需要通过操作系统内核中的TCB（Thread Control Block）模块来改变线程的状态，这一过程需要耗费一定的CPU资源。</p><p><strong>进程和线程的痛点</strong></p><p>线程之间是如何进行协作的呢？</p><p>最经典的例子就是<strong>生产者/消费者模式</strong>：</p><p>若干个生产者线程向队列中写入数据，若干个消费者线程从队列中消费数据。</p><img src="/images/interview-%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/image-20201029180606391.png" alt="image-20201029180606391" style="zoom:50%;" /><p>如何用java语言实现生产者/消费者模式呢？</p><p>让我们来看一看代码：</p><p>public class ProducerConsumerTest {</p><p>}</p><p>class Producer extends Thread {</p><p>}</p><p>class Consumer extends Thread {private final Queue sharedQueue;</p><p>}</p><p>这段代码做了下面几件事：</p><p>1.定义了一个生产者类，一个消费者类。</p><p>2.生产者类循环100次，向同步队列当中插入数据。</p><p>3.消费者循环监听同步队列，当队列有数据时拉取数据。</p><p>4.如果队列满了（达到5个元素），生产者阻塞。</p><p>5.如果队列空了，消费者阻塞。</p><p>上面的代码正确地实现了生产者/消费者模式，但是却并不是一个高性能的实现。为什么性能不高呢？原因如下：</p><p>1.涉及到同步锁。</p><p>2.涉及到线程阻塞状态和可运行状态之间的切换。</p><p>3.涉及到线程上下文的切换。</p><p>以上涉及到的任何一点，都是非常耗费性能的操作。</p><p><strong>什么是协程</strong></p><p><strong>协程，英文Coroutines，是一种比线程更加轻量级的存在。</strong>正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。</p><img src="/images/interview-%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/image-20201029180628288.png" alt="image-20201029180628288" style="zoom:50%;" /><p>最重要的是，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。</p><p>这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。</p><p>既然协程这么好，它到底是怎么来使用的呢？</p><p>由于Java的原生语法中并没有实现协程（某些开源框架实现了协程，但是很少被使用），所以我们来看一看python当中对协程的实现案例，同样以生产者消费者模式为例：</p><p><img src="/images/interview-%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/image-20201029180645894.png" alt="image-20201029180645894"></p><p>这段代码十分简单，即使没用过python的小伙伴应该也能基本看懂。</p><p>代码中创建了一个叫做consumer的协程，并且在主线程中生产数据，协程中消费数据。</p><p>其中 <strong>yield</strong> 是python当中的语法。当协程执行到yield关键字时，会暂停在那一行，等到主线程调用send方法发送了数据，协程才会接到数据继续执行。</p><p>但是，yield让协程暂停，和线程的阻塞是有本质区别的。协程的暂停完全由程序控制，线程的阻塞状态是由操作系统内核来进行切换。</p><p>因此，<strong>协程的开销远远小于线程的开销。</strong></p><p><strong>协程的应用</strong></p><p>有哪些编程语言应用到了协程呢？我们举几个栗子：</p><p><strong>Lua语言</strong></p><p>Lua从5.0版本开始使用协程，通过扩展库coroutine来实现。</p><p><strong>Python语言</strong></p><p>正如刚才所写的代码示例，python可以通过 yield/send 的方式实现协程。在python 3.5以后，async/await 成为了更好的替代方案。</p><p><strong>Go语言</strong></p><p>Go语言对协程的实现非常强大而简洁，可以轻松创建成百上千个协程并发执行。</p><p><strong>Java语言</strong></p><p>如上文所说，Java语言并没有对协程的原生支持，但是某些开源框架模拟出了协程的功能，有兴趣的小伙伴可以看一看<strong>Kilim框架</strong>的源码：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;什么是进程和线程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;进程是什么呢？&lt;/p&gt;
&lt;p&gt;直白地讲，进程就是应用程序的启动实例。比如我们运行一个游戏，打开一个软件，就是开启了一个进程。&lt;/p&gt;
&lt;p&gt;进程拥有代码和打开的文件资源、数据资源、独立的内存空间。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>打包go-web镜像</title>
    <link href="https://richard-xiong.github.io/2020/10/29/%E6%89%93%E5%8C%85go-web%E9%95%9C%E5%83%8F/"/>
    <id>https://richard-xiong.github.io/2020/10/29/%E6%89%93%E5%8C%85go-web%E9%95%9C%E5%83%8F/</id>
    <published>2020-10-29T11:09:06.000Z</published>
    <updated>2020-10-29T03:09:18.611Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>grep 去注释和空行</title>
    <link href="https://richard-xiong.github.io/2020/10/20/grep-%E5%8E%BB%E6%B3%A8%E9%87%8A%E5%92%8C%E7%A9%BA%E8%A1%8C/"/>
    <id>https://richard-xiong.github.io/2020/10/20/grep-%E5%8E%BB%E6%B3%A8%E9%87%8A%E5%92%8C%E7%A9%BA%E8%A1%8C/</id>
    <published>2020-10-20T15:36:50.000Z</published>
    <updated>2020-10-20T07:37:26.204Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="literal">-v</span> ^<span class="comment"># /etc/vsftpd/vsftpd.conf |grep -v ^$</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight powershell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;spa
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>redis</title>
    <link href="https://richard-xiong.github.io/2020/10/15/redis/"/>
    <id>https://richard-xiong.github.io/2020/10/15/redis/</id>
    <published>2020-10-15T10:39:44.000Z</published>
    <updated>2020-11-04T12:53:55.263Z</updated>
    
    <content type="html"><![CDATA[<h3 id="redis的数据结构和编码"><a href="#redis的数据结构和编码" class="headerlink" title="redis的数据结构和编码"></a>redis的数据结构和编码</h3><img src="/images/redis/image-20201015114538604.png" alt="image-20201015114538604" style="zoom:50%;" /><p>可以使用OBJECT ENCODING</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SET msg <span class="string">&quot;hello wrold&quot;</span></span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING msg</span></span><br><span class="line">&quot;embstr&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SET story <span class="string">&quot;long long long long long long ago ...&quot;</span></span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING story</span></span><br><span class="line">&quot;raw&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SADD numbers 1 3 5</span></span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING numbers</span></span><br><span class="line">&quot;intset&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SADD numbers <span class="string">&quot;seven&quot;</span></span></span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING numbers</span></span><br><span class="line">&quot;hashtable&quot;</span><br></pre></td></tr></table></figure><ul><li><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>字符串类型的内部编码有3种：</p><ul><li>int：8个字节的长整型。</li><li>embstr：小于等于39个字节的字符串。</li><li>raw：大于39个字节的字符串。</li></ul><p>Redis会根据当前值的类型和长度决定使用哪种内部编码实现。</p><h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><p>哈希类型的内部编码有两种：</p><ul><li><p>ziplist（压缩列表）：</p><p>条件：</p><ol><li>当哈希类型元素个数小于hash-max-ziplist-entries配置（默认512个）</li><li>所有值都小于hash-max-ziplist-value配置（默认64字节）</li></ol></li><li><p>hashtable（哈希表）：当哈希类型无法满足ziplist的条件时使用hashtable</p></li></ul><p>Redis使用ziplist作为哈希的内部实现，ziplist使用更加紧凑的结构实现多个元素的连续存储，所以在节省内存方面比hashtable更加优秀。</p><p>使用hashtable作为哈希的内部实现，ziplist的读写效率会下降，而hashtable的读写时间复杂度为O（1）。</p><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p>列表类型的内部编码有两种。</p><ul><li>ziplist（压缩列表）：当列表的元素个数小于list-max-ziplist-entries配置（默认512个），同时列表中每个元素的值都小于list-max-ziplist-value配置时（默认64字节），Redis会选用ziplist来作为列表的内部实现来减少内存的使用。</li><li>linkedlist（链表）：当列表类型无法满足ziplist的条件时，Redis会使用linkedlist作为列表的内部实现。</li></ul><p>提示：</p><p>Redis3.2版本提供了quicklist内部编码，简单地说它是以一个ziplist为节点的linkedlist，它结合了ziplist和linkedlist两者的优势，为列表类型提供了一种更为优秀的内部编码实现，它的设计原理可以参考Redis的另一个作者Matt Stancliff的博客：<a href="https://matt.sh/redis-quicklist">https://matt.sh/redis-quicklist</a> 。</p><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>集合类型的内部编码有两种：</p><ul><li>intset（整数集合）：当集合中的元素都是整数且元素个数小于set-max-intset-entries配置（默认512个）时，Redis会选用intset来作为集合的内部实现，从而减少内存的使用。</li><li>hashtable（哈希表）：当集合类型无法满足intset的条件时，Redis会使用hashtable作为集合的内部实现。</li></ul><h2 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h2><p>有序集合类型的内部编码有两种：</p><ul><li>ziplist（压缩列表）：当有序集合的元素个数小于zset-max-ziplist-entries配置（默认128个），同时每个元素的值都小于zset-max-ziplist-value配置（默认64字节）时，Redis会用ziplist来作为有序集合的内部实现，ziplist可以有效减少内存的使用。</li><li>skiplist（跳跃表）：当ziplist条件不满足时，有序集合会使用skiplist作为内部实现，因为此时ziplist的读写效率会下降。</li></ul></li></ul><h4 id="单线程为什么这么快？"><a href="#单线程为什么这么快？" class="headerlink" title="单线程为什么这么快？"></a>单线程为什么这么快？</h4><ol><li>纯内存 大概是100纳秒 （主要原因）</li><li>非阻塞io （select/poll/epoll）</li><li>减少了多线程的切换和竟态消耗 ，多线程如果没有合理使用会比单线程还慢</li></ol><h4 id="需要注意哪些："><a href="#需要注意哪些：" class="headerlink" title="需要注意哪些："></a>需要注意哪些：</h4><ol><li><p>一次只运行一次命令</p></li><li><p>拒绝慢命令 keys flush flushdb，slow lua script 。mutil/exec operate big value（Collection）</p></li><li><p>redis 其实不是单线程，再执行下面操作的时候都是有单独线程去执行的</p><p>​    fysnc file descriptor</p><p>​    close file descriptor</p></li><li><p>redis的key和string类型的value都限制为512MB</p></li></ol><h2 id="Redis-Api的使用和理解"><a href="#Redis-Api的使用和理解" class="headerlink" title="Redis Api的使用和理解"></a>Redis Api的使用和理解</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ol><li><h5 id="结构和命令"><a href="#结构和命令" class="headerlink" title="结构和命令"></a>结构和命令</h5><p>​    key value 结构</p><p>​    value的值 可以是字符串 数值 也可以是位图   最大的值有限制是512MB</p><ol><li><p>场景：</p><ol><li>缓存</li><li>计数器</li><li>分布式锁</li><li>。。。</li></ol></li><li><p>命令</p><p>get key O(1)</p><p>set key value O(1)</p><p>delete key O(1)</p><p>incry key  # key自增1 如果不存在，以0为起点 O(1)</p><p>decr key  #key 自减  O(1)</p><p>incrby  key k # key 自增k，如果不存在 ,自增后get(key)=k  O(1)</p><p>decrby key k  #   key 自减k，如果不存在 ,自增后get(key)=-k  O(1)</p></li><li><p>快速实战</p><ol><li><p>实现如下功能：</p><p>​    记录网站每个用户个人主页的访问量？</p><p> incr userid:pageview (单线程：无竞争) </p></li><li><p>缓存视频的基本信息（数据源再mysql中）伪代码</p><img src="/images/redis/image-20201015142830668.png" alt="image-20201015142830668" style="zoom: 33%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> VideoInfo <span class="title">get</span><span class="params">(<span class="keyword">long</span> id)</span></span>&#123;</span><br><span class="line">    String redisKey = redisPrefix+id</span><br><span class="line">  VideoInfo videoInfo = redis.get(redisKey);</span><br><span class="line">  <span class="keyword">if</span> (videoInfo==<span class="keyword">null</span>)&#123;</span><br><span class="line">    videoInfo=mysql.get(id)&#123;</span><br><span class="line">      <span class="keyword">if</span> (videoInfo!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">// 序列化</span></span><br><span class="line">            redis.set(redisKey,searialize(videoInfo))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> videoInfo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol></li></ol><pre><code>  3. 分布式的id生成器     &lt;img src=&quot;/images/redis/image-20201015144059614.png&quot; alt=&quot;image-20201015144059614&quot; style=&quot;zoom:33%;&quot; /&gt;     incr key    4.  set  setnx  setxx     ​    set key value # 不管key是否存在都设置 O(1)     ​    setnx key value # key 不存在才设置 O(1)     ​    set key value xx #  key 存在才设置 O(1)  5. mget  mset     ​    mget key1 key2 key3 #批量获取key 原子操作 O(n)     ​    mset key1 value1 key2 value2 key3 value3 # 批量设置key value O(n)     &lt;img src=&quot;/images/redis/image-20201015145748466.png&quot; alt=&quot;image-20201015145748466&quot; style=&quot;zoom:25%;&quot; /&gt;  &lt;img src=&quot;/images/redis/image-20201015145832158.png&quot; alt=&quot;image-20201015145832158&quot; style=&quot;zoom:25%;&quot; /&gt;#### 内部编码  4. #### 查缺补漏     1. getset 、append 、strlen        getset key newvalue # set key newvalue 并返回久的value   O(1)        append key value # 将value追加到旧的value O(1)        strlen key # 返回字符串的长度（注意中文） O(1)  utf8 中文占用两个字节     2.  incrbyfloat getrange setrange        incrbyfloat key 3.5 #增加kkey对应的值是3.5 O(1)        getrange key start end # 获取字符串指定下标的所有的值  O(n)        setrange key index value # 设置指定下标所有对应的值  O(n)</code></pre><ol start="2"><li><h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><h4 id="1、hash键值的结构"><a href="#1、hash键值的结构" class="headerlink" title="1、hash键值的结构"></a>1、hash键值的结构</h4><p>​        key   filed value    filed 可以理解为属性  value 是属性值    </p><img src="/images/redis/image-20201015152852586.png" alt="image-20201015152852586" style="zoom:25%;" /><h4 id="2、-特点"><a href="#2、-特点" class="headerlink" title="2、 特点"></a>2、 特点</h4><p>​    Mapmap？map的map   key对应的是一个map  filed和value也像是一个map   </p><p>​    SmallRedis  引号的 可以理解为上面</p><p>​    filed 不能相同 value 可以相同</p><h4 id="3-、重要的api"><a href="#3-、重要的api" class="headerlink" title="3 、重要的api"></a>3 、重要的api</h4><ol><li><p>​    hget hset hdel</p><p>​    hget key filed # 获取hash key对应filed的value O(1) </p><p>​    hset key filed value # 设置hash key 对应field 的value  O(1)</p><p>​    hdel key field # 删除hash key 对应filed的value  O(1)</p></li><li><p>hexists hlen </p><p>​    hexists  key filed # 判断hash key 是否有field O(1) </p><p>hlen key # 获取hash key field的数量 O(1) </p></li><li><p>hmegt  hmset</p><p>​    hmget key filed1 field2 … filedN # 批量获取hash key的一批field的值  O(n)</p><p>​    hmset key filed1 value1 field2 value2 …filedN valueN # 批量设置hash key的一批field value O(n) </p></li></ol><h4 id="4、-实战"><a href="#4、-实战" class="headerlink" title="4、 实战"></a>4、 实战</h4><ol><li><p>​    记录网站每个用户个人主页的访问量</p><p>​    hincrby user:1:info pageview count</p></li><li><p>缓存视频的基本信息 伪代码    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> VedioInfo <span class="title">get</span><span class="params">(<span class="keyword">long</span> id)</span></span>&#123;</span><br><span class="line">  String redisKey = redisPrefix + id</span><br><span class="line">  Map&lt;String,String&gt; hashMap = redis.getAll(redisKey)</span><br><span class="line">  VideoInfo videoInfo = transferMapToVideo(hashMap)</span><br><span class="line">  <span class="keyword">if</span> videoInfo == <span class="keyword">null</span> &#123;</span><br><span class="line">        videoInfo = mysql.get(id)</span><br><span class="line">      <span class="keyword">if</span> videoInfo != <span class="keyword">null</span> &#123;</span><br><span class="line">        redis.hmset(redisKey,transVideoToMap(videoInfo))</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> videoInfo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>hgetall hvals  hkeys</p><p>hgetall key # 返回对应key的所有field和value O(n) </p><p>hvals key # 返回对应key的所有field的values O(n) </p><p>hkeys key # 返回对应key的所有field  O(n) </p><p>小心使用hgetall 因为redis是单线程  否则会阻塞操作</p></li><li><p>更新用户信息</p><ol><li>string key  user存储    key value是整个用户信息</li><li>string  key:用户属性  value:属性值</li><li>hash  key field 是用户属性 value  属性值</li></ol><img src="/images/redis/image-20201015174305567.png" alt="image-20201015174305567" style="zoom:25%;" /></li></ol></li></ol><h4 id="5、查缺补漏"><a href="#5、查缺补漏" class="headerlink" title="5、查缺补漏"></a>5、查缺补漏</h4><ol><li><p>hsetnx hincrby hincrbyfloat</p><p>​    hsetnx key field value # 设置hash key对应field的value 如果field已经存在则失败 O(1)</p><p>​    hincrby key field intCounter # hash key对应的field的value自增intCounter  O(1) </p><p>​    hincrbyfloat key field floatCounter  # hash key对应的field的value自增loatCounter  O(1)</p></li></ol><ol start="3"><li><h2 id="list-1"><a href="#list-1" class="headerlink" title="list"></a>list</h2><ol><li><h4 id="列表结构"><a href="#列表结构" class="headerlink" title="列表结构"></a>列表结构</h4><p>​    key  elements</p></li><li><h4 id="重要api"><a href="#重要api" class="headerlink" title="重要api"></a>重要api</h4><p>​    rpush key value1 value2 … valueN #从列表右端插入值(1-n个) O(n)</p><p>​    lpush key value1 value2 … valueN # 从列表左端插入值(1-n个) O(n)</p><p>​    linsert key before|after value newValue #在list指定的值 前|后插入newValue O(n)</p><p>​    lpop key # 从list左边弹出一个item</p><p>​    rpop key # 从list右边弹出一个item</p><p>​    lrem key count value # 根据count的值，从列表中删除所有与value相等的项 O(n)</p><ol><li>count&gt;0 从左到右，删除最大count个与value相等的项</li><li>count&lt;0 从右到左，删除最大count个与value相等的项</li><li>count=0 删除所有与value相等的项</li></ol><p>​    ltrim key start end # 按照索引范围修剪列表 O(n)</p><p>​    lrange key start end（包含end）# 获取列表指定范围的所有item O(n)</p><p>​    lindex key index # 获取列表指定索引的值 O(n)</p><p>​    llen key # 获取列表的长度 O(1)</p><p>​    lset key index newValue # 设置列表指定索引的值为newValueO(n)</p><h4 id="3-实战场景"><a href="#3-实战场景" class="headerlink" title="3.实战场景"></a>3.实战场景</h4><p>​    时间轴 timeline</p><h4 id="4-查缺补漏"><a href="#4-查缺补漏" class="headerlink" title="4.查缺补漏"></a>4.查缺补漏</h4><p>​    blpop brpop</p><ol><li>​    blpop key timeout # lpop阻塞版本，timeout是阻塞超时时间，timeout=0 为永远不阻塞</li><li>brpop key timeout # rpop阻塞版本，timeout是阻塞超时时间，timeout=0 为永远不阻塞</li></ol><h5 id="5-tips"><a href="#5-tips" class="headerlink" title="5. tips"></a>5. tips</h5><ol><li>​    LPUSH + LPOP = Stack</li><li>​    LPUSH + RPOP = Quene</li><li>LPUSH + LTRIM = Cappend Collection 固定大小的集合</li><li>LPSUH + BRPOP = Message Quene </li></ol></li></ol></li><li><p>set</p><ol><li><p>集合结构</p><p>​    key  values</p></li><li><p>特点</p><ol><li>无序</li><li>无重复</li><li>集合间的操作</li></ol></li><li><p>api</p><ol><li><p>sadd  srem</p><p>sadd key element  #向集合key添加element（如果element已经存在 添加失败） O(1)</p><p>srem key element  # 将集合key中element移出掉  O(1)</p></li><li><p>scard、sismember 、srandmember、 smembers</p><p>scard key # 计算 集合的大小</p><p>sismember key element # 判断element是否在集合key中存在</p><p>srandmember key count # 从集合中随机挑选count个元素  </p><p>spop key # 从集合中随机弹出一个元素 （弹出之后 集合中不存在这个元素了）</p><p>smembers key # 返回集合中所有元素 </p><ol><li>无序</li><li>小心使用 集合多会阻塞队列</li></ol></li><li><p>集合内实战</p><ol><li><p>抽奖系统</p><p>​    可以借助srandmember 或者spop来实现</p></li><li><p>like 赞 踩</p></li><li><p>添加标签 </p></li></ol></li><li><p>集合间的使用</p><ol><li>sdiff sinter sunion</li></ol><p>​    sdiff key1 key2 # 算出两个集合的差集</p><p>​    sinter key1 key2 # 算出两个集合的交集</p><p>​    sunion key1 key2 # 算法两个集合的并集</p></li><li><p>tips</p><p>sadd = 添加标签</p><p>spop /srandMember = 获取随机数</p><p>sadd + sinter = 做一些社交相关的业务</p></li></ol></li></ol></li><li><p>list 有序集合</p><ol><li><p>结构</p><p>​    key score value</p></li><li><p>特点</p><ol><li>无重复元素</li><li>有序</li><li>element score</li></ol></li><li><p>重要api</p><ol><li>zadd key score element # 添加元素（可以是多对 score 可以重复 element不能重复）O(logN)</li><li>zrem key element # 删除元素 可以多个 O(1)</li><li>zscore key element # 返回元素的分数 O(1) </li><li>zincrby key increSocre element  # 增加或减少element的分数 O(1)</li><li>zcard key # 返回元素的总个数   O(1)</li><li>zrank key element # 获取element在集合中的排名  ，从小到大 起点是0  O(1)  </li><li>zrange key start end 【withscores】 # 返回指定索引范围内的升序元素， 按照排名进行排序 O(logN + m)  </li><li>zrangebyscore key minScore maxScore withscores】  # 返回指定分数范围内的升序元素【分值】，按照分值进行排序   O(logN + m)  </li><li>zcount key minScores maxScore # 返回有序集合内在指定分数范围的个数 O(logN + m)  </li><li>zremrangebyrank key start end # 删除指定排名内的升序元素 O(logN + m)  </li><li>zremrangebyscore by minScore maxScore # 删除指定分值内的升序元素 O(logN + m)  </li></ol></li><li><p>实战</p><ol><li>排行榜 </li></ol></li><li><p>查缺补漏</p><ol><li>zrevrank  </li></ol></li></ol></li></ol><h2 id="瑞士军刀-redis"><a href="#瑞士军刀-redis" class="headerlink" title="瑞士军刀 redis"></a>瑞士军刀 redis</h2><h3 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h3><ol><li><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><ol><li>过程  发送 排队 执行 返回结果</li><li>慢查询是发生在第三阶段 </li><li>客户端超时不一定慢，但慢查询是客户端超时的一个可能因素</li></ol></li><li><h4 id="两个配置"><a href="#两个配置" class="headerlink" title="两个配置"></a>两个配置</h4><ol><li><p>slowlog-max-len</p><ol><li><p>先进先出的队列</p></li><li><p>固定长度</p></li><li><p>保存在内存内  </p><img src="/images/redis/image-20201016175532537.png" alt="image-20201016175532537" style="zoom: 50%;" /></li></ol></li><li><p>slowlog-log-slower-than</p><ol><li>慢查询的阈值（单位：微秒）</li><li>slowlog-log-slower-than=0 记录所有的命令 ps（因为客户端不会显示执行的时间，这时候可以将改配置记录为0 ，然后看一下慢查询中执行的时间）</li><li>slowlog-log-slower-than&lt;0 不记录任何命令</li></ol></li><li><p>配置方法</p><ol><li><p>默认值</p><ol><li>config get slowlog-max-len= 128 默认值 </li><li>config get slowlog-log-slower-than=10000 10ms</li></ol></li><li><p>修改配置文件重启（不推荐）</p></li><li><p>动态配置</p><ol><li>config set slowlog-max-len 1000</li><li>config set slowlog-log-slower-than=1000</li></ol></li></ol></li></ol></li></ol><ol start="3"><li><h4 id="三个命令"><a href="#三个命令" class="headerlink" title="三个命令"></a>三个命令</h4><ol><li>slowlog get [n] : 获取慢查询队列</li><li>showlog len ： 获取慢查询队列的长度</li><li>showlog reset ： 清空慢查询队列</li></ol></li><li><h4 id="运维经验"><a href="#运维经验" class="headerlink" title="运维经验"></a>运维经验</h4><ol><li>slowlog-max-len 不要设置的过大，slowlog-log-slower-than默认是10ms，通常设置为1ms</li><li>slowlog-log-slower-than 不要设置的过小，通常设置在1000左右</li><li>理解命令的生命周期</li><li>定期持久化慢查询（因为慢查询是存在内存当中的，这样我们就能查到历史的慢查询，这些数据是非常重要的，可以使用一些开源的第三方方法来实现这个功能）</li></ol><h3 id="pipeline"><a href="#pipeline" class="headerlink" title="pipeline"></a>pipeline</h3></li><li><p>什么是流水线</p><ol><li><p>正常redis执行一条命令的时间= 客户端发送请求和获取请求算一次网络时间，+ 一次命令在客户端执行的时间</p><p>如果多次执行redis 命令就会浪费很多网络时间，所以我们将多次命令可以打包成pipeline，然后在服务端计算n次</p><p>将结果顺序返回，这样</p><p>1次pipeline(n条命令)=1次网络时间+ n次命令执行时间</p><p>注意：</p><p>​        redis的命令时间是微秒级别的</p><p>​        pipeline每次条数要控制（网络）</p></li></ol></li><li><p>客户端实现</p></li><li><p>与原生操作对比</p><ol><li>他不是原子操作</li><li>客户端将pipeline的命令发送到服务端之后 会将pipeline中的命令进行拆分的</li></ol></li><li><p>使用建议</p><ol><li>注意每次pipeline携带的数据量</li><li>pipeline每次只能作用在一个redis节点上</li><li>M操作与pipeline的区别</li></ol><h3 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h3></li><li><p>角色</p><ol><li>发布者 publisher</li><li>订阅者 subscriber</li></ol><h3 id="bitmap"><a href="#bitmap" class="headerlink" title="bitmap"></a>bitmap</h3><h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><h3 id="Geo"><a href="#Geo" class="headerlink" title="Geo"></a>Geo</h3></li></ol><h3 id="开发运维常见问题"><a href="#开发运维常见问题" class="headerlink" title="开发运维常见问题"></a>开发运维常见问题</h3><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><ol><li><h4 id="命令实现"><a href="#命令实现" class="headerlink" title="命令实现"></a>命令实现</h4><ol><li>slaveof  ip port     异步去执行复制 </li><li>取消复制<ol><li>slaveof no more 不在成为从节点  </li></ol></li></ol></li><li><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><ol><li>slaveif ip port</li><li>slave-read-only yes 只做读操作 </li></ol></li><li><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><table><thead><tr><th align="center">方式</th><th align="center">命令</th><th align="center">配置</th></tr></thead><tbody><tr><td align="center">优点</td><td align="center">不需要重启</td><td align="center">统一配置</td></tr><tr><td align="center">缺点</td><td align="center">不便于管理</td><td align="center">需要重启</td></tr></tbody></table></li><li><h4 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h4><p>redis&gt; info replication 查看分片的状态</p><p>主从复制的配置 实际上是从节点先flush本身的数据 然后在通过网络传输将master节点的rdb文件复制过来 然后再加载到内存当中</p></li><li><h4 id="全量复制和部分复制"><a href="#全量复制和部分复制" class="headerlink" title="全量复制和部分复制"></a>全量复制和部分复制</h4><ol><li><p>当不知道master节点的run id是多少 或者master节点重启或其他情况 run id会发生改变 这样都会出发slave节点全量复制</p></li><li><p>部分复制是要看 info replication</p><p>​    </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">10.49.1.43:6379&gt; info replication</span><br><span class="line"><span class="meta">#</span><span class="bash"> Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:1</span><br><span class="line">slave0:ip=192.168.16.74,port=6379,state=online,offset=102936066,lag=1</span><br><span class="line">master_replid:134e809e3fddd112cdb3235e0a0f15a167ea65b5</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:102936066</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:101887491</span><br><span class="line">repl_backlog_histlen:1048576</span><br><span class="line"></span><br><span class="line">10.49.1.121:6379&gt; info replication</span><br><span class="line"><span class="meta">#</span><span class="bash"> Replication</span></span><br><span class="line">role:slave</span><br><span class="line">master_host:192.168.51.59</span><br><span class="line">master_port:6379</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:1</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:421179470</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_replid:5267ce41ab6dcb2bb525b5279df006259e835153</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:421179470</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:420130895</span><br><span class="line">repl_backlog_histlen:1048576</span><br></pre></td></tr></table></figure><p>从节点会定时上报自己的状态到主节点 这样master就知道slave 的偏移情况，如果offset是差别比较多的情况下 ，证明你的主从复制是有问题的，有可能是阻塞 网络 或者是缓存区域有没有满的情况 </p></li><li><p>全量复制 首先slave先将获取到的rdb文件加载到内存中，加载完成后 ，然后通过偏移量的对比 将这个期间写入的值同步给slave节点</p><p>​    <img src="/images/redis/image-20201020165104374.png" alt="image-20201020165104374"></p></li></ol></li></ol><pre><code>     1. 1 redis 2.8之前是sync  2.8之后是psync  ，是完成全量复制和部分复制的一个功能，需要两个参数 一个是run id 一个是偏移量 offset ，完成全量复制之后 在将offset之后的写入数据同步到slave上，如果第一次不知道run id是多少 也不知道偏移量是多少 那么 run id 就传？offset 填 1     2. master节点会告诉slave节点的run id和偏移量     3. salve 会保存master的一个基本信息     4. master 执行 持久化相关的bgsave，生一个快照 rdb文件     5. 在生成rdb发给slave之后 实际上redis 还有一个复制缓存区     6. 发送缓存区的数据     7. flush 老数据     8. 加载rdb和缓存区的数据  4. 全量复制的开销     1. bgsave 的时间     2. RDB文件的网络传输时间     3. 从节点清空数据时间     4. 从节点加载rdb时间     5. 可能的aof重写时间     有一个场景就是slave在进行全量复制的过程中 master和slave之间发生了网络抖动，这样在网络抖动期间操作的数据 slave是不知道的，所以2.8之前会再进行一次全量复制 但是全量复制的开销也是比较大的 所以2.8之后 出现了部分复制，将这个损失降到最低  5. 部分复制     1. 连接断开     2. master在写的时候会写一份复制到缓冲区的命令     3. 网络抖动结束 slave继续连接master     4. slave会执行一个psync命令 告诉master 自己的offset和run id     5. offset在master有一个队列的概念 如果offset不在master的队列期间内 证明已经错过了很多数据，会进行全量复制，     6. 如果再范围内，那么会将offset到队列结尾的数据同步给slave ，这样master和slave就达到了一致，后面的那些  6. 故障处理     1. 主从结构故障        1. slave故障-宕机  改成连接其他的slave节点就可        2. master故障宕机 找一个slave 选择成master  执行slaveof no one，其他的节点执行slave of new master，如果故障发生了 每一秒都很重要 最好能脚本化        3. 可以使用redis sentinel来进行故障转移  7. 主从复制     1. 优点        1. 实现高可用，分布式基础        2. 数据备份        3. 读写分离     2. 可能遇到的问题        1. 读写分离        2. 主从配置不一致        3. 规避全量复制        4. 规避复制风暴     3. 读写分离        1. 读流量分摊到从节点        2. 可能遇到的问题           1. 复制数据的延迟            2. 读到过期的数据           3. 从节点故障        3. 配置不一致           1. 主从节点的maxmemory 不一致，丢失数据， 从节点的内存比主节点小会触发最大内存的淘汰策略，将数据进行淘汰，如果过期的数据比较多，那么会优先剔出出去过期的数据，即使oom也不会报错，但是如果当slave晋升成为主节点的时候 就会因为内存不够从而淘汰一些数据            2. 例如数据结构优化参数(例如hash-max-ziplist-entries)： 内存不一致         4. 规避全量复制           1. 产生的条件               1. 第一次全量复制  不可避免                 ​    小主节点 低峰 （maxmemory 设置的小 或者在低峰的时候去复制）              2. 节点运行的id 不匹配                 1. 主节点重启（运行id变化）                 2. 故障转移，例如哨兵或者集群 slave晋升为主节点              3. 复制积压缓冲区不足  （1MB）判断主从的offset 如果没命中就需要进行全量复制                 1. 网络中断，部分复制无法满足                 2. 增大复制缓存去配置rel_backlog_size ，网络增强        5. 规避复制风暴           1. 单节点复制风暴              1. 问题：主节点重启 ，多从节点复制              2. 解决：更换网络拓扑&lt;img src=&quot;/images/redis/image-20201021214920029.png&quot; alt=&quot;image-20201021214920029&quot; style=&quot;zoom:33%;&quot; /&gt;                 这样对于master来说会减轻他的压力，如果不考虑读写分离 那么完全可以在master节点挂掉之后 将slave节点晋升 然后在给它加一个slave 节点就可以了           2. 单机器复制风暴              1. 机器宕机之后 大量全量复制 ，&lt;img src=&quot;/images/redis/image-20201021215320889.png&quot; alt=&quot;image-20201021215320889&quot; style=&quot;zoom: 33%;&quot; /&gt;                 ​    masterA 会进行大量的bgsave 然后传输rdb文件，很有可能会造成内存池满和大量的网络开销或者带宽池满的情况               2. 解决： 我们将master节点分数到多机器上 </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;redis的数据结构和编码&quot;&gt;&lt;a href=&quot;#redis的数据结构和编码&quot; class=&quot;headerlink&quot; title=&quot;redis的数据结构和编码&quot;&gt;&lt;/a&gt;redis的数据结构和编码&lt;/h3&gt;&lt;img src=&quot;/images/redis/image
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Golang小技巧-自定义三元表达式</title>
    <link href="https://richard-xiong.github.io/2020/10/15/Golang%E5%B0%8F%E6%8A%80%E5%B7%A7-%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%89%E5%85%83%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://richard-xiong.github.io/2020/10/15/Golang%E5%B0%8F%E6%8A%80%E5%B7%A7-%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%89%E5%85%83%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2020-10-15T10:29:33.000Z</published>
    <updated>2020-10-15T02:30:34.222Z</updated>
    
    <content type="html"><![CDATA[<p>三元表达式的介绍在这里:</p><ul><li><a href="http://en.wikipedia.org/wiki/%3F">http://en.wikipedia.org/wiki/%3F</a>:</li><li><a href="http://en.wikipedia.org/wiki/IIf">http://en.wikipedia.org/wiki/IIf</a></li></ul><p>Go语言明确不支持三元表达式，这里是相关的讨论：<br><a href="https://groups.google.com/d/msg/golang-nuts/dbyqx_LGUxM/tLFFSXSfOdQJ">https://groups.google.com/d/msg/golang-nuts/dbyqx_LGUxM/tLFFSXSfOdQJ</a></p><p>官方FAQ的说明在这里：<br><a href="http://golang.org/doc/faq#Does_Go_have_a_ternary_form">http://golang.org/doc/faq#Does_Go_have_a_ternary_form</a></p><p>官方FAQ推荐的做法是用 <code>if</code> 代替：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> expr &#123;</span><br><span class="line">    n = trueVal</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    n = falseVal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过用 <code>if</code> 的问题是变量 <code>n</code> 有作用域问题.<br>我们需要在 <code>if</code> 之前先定义变量 <code>n</code>，这样才可以在 <code>if</code> 语句之后使用变量 <code>n</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n <span class="keyword">int</span></span><br><span class="line"><span class="keyword">if</span> expr &#123;</span><br><span class="line">    n = trueVal</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    n = falseVal</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println</span>(n)</span><br></pre></td></tr></table></figure><p>本来一个简单的 <code>n := expr? trueVal: falseVal</code> 就能够表达的问题，变的复杂了很多。<br>这和Go所追求的简单思路是有冲突的。</p><p>类似的有 <code>max</code>/<code>min</code> 等函数。因为这类函数使用频度比较高，在很多pkg的内部都定义了私有的实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>熟悉Go语言的用户应该可以发现，这个 <code>max</code> 只支持 <code>int</code> 类型。<br>对于支持泛型的C++语言来说，<code>max</code> 一般被实现为一个模板函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T&gt;</span><br><span class="line"><span class="keyword">const</span> T&amp; max (<span class="keyword">const</span> T&amp; a, <span class="keyword">const</span> T&amp; b) &#123;</span><br><span class="line">    <span class="keyword">return</span> (a&lt;b)?b:a;     <span class="comment">// or: return comp(a,b)?b:a; for version (2)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在C++版本中，不仅用到的泛型<code>T</code>，还依赖 <code>a&lt;b</code> 的运算符重载特性。<br>在C语言中，虽然没有泛型和运算符重载，但是三元表达式也具备全部的特性（因为表达式天生就是支持泛型的）。</p><p>而这些都是Go语言中缺少的特性。<br>不过在Go语言中可以模拟一个更普通的函数(<code>If</code> 的首字母大写，是函数名，不是 <code>if</code> 关键字)：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">If</span><span class="params">(condition <span class="keyword">bool</span>, trueVal, falseVal <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    <span class="keyword">if</span> condition &#123;</span><br><span class="line">        <span class="keyword">return</span> trueVal</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> falseVal</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a, b := <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">max := If(a &gt; b, a, b).(<span class="keyword">int</span>)</span><br><span class="line"><span class="built_in">println</span>(max)</span><br></pre></td></tr></table></figure><p>有几个关键点：</p><ul><li>Go不支持运算符重载，因此需要先将 <code>a&lt;b</code> 在函数外转换为 <code>bool</code> 条件</li><li>Go不支持泛型，只能用 <code>interface&#123;&#125;</code> 模拟</li><li>返回的类型安全需要用户自己保证，<code>.(type)</code> 的类型必须匹配</li><li><code>interface&#123;&#125;</code> 是运行时泛型，性能没有编译时泛型高</li></ul><p>由此可见，<code>?:</code> 不仅仅是一个简单的三元表达式。其实它更像一个内置的泛型版的函数（因为表达式天生就是支持泛型的）。</p><p>期望未来的Go版本中，能完善对 <code>?:</code> 三元表达式 和 编译时的泛型 的支持。</p><p>补充：<br>星星 同学的提示：可能会导致深入嵌套的滥用： <code>c?d?e?0:1:2:3</code> 。<br>因为三元表达式是一个表达式，必然是允许嵌套的。</p><p>不过我觉得嵌套不是问题的本质，函数也能导致嵌套的滥用。<br>但是不能因为滥用的行为来排斥有存在价值的语法（比如三元表达式）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;三元表达式的介绍在这里:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/%3F&quot;&gt;http://en.wikipedia.org/wiki/%3F&lt;/a&gt;:&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://en.wi
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>golang设计模式之原型模式.md </title>
    <link href="https://richard-xiong.github.io/2020/10/15/golang%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://richard-xiong.github.io/2020/10/15/golang%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-10-14T17:53:03.000Z</published>
    <updated>2020-10-14T13:15:20.062Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>wiki:原型模式是创建型模式的一种，其特点在于通过“复制”一个已经存在的实例来返回新的实例,而不是新建实例。被复制的实例就是我们所称的“原型”，这个原型是可定制的。原型模式多用于创建复杂的或者耗时的实例，因为这种情况下，复制一个已经存在的实例使程序运行更高效；或者创建值相等，只是命名不一样的同类数据。</p></blockquote><p>这是一个十分简单的设计模式,可以看做是其他语言中的克隆方法，例如 <code>JAVA</code>/<code>PHP</code> 中都有相关方法，从一个内存中已经存在的对象中，拷贝出一个一模一样的对象来，针对复杂对象或比较大的对象，要比使用各种设计模式<code>new</code>出来的对象要快的多,</p><p>而且原型模式很少单独使用，一般与其他对象结合使用。</p><h3 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h3><ol><li><p>创建一个结构体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F; 示例结构体</span><br><span class="line">  type Example struct &#123;</span><br><span class="line">      Content string</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li><li><p>添加克隆方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  func (e *Example) Clone() *Example &#123;</span><br><span class="line">      res :&#x3D; *e</span><br><span class="line">      return &amp;res</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>我们仅仅一行代码就完成了值的拷贝，使用 <code>*指针</code>，直接获取了一个拷贝的值，然后将这个拷贝的值得指针返回，原理请阅读下面的扩展阅读。</p></li><li><p>编写主代码</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   func main() &#123;</span><br><span class="line">       r1 :&#x3D; new(Example)</span><br><span class="line">       r1.Content &#x3D; &quot;this is example 1&quot;</span><br><span class="line">       r2 :&#x3D; r1.Clone()</span><br><span class="line">       r2.Content &#x3D; &quot;this is example 2&quot;</span><br><span class="line">   </span><br><span class="line">       fmt.Println(r1)</span><br><span class="line">       fmt.Println(r2)</span><br><span class="line">   </span><br><span class="line">   &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="扩展阅读-深拷贝与浅拷贝"><a href="#扩展阅读-深拷贝与浅拷贝" class="headerlink" title="扩展阅读: 深拷贝与浅拷贝"></a>扩展阅读: 深拷贝与浅拷贝</h3><p><code>go</code> 语言中的传递都是值传递，传递一个对象，就会把对象拷贝一份传入函数中，传递一个指针，就会把指针拷贝一份传入进去。</p><p>赋值的时候也是这样，<code>res:=*e</code> 就会把传递的 <code>Example</code> 对象拷贝一份，如果是 <code>res:=e</code> 的话，那么拷贝的就是对象的指针了.</p><p>而深拷贝和浅拷贝也可以这样理解，深拷贝就是拷贝整个对象，浅拷贝就是拷贝对象指针。</p><p>对于深度拷贝，<code>go</code>和其他语言还经常使用序列化后反序列化的形式进行拷贝:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> func deepCopy(dst, src interface&#123;&#125;) error &#123;</span><br><span class="line">     var buf bytes.Buffer</span><br><span class="line">     if err :&#x3D; gob.NewEncoder(&amp;buf).Encode(src); err !&#x3D; nil &#123;</span><br><span class="line">         return err</span><br><span class="line">     &#125;</span><br><span class="line">     return gob.NewDecoder(bytes.NewBuffer(buf.Bytes())).Decode(dst)</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>实际上<code>gob</code>包序列化的时候也是用到了 <code>reflect</code>包来实现拷贝的</p><p><strong>注意:</strong> golang完全是按值传递，所以如果深度拷贝的对象中包含有指针的话，那么深度拷贝后，这些指针也会相同，会导致部分数据共享，要注意这一点.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;wiki:原型模式是创建型模式的一种，其特点在于通过“复制”一个已经存在的实例来返回新的实例,而不是新建实例。被复制的实例就是我们所称的“原型”，这个原型是可定制的。原型模式多用于创建复杂的或者耗时的实例，因为这种情况下，复制一个已经存在的实例使程
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>golang设计模式之建造者模式</title>
    <link href="https://richard-xiong.github.io/2020/10/14/golang%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://richard-xiong.github.io/2020/10/14/golang%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-10-13T20:43:21.000Z</published>
    <updated>2020-10-14T09:52:11.663Z</updated>
    
    <content type="html"><![CDATA[<h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><p>建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</p><p><strong>主要解决：</strong>主要解决在软件系统中，有时候面临着”一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。</p><p><strong>何时使用：</strong>一些基本部件不会变，而其组合经常变化的时候。</p><p><strong>如何解决：</strong>将变与不变分离开。</p><p><strong>关键代码：</strong>建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。</p><p><strong>应用实例：</strong> 1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的”套餐”。 2、JAVA 中的 StringBuilder。</p><p><strong>优点：</strong> 1、建造者独立，易扩展。 2、便于控制细节风险。</p><p><strong>缺点：</strong> 1、产品必须有共同点，范围有限制。 2、如内部变化复杂，会有很多的建造类。</p><p><strong>使用场景：</strong> 1、需要生成的对象具有复杂的内部结构。 2、需要生成的对象内部属性本身相互依赖。</p><p><strong>注意事项：</strong>与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们假设一个快餐店的商业案例，其中，一个典型的套餐可以是一个汉堡（Burger）和一杯冷饮（Cold drink）。汉堡（Burger）可以是素食汉堡（Veg Burger）或鸡肉汉堡（Chicken Burger），它们是包在纸盒中。冷饮（Cold drink）可以是可口可乐（coke）或百事可乐（pepsi），它们是装在瓶子中。</p><p>我们将创建一个表示食物条目（比如汉堡和冷饮）的 <em>Item</em> 接口和实现 <em>Item</em> 接口的实体类，以及一个表示食物包装的 <em>Packing</em> 接口和实现 <em>Packing</em> 接口的实体类，汉堡是包在纸盒中，冷饮是装在瓶子中。</p><p>然后我们创建一个 <em>Meal</em> 类，带有 <em>Item</em> 的 <em>ArrayList</em> 和一个通过结合 <em>Item</em> 来创建不同类型的 <em>Meal</em> 对象的 <em>MealBuilder</em>。<em>BuilderPatternDemo</em>，我们的演示类使用 <em>MealBuilder</em> 来创建一个 <em>Meal</em>。</p><p><img src="/images/golang%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/builder_pattern_uml_diagram.jpg" alt="建造者模式的 UML 图"></p><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤 1"></a>步骤 1</h3><p>创建一个表示食物条目和食物包装的接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Item <span class="keyword">interface</span> &#123;</span><br><span class="line">   GetName() <span class="keyword">string</span></span><br><span class="line">   GetPacking() Packing</span><br><span class="line">   GetPrice() <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Packing <span class="keyword">interface</span> &#123;</span><br><span class="line">    GetPack() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤 2"></a>步骤 2</h3><p>创建实现 Packing 接口的实体类。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Wrapper <span class="keyword">struct</span> &#123;</span><br><span class="line">    Pack <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Wrapper)</span> <span class="title">GetPack</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Wrapper&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Bottle <span class="keyword">struct</span> &#123;</span><br><span class="line">    Pack <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Bottle)</span> <span class="title">GetPack</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Bottle&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤 3"></a>步骤 3</h3><p>创建实现 Item 接口的抽象类，该类提供了默认的功能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Burger <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Burger)</span> <span class="title">GetPacking</span><span class="params">(item Item)</span> <span class="title">Packing</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item.GetPacking()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Burger)</span> <span class="title">GetPrice</span><span class="params">(item Item)</span><span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item.GetPrice()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Burger)</span> <span class="title">GetName</span><span class="params">(item Item)</span><span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item.GetName()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ColdDrink <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *ColdDrink)</span> <span class="title">GetPacking</span><span class="params">(item Item)</span> <span class="title">Packing</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item.GetPacking()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *ColdDrink)</span> <span class="title">GetPrice</span><span class="params">(item Item)</span><span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item.GetPrice()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *ColdDrink)</span> <span class="title">GetName</span><span class="params">(item Item)</span><span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item.GetName()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤 4"></a>步骤 4</h3><p>创建扩展了 Burger 和 ColdDrink 的实体类。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ChickenBurger <span class="keyword">struct</span> &#123;</span><br><span class="line">    Burger</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *ChickenBurger)</span> <span class="title">GetPrice</span><span class="params">()</span> <span class="title">float64</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">50.5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(this *ChickenBurger)</span> <span class="title">GetName</span><span class="params">()</span><span class="title">string</span></span>  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Chicken Burger&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *ChickenBurger)</span> <span class="title">GetPacking</span><span class="params">()</span> <span class="title">Packing</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">new</span>(Wrapper)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> VegBurger <span class="keyword">struct</span> &#123;</span><br><span class="line">    Burger</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *VegBurger)</span> <span class="title">GetPrice</span><span class="params">()</span> <span class="title">float64</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">25.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(this *VegBurger)</span> <span class="title">GetName</span><span class="params">()</span><span class="title">string</span></span>  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Veg Burger&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *VegBurger)</span> <span class="title">GetPacking</span><span class="params">()</span> <span class="title">Packing</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">new</span>(Wrapper)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Coke <span class="keyword">struct</span> &#123;</span><br><span class="line">    ColdDrink</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Coke)</span> <span class="title">GetPrice</span><span class="params">()</span> <span class="title">float64</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">30.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(this *Coke)</span> <span class="title">GetName</span><span class="params">()</span><span class="title">string</span></span>  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Coke&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Coke)</span> <span class="title">GetPacking</span><span class="params">()</span> <span class="title">Packing</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">new</span>(Bottle)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Pepsi <span class="keyword">struct</span> &#123;</span><br><span class="line">    ColdDrink</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Pepsi)</span> <span class="title">GetPrice</span><span class="params">()</span> <span class="title">float64</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">35.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(this *Pepsi)</span> <span class="title">GetName</span><span class="params">()</span><span class="title">string</span></span>  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Pepsi&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Pepsi)</span> <span class="title">GetPacking</span><span class="params">()</span> <span class="title">Packing</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">new</span>(Bottle)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="步骤-5"><a href="#步骤-5" class="headerlink" title="步骤 5"></a>步骤 5</h3><p>创建一个 Meal 类，带有上面定义的 Item 对象。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Meal <span class="keyword">struct</span> &#123;</span><br><span class="line">    Items []Item</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Meal)</span> <span class="title">AddItem</span><span class="params">(item Item)</span></span> &#123;</span><br><span class="line">    this.Items = <span class="built_in">append</span>(this.Items, item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Meal)</span> <span class="title">GetCost</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> cost <span class="keyword">float64</span></span><br><span class="line">    <span class="keyword">for</span> _, item := <span class="keyword">range</span> this.Items &#123;</span><br><span class="line">        cost += item.GetPrice()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cost</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Meal)</span> <span class="title">ShowItems</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, item := <span class="keyword">range</span> this.Items &#123;</span><br><span class="line">        fmt.Print(<span class="string">&quot;Item : &quot;</span> + item.GetName())</span><br><span class="line">        fmt.Print(<span class="string">&quot;, Packing : &quot;</span> + item.GetPacking().GetPack())</span><br><span class="line">        fmt.Println(<span class="string">&quot;, Price : &quot;</span> + fmt.Sprintf(<span class="string">&quot;%f&quot;</span>, item.GetPrice()))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="步骤-6"><a href="#步骤-6" class="headerlink" title="步骤 6"></a>步骤 6</h3><p>创建一个 MealBuilder 类，实际的 builder 类负责创建 Meal 对象。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetPrepareNonVegMea</span><span class="params">()</span> <span class="title">Meal</span></span> &#123;</span><br><span class="line">    meal := <span class="built_in">new</span>(Meal)</span><br><span class="line">    meal.AddItem(<span class="built_in">new</span>(ChickenBurger))</span><br><span class="line">    meal.AddItem(<span class="built_in">new</span>(Pepsi))</span><br><span class="line">    <span class="keyword">return</span> *meal</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetPrepareVegMeal</span><span class="params">()</span> <span class="title">Meal</span></span> &#123;</span><br><span class="line">    meal := <span class="built_in">new</span>(Meal)</span><br><span class="line">    meal.AddItem(<span class="built_in">new</span>(VegBurger))</span><br><span class="line">    meal.AddItem(<span class="built_in">new</span>(Coke))</span><br><span class="line">    <span class="keyword">return</span> *meal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-7"><a href="#步骤-7" class="headerlink" title="步骤 7"></a>步骤 7</h3><p>BuiderPatternDemo 使用 MealBuider 来演示建造者模式（Builder Pattern）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    nonVegMeal := meal.GetPrepareNonVegMea()</span><br><span class="line">    fmt.Println(<span class="string">&quot;\\n\\nNon-Veg Meal&quot;</span>)</span><br><span class="line">    nonVegMeal.ShowItems()</span><br><span class="line">    fmt.Println(<span class="string">&quot;Total Cost: &quot;</span> + fmt.Sprintf(<span class="string">&quot;%f&quot;</span>, nonVegMeal.GetCost()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    VegMeal := meal.GetPrepareVegMeal()</span><br><span class="line">    fmt.Println(<span class="string">&quot;\\n\\nVegMeal Meal&quot;</span>)</span><br><span class="line">    VegMeal.ShowItems()</span><br><span class="line">    fmt.Println(<span class="string">&quot;Total Cost: &quot;</span> + fmt.Sprintf(<span class="string">&quot;%f&quot;</span>, VegMeal.GetCost()))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-8"><a href="#步骤-8" class="headerlink" title="步骤 8"></a>步骤 8</h3><p>执行程序，输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\n\nNon-Veg Meal</span><br><span class="line">Item : Chicken Burger, Packing : Wrapper, Price : 50.500000</span><br><span class="line">Item : Pepsi, Packing : Bottle, Price : 35.000000</span><br><span class="line">Total Cost: 85.500000</span><br><span class="line">\n\nVegMeal Meal</span><br><span class="line">Item : Veg Burger, Packing : Wrapper, Price : 25.000000</span><br><span class="line">Item : Coke, Packing : Bottle, Price : 30.000000</span><br><span class="line">Total Cost: 55.000000</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;建造者模式&quot;&gt;&lt;a href=&quot;#建造者模式&quot; class=&quot;headerlink&quot; title=&quot;建造者模式&quot;&gt;&lt;/a&gt;建造者模式&lt;/h1&gt;&lt;p&gt;建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>golang开发技巧-实现抽象类</title>
    <link href="https://richard-xiong.github.io/2020/10/14/golang%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7-%E5%AE%9E%E7%8E%B0%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    <id>https://richard-xiong.github.io/2020/10/14/golang%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7-%E5%AE%9E%E7%8E%B0%E6%8A%BD%E8%B1%A1%E7%B1%BB/</id>
    <published>2020-10-13T17:43:58.000Z</published>
    <updated>2020-10-13T09:45:14.608Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍了一种通过 struct 和 interface 来在 golang 中实现抽象类的方式。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 Java 这种面向对象的语言中，抽象类和接口是我们经常会运用到的 2 种对抽象概念进行定义的机制。在 golang 中，没有类和继承的概念。golang 中有结构体（struct），和面向对象语言中的类相似。golang 中也有接口（interface），接口可以定义一组不含有具体实现的方法，其提供了一种方式来说明对象的行为。</p><p>然而，在某些情况下，我们需要使用抽象类继承，来帮助我们写出更优雅的代码。可是在 golang 中又没有抽象类的概念，本文将介绍一种通过 struct 和 interface 来在 golang 中实现抽象类的方法。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>首先，我们会用 Java 语言作为示例，来看看如何在面向对象语言中实现抽象类。接着换 golang 语言，通过 struct 和 interface 来实现抽象类，完成相同的功能。</p><h4 id="面向对象语言中抽象类的实现"><a href="#面向对象语言中抽象类的实现" class="headerlink" title="面向对象语言中抽象类的实现"></a>面向对象语言中抽象类的实现</h4><p>假设我们需要实现下面这样的几个类（使用 Java 为例）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Game</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name() + <span class="string">&quot; is awesome!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dota</span> <span class="keyword">extends</span> <span class="title">Game</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Dota&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LOL</span> <span class="keyword">extends</span> <span class="title">Game</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;LOL&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们定义了 Game 抽象类，在此类中定义了 <code>public abstract String name();</code> 一个抽象方法和 <code>public void play()</code> 这样一个公开方法。然后我们定义了 <code>Dota</code> 和 <code>LOL</code> 2个类去继承 <code>Game</code>，并各自实现了 <code>public String name()</code>。</p><p>接下来让我们看看如何在 golang 中实现抽象类。</p><h4 id="golang-中实现抽象类的方式"><a href="#golang-中实现抽象类的方式" class="headerlink" title="golang 中实现抽象类的方式"></a>golang 中实现抽象类的方式</h4><ul><li>定义 interface</li></ul><p>首先，我们需要将抽象方法定义在 interface 中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IGame <span class="keyword">interface</span> &#123;</span><br><span class="line">    Name() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>定义”父类”</li></ul><p>然后，我们需要使用 struct 实现公共方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Game <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Game)</span> <span class="title">play</span><span class="params">(game IGame)</span></span> &#123;</span><br><span class="line">    fmt.Printf(fmt.Sprintf(<span class="string">&quot;%s is awesome!&quot;</span>, game.Name()))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是重点，我们将 <code>game IGame</code> 传了进来。这样我们便可以调用”子类”的方法来获取名字。<strong>从而间接地实现了在公共方法中调用不同”子类”的实现的抽象方法。</strong></p><ul><li>定义”子类”</li></ul><p>接着，我们再定义”Dota”和”LOL”这 2 个 struct 即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Dota <span class="keyword">struct</span> &#123;</span><br><span class="line">    Game</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dota)</span> <span class="title">Name</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Dota&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LOL <span class="keyword">struct</span> &#123;</span><br><span class="line">    Game</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LOL)</span> <span class="title">Name</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;LOL&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>大功告成</li></ul><p>现在，在初始化”Dota”和”LOL”结构体后，便可以调用 <code>func (g *Game) play(game IGame)</code> 方法了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dota := &amp;Dota&#123;&#125;</span><br><span class="line">dota.play(dota)</span><br><span class="line"></span><br><span class="line">lol := &amp;LOL&#123;&#125;</span><br><span class="line">lol.play(lol)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">//Dota is awesome!</span></span><br><span class="line"><span class="comment">//LOL is awesome!</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文通过 struct 和 interface 的组合，提供了一种思路，间接实现了面向对象语言中的抽象类继承的模式。旨在提供一种思路，希望能帮助到需要的同学，欢迎讨论 :)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文介绍了一种通过 struct 和 interface 来在 golang 中实现抽象类的方式。&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在 Java 这种面向对象
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Golang疑问 Use of new vs var in Go</title>
    <link href="https://richard-xiong.github.io/2020/10/13/Golang%E7%96%91%E9%97%AE-Use-of-new-vs-var-in-Go/"/>
    <id>https://richard-xiong.github.io/2020/10/13/Golang%E7%96%91%E9%97%AE-Use-of-new-vs-var-in-Go/</id>
    <published>2020-10-12T20:58:57.000Z</published>
    <updated>2020-10-12T13:36:35.679Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Q： Is there any difference between:</strong></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b bar</span><br><span class="line">foo(&amp;b)</span><br></pre></td></tr></table></figure><p>and</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b := <span class="built_in">new</span>(bar)</span><br><span class="line">foo(b)</span><br></pre></td></tr></table></figure><p>The use of new creates an allocation.</p><p><strong>A： No, there is no difference, as, contrary to C, Go explicitly states that you can give a pointer to a locally created variable.</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Q： Is there any difference between:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight golang&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>golang设计模式之单例模式</title>
    <link href="https://richard-xiong.github.io/2020/10/13/golang%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://richard-xiong.github.io/2020/10/13/golang%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-10-12T20:42:48.000Z</published>
    <updated>2020-10-12T12:56:57.370Z</updated>
    
    <content type="html"><![CDATA[<p>在过去的几年中，Go语言的发展是惊人的，并且吸引了很多由其他语言（Python、PHP、Ruby）转向Go语言的跨语言学习者。 Go语言太容易实现并发了，以至于它在很多地方被不正确的使用了。</p><h2 id="Go语言中的单例模式"><a href="#Go语言中的单例模式" class="headerlink" title="Go语言中的单例模式"></a>Go语言中的单例模式</h2><p>在过去的几年中，Go语言的发展是惊人的，并且吸引了很多由其他语言（Python、PHP、Ruby）转向Go语言的跨语言学习者。</p><p>在过去的很长时间里，很多开发人员和初创公司都习惯使用Python、PHP或Ruby快速开发功能强大的系统，并且大多数情况下都不需要担心内部事务如何工作，也不需要担心线程安全性和并发性。直到最近几年，多线程高并发的系统开始流行起来，我们现在不仅需要快速开发功能强大的系统，而且还要保证被开发的系统能够足够快速运行。（我们真是太难了☺️）</p><p>对于被Go语言天生支持并发的特性吸引来的跨语言学习者来说，我觉着掌握Go语言的语法并不是最难的，最难的是突破既有的思维定势，真正理解并发和使用并发来解决实际问题。</p><p>Go语言太容易实现并发了，以至于它在很多地方被不正确的使用了。</p><h3 id="常见的错误"><a href="#常见的错误" class="headerlink" title="常见的错误"></a>常见的错误</h3><p>有一些错误是很常见的，比如不考虑并发安全的单例模式。就像下面的示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> singleton <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance *singleton</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span> *<span class="title">singleton</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> instance == <span class="literal">nil</span> &#123;</span><br><span class="line">        instance = &amp;singleton&#123;&#125;   <span class="comment">// 不是并发安全的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述情况下，多个goroutine可以执行第一个检查，并且它们都将创建该<code>singleton</code>类型的实例并相互覆盖。无法保证它将在此处返回哪个实例，并且对该实例的其他进一步操作可能与开发人员的期望不一致。</p><p>不好的原因是，如果有代码保留了对该单例实例的引用，则可能存在具有不同状态的该类型的多个实例，从而产生潜在的不同代码行为。这也成为调试过程中的一个噩梦，并且很难发现该错误，因为在调试时，由于运行时暂停而没有出现任何错误，这使非并发安全执行的可能性降到了最低，并且很容易隐藏开发人员的问题。</p><h3 id="激进的加锁"><a href="#激进的加锁" class="headerlink" title="激进的加锁"></a>激进的加锁</h3><p>也有很多对这种并发安全问题的糟糕解决方案。使用下面的代码确实能解决并发安全问题，但会带来其他潜在的严重问题，通过加锁把对该函数的并发调用变成了串行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mu Sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span> *<span class="title">singleton</span></span> &#123;</span><br><span class="line">    mu.Lock()                    <span class="comment">// 如果实例存在没有必要加锁</span></span><br><span class="line">    <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> instance == <span class="literal">nil</span> &#123;</span><br><span class="line">        instance = &amp;singleton&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们可以看到在创建单例实例之前通过引入<code>Sync.Mutex</code>和获取Lock来解决并发安全问题。问题是我们在这里执行了过多的锁定，即使我们不需要这样做，在实例已经创建的情况下，我们应该简单地返回缓存的单例实例。在高度并发的代码基础上，这可能会产生瓶颈，因为一次只有一个goroutine可以获得单例实例。</p><p>因此，这不是最佳方法。我们必须考虑其他解决方案。</p><h3 id="Check-Lock-Check模式"><a href="#Check-Lock-Check模式" class="headerlink" title="Check-Lock-Check模式"></a>Check-Lock-Check模式</h3><p>在C ++和其他语言中，确保最小程度的锁定并且仍然是并发安全的最佳和最安全的方法是在获取锁定时利用众所周知的<code>Check-Lock-Check</code>模式。该模式的伪代码表示如下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> check() &#123;</span><br><span class="line">    lock() &#123;</span><br><span class="line">        <span class="keyword">if</span> check() &#123;</span><br><span class="line">            <span class="comment">// 在这里执行加锁安全的代码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该模式背后的思想是，你应该首先进行检查，以最小化任何主动锁定，因为IF语句的开销要比加锁小。其次，我们希望等待并获取互斥锁，这样在同一时刻在那个块中只有一个执行。但是，在第一次检查和获取互斥锁之间，可能有其他goroutine获取了锁，因此，我们需要在锁的内部再次进行检查，以避免用另一个实例覆盖了实例。</p><p>如果将这种模式应用于我们的<code>GetInstance()</code>方法，我们会写出类似下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span> *<span class="title">singleton</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> instance == <span class="literal">nil</span> &#123;     <span class="comment">// 不太完美 因为这里不是完全原子的</span></span><br><span class="line">        mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> instance == <span class="literal">nil</span> &#123;</span><br><span class="line">            instance = &amp;singleton&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过使用<code>sync/atomic</code>这个包，我们可以原子化加载并设置一个标志，该标志表明我们是否已初始化实例。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> initialized <span class="keyword">uint32</span></span><br><span class="line">... <span class="comment">// 此处省略</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span> *<span class="title">singleton</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> atomic.LoadUInt32(&amp;initialized) == <span class="number">1</span> &#123;  <span class="comment">// 原子操作 </span></span><br><span class="line">            <span class="keyword">return</span> instance</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> initialized == <span class="number">0</span> &#123;</span><br><span class="line">         instance = &amp;singleton&#123;&#125;</span><br><span class="line">         atomic.StoreUint32(&amp;initialized, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是……这看起来有点繁琐了，我们其实可以通过研究Go语言和标准库如何实现goroutine同步来做得更好。</p><h3 id="Go语言惯用的单例模式"><a href="#Go语言惯用的单例模式" class="headerlink" title="Go语言惯用的单例模式"></a>Go语言惯用的单例模式</h3><p>我们希望利用Go惯用的方式来实现这个单例模式。我们在标准库<code>sync</code>中找到了<code>Once</code>类型。它能保证某个操作仅且只执行一次。下面是来自Go标准库的源码（部分注释有删改）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Once is an object that will perform exactly one action.</span></span><br><span class="line"><span class="keyword">type</span> Once <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// done indicates whether the action has been performed.</span></span><br><span class="line">    <span class="comment">// It is first in the struct because it is used in the hot path.</span></span><br><span class="line">    <span class="comment">// The hot path is inlined at every call site.</span></span><br><span class="line">    <span class="comment">// Placing done first allows more compact instructions on some architectures (amd64/x86),</span></span><br><span class="line">    <span class="comment">// and fewer instructions (to calculate offset) on other architectures.</span></span><br><span class="line">    done <span class="keyword">uint32</span></span><br><span class="line">    m    Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">Do</span><span class="params">(f <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> atomic.LoadUint32(&amp;o.done) == <span class="number">0</span> &#123; <span class="comment">// check</span></span><br><span class="line">        <span class="comment">// Outlined slow-path to allow inlining of the fast-path.</span></span><br><span class="line">        o.doSlow(f)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">doSlow</span><span class="params">(f <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">    o.m.Lock()                          <span class="comment">// lock</span></span><br><span class="line">    <span class="keyword">defer</span> o.m.Unlock()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> o.done == <span class="number">0</span> &#123;                    <span class="comment">// check</span></span><br><span class="line">        <span class="keyword">defer</span> atomic.StoreUint32(&amp;o.done, <span class="number">1</span>)</span><br><span class="line">        f()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这说明我们可以借助这个实现只执行一次某个函数/方法，<code>once.Do()</code>的用法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 在这里执行安全的初始化</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>下面就是单例实现的完整代码，该实现利用<code>sync.Once</code>类型去同步对<code>GetInstance()</code>的访问，并确保我们的类型仅被初始化一次。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> singleton <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance *singleton</span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span> *<span class="title">singleton</span></span> &#123;</span><br><span class="line">    once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        instance = &amp;singleton&#123;&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，使用<code>sync.Once</code>包是安全地实现此目标的首选方式，类似于Objective-C和Swift（Cocoa）实现<code>dispatch_once</code>方法来执行类似的初始化。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>当涉及到并发和并行代码时，需要对代码进行更仔细的检查。始终让你的团队成员执行代码审查，因为这样的事情很容易就会被发现。</p><p>所有刚转到Go语言的新开发人员都必须真正了解并发安全性如何工作以更好地改进其代码。即使Go语言本身通过允许你在对并发性知识知之甚少的情况下设计并发代码，也完成了许多繁重的工作。在某些情况下，单纯的依靠语言特性也无能为力，你仍然需要在开发代码时应用最佳实践。</p><p>翻译自<a href="http://marcio.io/2015/07/singleton-pattern-in-go/%EF%BC%8C%E8%80%83%E8%99%91%E5%88%B0%E5%8F%AF%E8%AF%BB%E6%80%A7%E9%83%A8%E5%88%86%E5%86%85%E5%AE%B9%E6%9C%89%E4%BF%AE%E6%94%B9%E3%80%82">http://marcio.io/2015/07/singleton-pattern-in-go/，考虑到可读性部分内容有修改。</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在过去的几年中，Go语言的发展是惊人的，并且吸引了很多由其他语言（Python、PHP、Ruby）转向Go语言的跨语言学习者。 Go语言太容易实现并发了，以至于它在很多地方被不正确的使用了。&lt;/p&gt;
&lt;h2 id=&quot;Go语言中的单例模式&quot;&gt;&lt;a href=&quot;#Go语言中的单
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>golang技术准备</title>
    <link href="https://richard-xiong.github.io/2020/10/13/golang%E6%8A%80%E6%9C%AF%E5%87%86%E5%A4%87/"/>
    <id>https://richard-xiong.github.io/2020/10/13/golang%E6%8A%80%E6%9C%AF%E5%87%86%E5%A4%87/</id>
    <published>2020-10-12T16:36:37.000Z</published>
    <updated>2020-10-12T12:40:21.391Z</updated>
    
    <content type="html"><![CDATA[<p>golang技术准备</p><ol><li>数据结构与算法</li><li>设计模式  </li><li>golang基本知识&amp;底层实现原理</li><li>中间件 redis、mq、mysql、mangodb、memcache、dynamodb </li><li>线程和携程 </li><li>golang和java的对比</li><li>mysql分库分表 深入理解索引 二叉树 红黑树</li><li>docker&amp;k8s的使用  </li><li>CI/CD 的使用</li><li>gRPC&amp;go-kit&amp;goMicro的使用 </li><li>项目经验 </li><li>带团队经验</li></ol><p>1、设计模式 23种 预计23个小时</p><p>2、数据结构与算法 200道题 200个小时</p><p>3、golang基本知识&amp;底层实现原理 50个小时</p><p>​         <a href="https://tiancaiamao.gitbooks.io/go-internals/content/zh/06.2.html">https://tiancaiamao.gitbooks.io/go-internals/content/zh/06.2.html</a></p><p>​        <a href="https://mubu.com/doc/explore/23357">https://mubu.com/doc/explore/23357</a></p><p>​    <a href="https://mubu.com/doc/explore/23447">https://mubu.com/doc/explore/23447</a></p><p><a href="https://adolphlwq.xyz/blog/#/go/basics">https://adolphlwq.xyz/blog/#/go/basics</a></p><p><strong><a href="https://www.processon.com/view/link/5a9ba4c8e4b0a9d22eb3bdf0#map">https://www.processon.com/view/link/5a9ba4c8e4b0a9d22eb3bdf0#map</a></strong></p><ol start="4"><li>中间件 redis、mq、mysql、mangodb、memcache、dynamodb  20个小时</li><li>2个小时</li><li>1个小时</li><li>10个小时</li><li>5个小时</li></ol><p>预计300个小时 每天工作 2个小时 回家2个小时  预计75d  3个月</p><p>规划 </p><p>每天任务 </p><p>1个设计模式  </p><p>1个leetcode</p><p>1个go的底层知识</p><p>1 个 mysql或者redis原理</p><p>在过去的几年中，Go语言的发展是惊人的，并且吸引了很多由其他语言（Python、PHP、Ruby）转向Go语言的跨语言学习者。 Go语言太容易实现并发了，以至于它在很多地方被不正确的使用了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;golang技术准备&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据结构与算法&lt;/li&gt;
&lt;li&gt;设计模式  &lt;/li&gt;
&lt;li&gt;golang基本知识&amp;amp;底层实现原理&lt;/li&gt;
&lt;li&gt;中间件 redis、mq、mysql、mangodb、memcache、dynamodb &lt;/li
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>golang设计模式之工厂方法模式</title>
    <link href="https://richard-xiong.github.io/2020/10/13/golang%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>https://richard-xiong.github.io/2020/10/13/golang%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-10-12T16:29:10.000Z</published>
    <updated>2020-10-12T08:32:32.359Z</updated>
    
    <content type="html"><![CDATA[<h1 id="golang设计模式之工厂方法模式"><a href="#golang设计模式之工厂方法模式" class="headerlink" title="golang设计模式之工厂方法模式"></a>golang设计模式之工厂方法模式</h1><h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><blockquote><p>wiki: 工厂方法模式（英语：Factory method pattern）是一种实现了“工厂”概念的面向对象设计模式。就像其他创建型模式一样，它也是处理在不指定对象具体类型的情况下创建对象的问题。工厂方法模式的实质是“定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。”</p></blockquote><p>上面是 维基百科 中对工厂方法的定义，唯一的一个工厂控制着 所有产品的实例化，而 <code>工厂方法</code> 中包括一个工厂接口，我们可以动态的实现多种工厂，达到扩展的目的</p><ul><li>简单工厂需要:<ol><li>工厂结构体</li><li>产品接口</li><li>产品结构体</li></ol></li><li>工厂方法需要:<ol><li>工厂接口</li><li>工厂结构体</li><li>产品接口</li><li>产品结构体</li></ol></li></ul><p>在 <code>简单工厂</code> 中，依赖于唯一的工厂对象，如果我们需要实例化一个产品，那么就要向工厂中传入一个参数获取对应对象，如果要增加一种产品，就要在工厂中修改创建产品的函数，耦合性过高 ，而在 <code>工厂方法</code> 中，依赖工厂接口，我们可以通过实现工厂接口，创建多种工厂，将对象创建由一个对象负责所有具体类的实例化，变成由一群子类来负责对具体类的实例化，将过程解耦。</p><p>下面用代码实现：</p><p>例如，我们现在有一个产品需要被创建，那么先构建工厂接口和产品接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 工厂接口</span></span><br><span class="line"> <span class="keyword">type</span> FactoryInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">       CreateProduct(t <span class="keyword">string</span>) ProductInterface</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 产品接口</span></span><br><span class="line"><span class="keyword">type</span> ProductInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">    Intro()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后实现这两个接口: 工厂结构体和产品结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建工厂结构体并实现工厂接口</span></span><br><span class="line"><span class="keyword">type</span> Factory1 <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f Factory1)</span> <span class="title">CreateProduct</span><span class="params">(t <span class="keyword">string</span>)</span> <span class="title">ProductInterface</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> t &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;product1&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> Product1&#123;&#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建产品1并实现产品接口</span></span><br><span class="line"><span class="keyword">type</span> Product1 <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Product1)</span> <span class="title">Intro</span><span class="params">()</span></span> &#123;</span><br><span class="line"> fmt.Println(<span class="string">&quot;this is product 1&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在使用的时候，就可以让子类来选择实例化哪种产品:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建工厂</span></span><br><span class="line">    f := <span class="built_in">new</span>(Factory1)</span><br><span class="line"></span><br><span class="line">    p := f.CreateProduct(<span class="string">&quot;product1&quot;</span>)</span><br><span class="line">    p.Intro()  <span class="comment">// output:  this is product 1.</span></span><br></pre></td></tr></table></figure><p>或许上面的代码看起来并不容易懂，因为我们只有一种产品，不能看出来它的好处，在网上我看到了一个卖包子的例子，我觉得很贴切，在这我就用go实现一下,辅助理解:</p><p>栗子: 我现在想在我的老家齐齐哈尔开一家包子店，卖猪肉馅和三鲜馅两种馅料的包子，那么我们使用简单工厂模式应该怎样实现呢？</p><ul><li><p>简单工厂模式实现:</p><ol><li><p>创建工厂结构体（包子店）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工厂类(包子店)</span></span><br><span class="line"><span class="keyword">type</span> BunShop <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建产品接口(包子类的接口)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Bun <span class="keyword">interface</span> &#123;</span><br><span class="line">    create()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现产品（2种包子）</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PigMeatBuns <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p PigMeatBuns)</span> <span class="title">create</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;猪肉馅包子&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> SamSunStuffingBuns <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s SamSunStuffingBuns)</span> <span class="title">create</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;三鲜馅包子&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>为工厂添加生产包子的方法</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b BunShop)</span> <span class="title">Generate</span><span class="params">(t <span class="keyword">string</span>)</span> <span class="title">Bun</span></span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> t &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;pig&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> PigMeatBuns&#123;&#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;3s&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> SamSunStuffingBuns&#123;&#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>这样一个简单工厂模式就完成了:</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">factory := <span class="built_in">new</span>(BunShop)</span><br><span class="line">b := factory.Generate(<span class="string">&quot;pig&quot;</span>)</span><br><span class="line">b.create() <span class="comment">// output: 猪肉馅包子</span></span><br></pre></td></tr></table></figure></li></ul><p>可是如果生意做的不错，我想要在广东开一家分店该怎么办呢？依旧是两种包子，但是为了符合当地人的口味，一定会有所差别，难道要一步一步的修改工厂类吗？</p><p>这样工厂方法模式就派上用场了…</p><ol><li><p>添加工厂接口(包子店的接口)和产品接口(包子接口)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> BunShopInterface <span class="keyword">interface</span>&#123;</span><br><span class="line">   Generate(t <span class="keyword">string</span>) Bun</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">type</span> Bun <span class="keyword">interface</span> &#123;</span><br><span class="line">   create()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建工厂结构体和产品结构体（具体包子店和具体包子）</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> QSPigMeatBuns <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> GDPigMeatBuns <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> QSSamSunStuffingBuns <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> GDSamSunStuffingBuns <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现产品接口...  这里就不写了</span></span><br><span class="line"><span class="comment">// CODE ...</span></span><br></pre></td></tr></table></figure><ol><li>创建对应的工厂（齐市包子店和广东包子店）</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> QSBunShop <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GDBunShop <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(qs QSBunShop)</span> <span class="title">Generate</span><span class="params">(t <span class="keyword">string</span>)</span> <span class="title">Bun</span></span> &#123;</span><br><span class="line">   <span class="keyword">switch</span> t &#123;</span><br><span class="line">       <span class="keyword">case</span> <span class="string">&quot;pig&quot;</span>:</span><br><span class="line">         <span class="keyword">return</span> QSPigMeatBuns&#123;&#125;</span><br><span class="line">       <span class="keyword">case</span> <span class="string">&quot;3s&quot;</span>:</span><br><span class="line">         <span class="keyword">return</span> QSSamSunStuffingBuns&#123;&#125;</span><br><span class="line">       <span class="keyword">default</span>:</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(gd QSBunShop)</span> <span class="title">Generate</span><span class="params">(t <span class="keyword">string</span>)</span> <span class="title">Bun</span></span> &#123;</span><br><span class="line">     <span class="keyword">switch</span> t &#123;</span><br><span class="line">       <span class="keyword">case</span> <span class="string">&quot;pig&quot;</span>:</span><br><span class="line">         <span class="keyword">return</span> GDPigMeatBuns&#123;&#125;</span><br><span class="line">       <span class="keyword">case</span> <span class="string">&quot;3s&quot;</span>:</span><br><span class="line">         <span class="keyword">return</span> GDSamSunStuffingBuns&#123;&#125;</span><br><span class="line">       <span class="keyword">default</span>:</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">       &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol><li>这样，就完成了工厂方法模式</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b Bun</span><br><span class="line"><span class="comment">// 卖呀卖呀卖包子...</span></span><br><span class="line">QSFactory := <span class="built_in">new</span>(QSBunShop)</span><br><span class="line">b = QSFactory.Generate(<span class="string">&quot;pig&quot;</span>)  <span class="comment">// 传入猪肉馅的参数，会返回齐市包子铺的猪肉馅包子</span></span><br><span class="line">b.create()</span><br><span class="line"></span><br><span class="line">GDFactory := <span class="built_in">new</span>(GDBunShop)</span><br><span class="line">b = GDFactory.Generate(<span class="string">&quot;pig&quot;</span>) <span class="comment">// 同样传入猪肉馅的参数，会返回广东包子铺的猪肉馅包子</span></span><br><span class="line">b.create()</span><br></pre></td></tr></table></figure><blockquote><p>go中没有继承，实际上可以以组合的方式达到继承的目的</p></blockquote><p>简单工厂模式和工厂方法模式看起来很相似，本质区别就在于，如果在包子店中直接创建包子产品，是依赖具体包子店的，扩展性、弹性、可维护性都较差，而如果将实例化的代码抽象出来，不再依赖具体包子店，而是依赖于抽象的包子接口，使对象的实现从使用中解耦，这样就拥有很强的扩展性了，也可以称为 『依赖倒置原则』</p><p>工厂方法模式的优缺点</p><ul><li>优点:<ol><li>符合“开闭”原则，具有很强的的扩展性、弹性和可维护性。修改时只需要添加对应的工厂类即可</li><li>使用了依赖倒置原则，依赖抽象而不是具体，使用（客户）和实现（具体类）松耦合</li><li>客户只需要知道所需产品的具体工厂，而无须知道具体工厂的创建产品的过程，甚至不需要知道具体产品的类名。</li></ol></li><li>缺点:<ol><li>每增加一个产品时，都需要一个具体类和一个具体创建者，使得类的个数成倍增加，导致系统类数目过多，复杂性增加</li><li>对简单工厂，增加功能修改的是工厂类；对工厂方法，增加功能修改的是产品类。</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;golang设计模式之工厂方法模式&quot;&gt;&lt;a href=&quot;#golang设计模式之工厂方法模式&quot; class=&quot;headerlink&quot; title=&quot;golang设计模式之工厂方法模式&quot;&gt;&lt;/a&gt;golang设计模式之工厂方法模式&lt;/h1&gt;&lt;h1 id=&quot;工厂方法模
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
