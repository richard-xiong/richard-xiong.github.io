<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"richard-xiong.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="XingServer">
<meta property="og:url" content="https://richard-xiong.github.io/page/3/index.html">
<meta property="og:site_name" content="XingServer">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Richard">
<meta property="article:tag" content="golang java elasticsearch">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://richard-xiong.github.io/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>XingServer</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="XingServer" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">XingServer</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">33</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">25</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">110</span></a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://richard-xiong.github.io/2020/10/30/interview-tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E3%80%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Richard">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XingServer">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/30/interview-tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E3%80%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/" class="post-title-link" itemprop="url">interview-tcp 三次握手、四次挥手</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-10-29 21:52:53 / 修改时间：13:54:46" itemprop="dateCreated datePublished" datetime="2020-10-29T21:52:53Z">2020-10-29</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li>请画出三次握手和四次挥手的示意图</li>
<li>为什么连接的时候是三次握手？</li>
<li>什么是半连接队列？</li>
<li>ISN(Initial Sequence Number)是固定的吗？</li>
<li>三次握手过程中可以携带数据吗？</li>
<li>如果第三次握手丢失了，客户端服务端会如何处理？</li>
<li>SYN攻击是什么？</li>
<li>挥手为什么需要四次？</li>
<li>四次挥手释放连接时，等待2MSL的意义?</li>
</ol>
<p><img src="/images/interview-tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E3%80%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/v2-67515121626493be9b645be76534007f_r.jpg" alt="preview"></p>
<h2 id="1-三次握手"><a href="#1-三次握手" class="headerlink" title="1. 三次握手"></a>1. 三次握手</h2><p>三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。</p>
<p>刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。</p>
<p>进行三次握手：</p>
<p>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN©。此时客户端处于 SYN_SEND 状态。</p>
<p>首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。</p>
<p>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。</p>
<p>在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y。</p>
<p>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。</p>
<p>确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。</p>
<p>发送第一个SYN的一端将执行主动打开（active open），接收这个SYN并发回下一个SYN的另一端执行被动打开（passive open）。</p>
<p>在socket编程中，客户端执行connect()时，将触发三次握手。</p>
<p><img src="/images/interview-tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E3%80%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/v2-2a54823bd63e16674874aa46a67c6c72_720w.jpg" alt="img"></p>
<p><strong>1.1 为什么需要三次握手，两次不行吗？</strong></p>
<p>弄清这个问题，我们需要先弄明白三次握手的目的是什么，能不能只用两次握手来达到同样的目的。</p>
<p>第一次握手：客户端发送网络包，服务端收到了。</p>
<p>这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p>
<p>第二次握手：服务端发包，客户端收到了。</p>
<p>这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。</p>
<p>第三次握手：客户端发包，服务端收到了。</p>
<p>这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</p>
<p>因此，需要三次握手才能确认双方的接收与发送能力是否正常。</p>
<p>试想如果是用两次握手，则会出现下面这种情况：</p>
<blockquote>
<p>如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。</p>
</blockquote>
<p><strong>1.2 什么是半连接队列？</strong></p>
<p>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。</p>
<p>当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。</p>
<p>这里在补充一点关于SYN-ACK 重传次数的问题：</p>
<p>服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。</p>
<p>注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s…</p>
<p><strong>1.3 ISN(Initial Sequence Number)是固定的吗？</strong></p>
<p>当一端为建立连接而发送它的SYN时，它为连接选择一个初始序号。ISN随时间而变化，因此每个连接都将具有不同的ISN。ISN可以看作是一个32比特的计数器，每4ms加1 。这样选择序号的目的在于防止在网络中被延迟的分组在以后又被传送，而导致某个连接的一方对它做错误的解释。</p>
<p>三次握手的其中一个重要功能是客户端和服务端交换 ISN(Initial Sequence Number)，以便让对方知道接下来接收数据的时候如何按序列号组装数据。如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。</p>
<p><strong>1.4 三次握手过程中可以携带数据吗？</strong></p>
<p>其实第三次握手的时候，是可以携带数据的。但是，第一次、第二次握手不可以携带数据</p>
<p>为什么这样呢?大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。</p>
<p>也就是说，第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。</p>
<p><strong>1.5 SYN攻击是什么？</strong></p>
<p>服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到SYN洪泛攻击。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS/DDoS 攻击。</p>
<p>检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -n -p TCP | grep SYN_RECV</span><br></pre></td></tr></table></figure>

<p>常见的防御 SYN 攻击的方法有如下几种：</p>
<ul>
<li>缩短超时（SYN Timeout）时间</li>
<li>增加最大半连接数</li>
<li>过滤网关防护</li>
<li>SYN cookies技术</li>
</ul>
<h2 id="2-四次挥手"><a href="#2-四次挥手" class="headerlink" title="2. 四次挥手"></a>2. 四次挥手</h2><p>建立一个连接需要三次握手，而终止一个连接要经过四次挥手（也有将四次挥手叫做四次握手的）。这由TCP的半关闭（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。</p>
<p>TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，客户端或服务器均可主动发起挥手动作。</p>
<p>刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：</p>
<p>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。</p>
<p>即发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。</p>
<p>第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。</p>
<p>即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。</p>
<p>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。</p>
<p>即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。</p>
<p>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</p>
<p>即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。</p>
<p>收到一个FIN只意味着在这一方向上没有数据流动。客户端执行主动关闭并进入TIME_WAIT是正常的，服务端通常执行被动关闭，不会进入TIME_WAIT状态。</p>
<p>在socket编程中，任何一方执行close()操作即可产生挥手操作。</p>
<p><img src="/images/interview-tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E3%80%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/v2-c7d4b5aca66560365593f57385ce9fa9_720w.jpg" alt="img"></p>
<p><strong>2.1 挥手为什么需要四次？</strong></p>
<p>因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。</p>
<p><strong>2.2 2MSL等待状态</strong></p>
<p>TIME_WAIT状态也成为2MSL等待状态。每个具体TCP实现必须选择一个报文段最大生存时间MSL（Maximum Segment Lifetime），它是任何报文段被丢弃前在网络内的最长时间。这个时间是有限的，因为TCP报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的TTL字段。</p>
<p>对一个具体实现所给定的MSL值，处理的原则是：当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在TIME_WAIT状态停留的时间为2倍的MSL。这样可让TCP再次发送最后的ACK以防这个ACK丢失（另一端超时并重发最后的FIN）。</p>
<p>这种2MSL等待的另一个结果是这个TCP连接在2MSL等待期间，定义这个连接的插口（客户的IP地址和端口号，服务器的IP地址和端口号）不能再被使用。这个连接只能在2MSL结束后才能再被使用。</p>
<p><strong>2.3 四次挥手释放连接时，等待2MSL的意义?</strong></p>
<p>MSL是Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p>
<p>为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。</p>
<p>两个理由：</p>
<ul>
<li>保证客户端发送的最后一个ACK报文段能够到达服务端。</li>
</ul>
<p>这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，服务端超时重传FIN+ACK报文段，而客户端能在2MSL时间内收到这个重传的FIN+ACK报文段，接着客户端重传一次确认，重新启动2MSL计时器，最后客户端和服务端都进入到CLOSED状态，若客户端在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到服务端重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则服务端无法正常进入到CLOSED状态。</p>
<ul>
<li>防止“已失效的连接请求报文段”出现在本连接中。</li>
</ul>
<p>客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。</p>
<p><strong>2.4 为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？</strong></p>
<p>理论上，四个报文都发送完毕，就可以直接进入CLOSE状态了，但是可能网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>《TCP/IP详解 卷1:协议》有一张TCP状态变迁图，很具有代表性，有助于大家理解三次握手和四次挥手的状态变化。如下图所示，粗的实线箭头表示正常的客户端状态变迁，粗的虚线箭头表示正常的服务器状态变迁。</p>
<p><img src="/images/interview-tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E3%80%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/v2-7c402fde8210519feb8f65d41410c205_720w.jpg" alt="img"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://richard-xiong.github.io/2020/10/30/interview-%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Richard">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XingServer">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/30/interview-%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">interview-进程、线程、协程的区别</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-29 18:03:18" itemprop="dateCreated datePublished" datetime="2020-10-29T18:03:18Z">2020-10-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-08 02:56:19" itemprop="dateModified" datetime="2020-11-08T02:56:19Z">2020-11-08</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>什么是进程和线程</strong></p>
<p>进程是什么呢？</p>
<p>直白地讲，进程就是应用程序的启动实例。比如我们运行一个游戏，打开一个软件，就是开启了一个进程。</p>
<p>进程拥有代码和打开的文件资源、数据资源、独立的内存空间。</p>
<p>线程又是什么呢？</p>
<p>线程从属于进程，是程序的实际执行者。一个进程至少包含一个主线程，也可以有更多的子线程。</p>
<p>线程拥有自己的栈空间。</p>
<img src="/images/interview-%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/image-20201029180523682.png" alt="image-20201029180523682" style="zoom:50%;" />

<p>有人给出了很好的归纳：</p>
<p><strong>对操作系统来说，线程是最小的执行单元，进程是最小的资源管理单元。</strong></p>
<p>无论进程还是线程，都是由操作系统所管理的。</p>
<p>Java中线程具有五种状态：</p>
<p><strong>初始化 可运行 运行中 阻塞 销毁</strong></p>
<p>这五种状态的转化关系如下：</p>
<img src="/images/interview-%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/image-20201029180545720.png" alt="image-20201029180545720" style="zoom:50%;" />

<p>但是，线程不同状态之间的转化是谁来实现的呢？是JVM吗？</p>
<p>并不是。JVM需要通过操作系统内核中的TCB（Thread Control Block）模块来改变线程的状态，这一过程需要耗费一定的CPU资源。</p>
<p><strong>进程和线程的痛点</strong></p>
<p>线程之间是如何进行协作的呢？</p>
<p>最经典的例子就是<strong>生产者/消费者模式</strong>：</p>
<p>若干个生产者线程向队列中写入数据，若干个消费者线程从队列中消费数据。</p>
<img src="/images/interview-%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/image-20201029180606391.png" alt="image-20201029180606391" style="zoom:50%;" />

<p>如何用java语言实现生产者/消费者模式呢？</p>
<p>让我们来看一看代码：</p>
<p>public class ProducerConsumerTest {</p>
<p>}</p>
<p>class Producer extends Thread {</p>
<p>}</p>
<p>class Consumer extends Thread {private final Queue sharedQueue;</p>
<p>}</p>
<p>这段代码做了下面几件事：</p>
<p>1.定义了一个生产者类，一个消费者类。</p>
<p>2.生产者类循环100次，向同步队列当中插入数据。</p>
<p>3.消费者循环监听同步队列，当队列有数据时拉取数据。</p>
<p>4.如果队列满了（达到5个元素），生产者阻塞。</p>
<p>5.如果队列空了，消费者阻塞。</p>
<p>上面的代码正确地实现了生产者/消费者模式，但是却并不是一个高性能的实现。为什么性能不高呢？原因如下：</p>
<p>1.涉及到同步锁。</p>
<p>2.涉及到线程阻塞状态和可运行状态之间的切换。</p>
<p>3.涉及到线程上下文的切换。</p>
<p>以上涉及到的任何一点，都是非常耗费性能的操作。</p>
<p><strong>什么是协程</strong></p>
<p><strong>协程，英文Coroutines，是一种比线程更加轻量级的存在。</strong>正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。</p>
<img src="/images/interview-%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/image-20201029180628288.png" alt="image-20201029180628288" style="zoom:50%;" />

<p>最重要的是，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。</p>
<p>这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。</p>
<p>既然协程这么好，它到底是怎么来使用的呢？</p>
<p>由于Java的原生语法中并没有实现协程（某些开源框架实现了协程，但是很少被使用），所以我们来看一看python当中对协程的实现案例，同样以生产者消费者模式为例：</p>
<p><img src="/images/interview-%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/image-20201029180645894.png" alt="image-20201029180645894"></p>
<p>这段代码十分简单，即使没用过python的小伙伴应该也能基本看懂。</p>
<p>代码中创建了一个叫做consumer的协程，并且在主线程中生产数据，协程中消费数据。</p>
<p>其中 <strong>yield</strong> 是python当中的语法。当协程执行到yield关键字时，会暂停在那一行，等到主线程调用send方法发送了数据，协程才会接到数据继续执行。</p>
<p>但是，yield让协程暂停，和线程的阻塞是有本质区别的。协程的暂停完全由程序控制，线程的阻塞状态是由操作系统内核来进行切换。</p>
<p>因此，<strong>协程的开销远远小于线程的开销。</strong></p>
<p><strong>协程的应用</strong></p>
<p>有哪些编程语言应用到了协程呢？我们举几个栗子：</p>
<p><strong>Lua语言</strong></p>
<p>Lua从5.0版本开始使用协程，通过扩展库coroutine来实现。</p>
<p><strong>Python语言</strong></p>
<p>正如刚才所写的代码示例，python可以通过 yield/send 的方式实现协程。在python 3.5以后，async/await 成为了更好的替代方案。</p>
<p><strong>Go语言</strong></p>
<p>Go语言对协程的实现非常强大而简洁，可以轻松创建成百上千个协程并发执行。</p>
<p><strong>Java语言</strong></p>
<p>如上文所说，Java语言并没有对协程的原生支持，但是某些开源框架模拟出了协程的功能，有兴趣的小伙伴可以看一看<strong>Kilim框架</strong>的源码：</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://richard-xiong.github.io/2020/10/29/%E6%89%93%E5%8C%85go-web%E9%95%9C%E5%83%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Richard">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XingServer">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/29/%E6%89%93%E5%8C%85go-web%E9%95%9C%E5%83%8F/" class="post-title-link" itemprop="url">打包go-web镜像</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-10-29 11:09:06 / 修改时间：03:09:18" itemprop="dateCreated datePublished" datetime="2020-10-29T11:09:06Z">2020-10-29</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://richard-xiong.github.io/2020/10/20/grep-%E5%8E%BB%E6%B3%A8%E9%87%8A%E5%92%8C%E7%A9%BA%E8%A1%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Richard">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XingServer">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/20/grep-%E5%8E%BB%E6%B3%A8%E9%87%8A%E5%92%8C%E7%A9%BA%E8%A1%8C/" class="post-title-link" itemprop="url">grep 去注释和空行</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-10-20 15:36:50 / 修改时间：07:37:26" itemprop="dateCreated datePublished" datetime="2020-10-20T15:36:50Z">2020-10-20</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>41</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="literal">-v</span> ^<span class="comment"># /etc/vsftpd/vsftpd.conf |grep -v ^$</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://richard-xiong.github.io/2020/10/15/redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Richard">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XingServer">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/15/redis/" class="post-title-link" itemprop="url">redis</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-15 10:39:44" itemprop="dateCreated datePublished" datetime="2020-10-15T10:39:44Z">2020-10-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-04 12:53:55" itemprop="dateModified" datetime="2020-11-04T12:53:55Z">2020-11-04</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="redis的数据结构和编码"><a href="#redis的数据结构和编码" class="headerlink" title="redis的数据结构和编码"></a>redis的数据结构和编码</h3><img src="/images/redis/image-20201015114538604.png" alt="image-20201015114538604" style="zoom:50%;" />

<p>可以使用OBJECT ENCODING</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SET msg <span class="string">&quot;hello wrold&quot;</span></span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING msg</span></span><br><span class="line">&quot;embstr&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SET story <span class="string">&quot;long long long long long long ago ...&quot;</span></span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING story</span></span><br><span class="line">&quot;raw&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SADD numbers 1 3 5</span></span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING numbers</span></span><br><span class="line">&quot;intset&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SADD numbers <span class="string">&quot;seven&quot;</span></span></span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING numbers</span></span><br><span class="line">&quot;hashtable&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>字符串类型的内部编码有3种：</p>
<ul>
<li>int：8个字节的长整型。</li>
<li>embstr：小于等于39个字节的字符串。</li>
<li>raw：大于39个字节的字符串。</li>
</ul>
<p>Redis会根据当前值的类型和长度决定使用哪种内部编码实现。</p>
<h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><p>哈希类型的内部编码有两种：</p>
<ul>
<li><p>ziplist（压缩列表）：</p>
<p>条件：</p>
<ol>
<li>当哈希类型元素个数小于hash-max-ziplist-entries配置（默认512个）</li>
<li>所有值都小于hash-max-ziplist-value配置（默认64字节）</li>
</ol>
</li>
<li><p>hashtable（哈希表）：当哈希类型无法满足ziplist的条件时使用hashtable</p>
</li>
</ul>
<p>Redis使用ziplist作为哈希的内部实现，ziplist使用更加紧凑的结构实现多个元素的连续存储，所以在节省内存方面比hashtable更加优秀。</p>
<p>使用hashtable作为哈希的内部实现，ziplist的读写效率会下降，而hashtable的读写时间复杂度为O（1）。</p>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p>列表类型的内部编码有两种。</p>
<ul>
<li>ziplist（压缩列表）：当列表的元素个数小于list-max-ziplist-entries配置（默认512个），同时列表中每个元素的值都小于list-max-ziplist-value配置时（默认64字节），Redis会选用ziplist来作为列表的内部实现来减少内存的使用。</li>
<li>linkedlist（链表）：当列表类型无法满足ziplist的条件时，Redis会使用linkedlist作为列表的内部实现。</li>
</ul>
<p>提示：</p>
<p>Redis3.2版本提供了quicklist内部编码，简单地说它是以一个ziplist为节点的linkedlist，它结合了ziplist和linkedlist两者的优势，为列表类型提供了一种更为优秀的内部编码实现，它的设计原理可以参考Redis的另一个作者Matt Stancliff的博客：<a target="_blank" rel="noopener" href="https://matt.sh/redis-quicklist">https://matt.sh/redis-quicklist</a> 。</p>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>集合类型的内部编码有两种：</p>
<ul>
<li>intset（整数集合）：当集合中的元素都是整数且元素个数小于set-max-intset-entries配置（默认512个）时，Redis会选用intset来作为集合的内部实现，从而减少内存的使用。</li>
<li>hashtable（哈希表）：当集合类型无法满足intset的条件时，Redis会使用hashtable作为集合的内部实现。</li>
</ul>
<h2 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h2><p>有序集合类型的内部编码有两种：</p>
<ul>
<li>ziplist（压缩列表）：当有序集合的元素个数小于zset-max-ziplist-entries配置（默认128个），同时每个元素的值都小于zset-max-ziplist-value配置（默认64字节）时，Redis会用ziplist来作为有序集合的内部实现，ziplist可以有效减少内存的使用。</li>
<li>skiplist（跳跃表）：当ziplist条件不满足时，有序集合会使用skiplist作为内部实现，因为此时ziplist的读写效率会下降。</li>
</ul>
</li>
</ul>
<h4 id="单线程为什么这么快？"><a href="#单线程为什么这么快？" class="headerlink" title="单线程为什么这么快？"></a>单线程为什么这么快？</h4><ol>
<li>纯内存 大概是100纳秒 （主要原因）</li>
<li>非阻塞io （select/poll/epoll）</li>
<li>减少了多线程的切换和竟态消耗 ，多线程如果没有合理使用会比单线程还慢</li>
</ol>
<h4 id="需要注意哪些："><a href="#需要注意哪些：" class="headerlink" title="需要注意哪些："></a>需要注意哪些：</h4><ol>
<li><p>一次只运行一次命令</p>
</li>
<li><p>拒绝慢命令 keys flush flushdb，slow lua script 。mutil/exec operate big value（Collection）</p>
</li>
<li><p>redis 其实不是单线程，再执行下面操作的时候都是有单独线程去执行的</p>
<p>​    fysnc file descriptor</p>
<p>​    close file descriptor</p>
</li>
<li><p>redis的key和string类型的value都限制为512MB</p>
</li>
</ol>
<h2 id="Redis-Api的使用和理解"><a href="#Redis-Api的使用和理解" class="headerlink" title="Redis Api的使用和理解"></a>Redis Api的使用和理解</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ol>
<li><h5 id="结构和命令"><a href="#结构和命令" class="headerlink" title="结构和命令"></a>结构和命令</h5><p>​    key value 结构</p>
<p>​    value的值 可以是字符串 数值 也可以是位图   最大的值有限制是512MB</p>
<ol>
<li><p>场景：</p>
<ol>
<li>缓存</li>
<li>计数器</li>
<li>分布式锁</li>
<li>。。。</li>
</ol>
</li>
<li><p>命令</p>
<p>get key O(1)</p>
<p>set key value O(1)</p>
<p>delete key O(1)</p>
<p>incry key  # key自增1 如果不存在，以0为起点 O(1)</p>
<p>decr key  #key 自减  O(1)</p>
<p>incrby  key k # key 自增k，如果不存在 ,自增后get(key)=k  O(1)</p>
<p>decrby key k  #   key 自减k，如果不存在 ,自增后get(key)=-k  O(1)</p>
</li>
<li><p>快速实战</p>
<ol>
<li><p>实现如下功能：</p>
<p>​    记录网站每个用户个人主页的访问量？</p>
<p> incr userid:pageview (单线程：无竞争) </p>
</li>
<li><p>缓存视频的基本信息（数据源再mysql中）伪代码</p>
<img src="/images/redis/image-20201015142830668.png" alt="image-20201015142830668" style="zoom: 33%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> VideoInfo <span class="title">get</span><span class="params">(<span class="keyword">long</span> id)</span></span>&#123;</span><br><span class="line">    String redisKey = redisPrefix+id</span><br><span class="line">  VideoInfo videoInfo = redis.get(redisKey);</span><br><span class="line">  <span class="keyword">if</span> (videoInfo==<span class="keyword">null</span>)&#123;</span><br><span class="line">    videoInfo=mysql.get(id)&#123;</span><br><span class="line">      <span class="keyword">if</span> (videoInfo!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">// 序列化</span></span><br><span class="line">            redis.set(redisKey,searialize(videoInfo))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> videoInfo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ol>
</li>
</ol>
<pre><code>  3. 分布式的id生成器

     &lt;img src=&quot;/images/redis/image-20201015144059614.png&quot; alt=&quot;image-20201015144059614&quot; style=&quot;zoom:33%;&quot; /&gt;

     incr key  

  4.  set  setnx  setxx

     ​    set key value # 不管key是否存在都设置 O(1)

     ​    setnx key value # key 不存在才设置 O(1)

     ​    set key value xx #  key 存在才设置 O(1)

  5. mget  mset

     ​    mget key1 key2 key3 #批量获取key 原子操作 O(n)

     ​    mset key1 value1 key2 value2 key3 value3 # 批量设置key value O(n)

     &lt;img src=&quot;/images/redis/image-20201015145748466.png&quot; alt=&quot;image-20201015145748466&quot; style=&quot;zoom:25%;&quot; /&gt;  &lt;img src=&quot;/images/redis/image-20201015145832158.png&quot; alt=&quot;image-20201015145832158&quot; style=&quot;zoom:25%;&quot; /&gt;#### 内部编码

  4. #### 查缺补漏

     1. getset 、append 、strlen

        getset key newvalue # set key newvalue 并返回久的value   O(1)

        append key value # 将value追加到旧的value O(1)

        strlen key # 返回字符串的长度（注意中文） O(1)  utf8 中文占用两个字节

     2.  incrbyfloat getrange setrange

        incrbyfloat key 3.5 #增加kkey对应的值是3.5 O(1)

        getrange key start end # 获取字符串指定下标的所有的值  O(n)

        setrange key index value # 设置指定下标所有对应的值  O(n)</code></pre>
<ol start="2">
<li><h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><h4 id="1、hash键值的结构"><a href="#1、hash键值的结构" class="headerlink" title="1、hash键值的结构"></a>1、hash键值的结构</h4><p>​        key   filed value    filed 可以理解为属性  value 是属性值    </p>
<img src="/images/redis/image-20201015152852586.png" alt="image-20201015152852586" style="zoom:25%;" />

<h4 id="2、-特点"><a href="#2、-特点" class="headerlink" title="2、 特点"></a>2、 特点</h4><p>​    Mapmap？map的map   key对应的是一个map  filed和value也像是一个map   </p>
<p>​    SmallRedis  引号的 可以理解为上面</p>
<p>​    filed 不能相同 value 可以相同</p>
<h4 id="3-、重要的api"><a href="#3-、重要的api" class="headerlink" title="3 、重要的api"></a>3 、重要的api</h4><ol>
<li><p>​    hget hset hdel</p>
<p>​    hget key filed # 获取hash key对应filed的value O(1) </p>
<p>​    hset key filed value # 设置hash key 对应field 的value  O(1)</p>
<p>​    hdel key field # 删除hash key 对应filed的value  O(1)</p>
</li>
<li><p>hexists hlen </p>
<p>​    hexists  key filed # 判断hash key 是否有field O(1) </p>
<p>hlen key # 获取hash key field的数量 O(1) </p>
</li>
<li><p>hmegt  hmset</p>
<p>​    hmget key filed1 field2 … filedN # 批量获取hash key的一批field的值  O(n)</p>
<p>​    hmset key filed1 value1 field2 value2 …filedN valueN # 批量设置hash key的一批field value O(n) </p>
</li>
</ol>
<h4 id="4、-实战"><a href="#4、-实战" class="headerlink" title="4、 实战"></a>4、 实战</h4><ol>
<li><p>​    记录网站每个用户个人主页的访问量</p>
<p>​    hincrby user:1:info pageview count</p>
</li>
<li><p>缓存视频的基本信息 伪代码    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> VedioInfo <span class="title">get</span><span class="params">(<span class="keyword">long</span> id)</span></span>&#123;</span><br><span class="line">  String redisKey = redisPrefix + id</span><br><span class="line">  Map&lt;String,String&gt; hashMap = redis.getAll(redisKey)</span><br><span class="line">  VideoInfo videoInfo = transferMapToVideo(hashMap)</span><br><span class="line">  <span class="keyword">if</span> videoInfo == <span class="keyword">null</span> &#123;</span><br><span class="line">        videoInfo = mysql.get(id)</span><br><span class="line">      <span class="keyword">if</span> videoInfo != <span class="keyword">null</span> &#123;</span><br><span class="line">        redis.hmset(redisKey,transVideoToMap(videoInfo))</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> videoInfo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>hgetall hvals  hkeys</p>
<p>hgetall key # 返回对应key的所有field和value O(n) </p>
<p>hvals key # 返回对应key的所有field的values O(n) </p>
<p>hkeys key # 返回对应key的所有field  O(n) </p>
<p>小心使用hgetall 因为redis是单线程  否则会阻塞操作</p>
</li>
<li><p>更新用户信息</p>
<ol>
<li>string key  user存储    key value是整个用户信息</li>
<li>string  key:用户属性  value:属性值</li>
<li>hash  key field 是用户属性 value  属性值</li>
</ol>
<img src="/images/redis/image-20201015174305567.png" alt="image-20201015174305567" style="zoom:25%;" />



</li>
</ol>
</li>
</ol>
<h4 id="5、查缺补漏"><a href="#5、查缺补漏" class="headerlink" title="5、查缺补漏"></a>5、查缺补漏</h4><ol>
<li><p>hsetnx hincrby hincrbyfloat</p>
<p>​    hsetnx key field value # 设置hash key对应field的value 如果field已经存在则失败 O(1)</p>
<p>​    hincrby key field intCounter # hash key对应的field的value自增intCounter  O(1) </p>
<p>​    hincrbyfloat key field floatCounter  # hash key对应的field的value自增loatCounter  O(1)</p>
</li>
</ol>
<ol start="3">
<li><h2 id="list-1"><a href="#list-1" class="headerlink" title="list"></a>list</h2><ol>
<li><h4 id="列表结构"><a href="#列表结构" class="headerlink" title="列表结构"></a>列表结构</h4><p>​    key  elements</p>
</li>
<li><h4 id="重要api"><a href="#重要api" class="headerlink" title="重要api"></a>重要api</h4><p>​    rpush key value1 value2 … valueN #从列表右端插入值(1-n个) O(n)</p>
<p>​    lpush key value1 value2 … valueN # 从列表左端插入值(1-n个) O(n)</p>
<p>​    linsert key before|after value newValue #在list指定的值 前|后插入newValue O(n)</p>
<p>​    lpop key # 从list左边弹出一个item</p>
<p>​    rpop key # 从list右边弹出一个item</p>
<p>​    lrem key count value # 根据count的值，从列表中删除所有与value相等的项 O(n)</p>
<ol>
<li>count&gt;0 从左到右，删除最大count个与value相等的项</li>
<li>count&lt;0 从右到左，删除最大count个与value相等的项</li>
<li>count=0 删除所有与value相等的项</li>
</ol>
<p>​    ltrim key start end # 按照索引范围修剪列表 O(n)</p>
<p>​    lrange key start end（包含end）# 获取列表指定范围的所有item O(n)</p>
<p>​    lindex key index # 获取列表指定索引的值 O(n)</p>
<p>​    llen key # 获取列表的长度 O(1)</p>
<p>​    lset key index newValue # 设置列表指定索引的值为newValueO(n)</p>
<h4 id="3-实战场景"><a href="#3-实战场景" class="headerlink" title="3.实战场景"></a>3.实战场景</h4><p>​    时间轴 timeline</p>
<h4 id="4-查缺补漏"><a href="#4-查缺补漏" class="headerlink" title="4.查缺补漏"></a>4.查缺补漏</h4><p>​    blpop brpop</p>
<ol>
<li>​    blpop key timeout # lpop阻塞版本，timeout是阻塞超时时间，timeout=0 为永远不阻塞</li>
<li>brpop key timeout # rpop阻塞版本，timeout是阻塞超时时间，timeout=0 为永远不阻塞</li>
</ol>
<h5 id="5-tips"><a href="#5-tips" class="headerlink" title="5. tips"></a>5. tips</h5><ol>
<li>​    LPUSH + LPOP = Stack</li>
<li>​    LPUSH + RPOP = Quene</li>
<li>LPUSH + LTRIM = Cappend Collection 固定大小的集合</li>
<li>LPSUH + BRPOP = Message Quene </li>
</ol>
</li>
</ol>
</li>
<li><p>set</p>
<ol>
<li><p>集合结构</p>
<p>​    key  values</p>
</li>
<li><p>特点</p>
<ol>
<li>无序</li>
<li>无重复</li>
<li>集合间的操作</li>
</ol>
</li>
<li><p>api</p>
<ol>
<li><p>sadd  srem</p>
<p>sadd key element  #向集合key添加element（如果element已经存在 添加失败） O(1)</p>
<p>srem key element  # 将集合key中element移出掉  O(1)</p>
</li>
<li><p>scard、sismember 、srandmember、 smembers</p>
<p>scard key # 计算 集合的大小</p>
<p>sismember key element # 判断element是否在集合key中存在</p>
<p>srandmember key count # 从集合中随机挑选count个元素  </p>
<p>spop key # 从集合中随机弹出一个元素 （弹出之后 集合中不存在这个元素了）</p>
<p>smembers key # 返回集合中所有元素 </p>
<ol>
<li>无序</li>
<li>小心使用 集合多会阻塞队列</li>
</ol>
</li>
<li><p>集合内实战</p>
<ol>
<li><p>抽奖系统</p>
<p>​    可以借助srandmember 或者spop来实现</p>
</li>
<li><p>like 赞 踩</p>
</li>
<li><p>添加标签 </p>
</li>
</ol>
</li>
<li><p>集合间的使用</p>
<ol>
<li>sdiff sinter sunion</li>
</ol>
<p>​    sdiff key1 key2 # 算出两个集合的差集</p>
<p>​    sinter key1 key2 # 算出两个集合的交集</p>
<p>​    sunion key1 key2 # 算法两个集合的并集</p>
</li>
<li><p>tips</p>
<p>sadd = 添加标签</p>
<p>spop /srandMember = 获取随机数</p>
<p>sadd + sinter = 做一些社交相关的业务</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>list 有序集合</p>
<ol>
<li><p>结构</p>
<p>​    key score value</p>
</li>
<li><p>特点</p>
<ol>
<li>无重复元素</li>
<li>有序</li>
<li>element score</li>
</ol>
</li>
<li><p>重要api</p>
<ol>
<li>zadd key score element # 添加元素（可以是多对 score 可以重复 element不能重复）O(logN)</li>
<li>zrem key element # 删除元素 可以多个 O(1)</li>
<li>zscore key element # 返回元素的分数 O(1) </li>
<li>zincrby key increSocre element  # 增加或减少element的分数 O(1)</li>
<li>zcard key # 返回元素的总个数   O(1)</li>
<li>zrank key element # 获取element在集合中的排名  ，从小到大 起点是0  O(1)  </li>
<li>zrange key start end 【withscores】 # 返回指定索引范围内的升序元素， 按照排名进行排序 O(logN + m)  </li>
<li>zrangebyscore key minScore maxScore withscores】  # 返回指定分数范围内的升序元素【分值】，按照分值进行排序   O(logN + m)  </li>
<li>zcount key minScores maxScore # 返回有序集合内在指定分数范围的个数 O(logN + m)  </li>
<li>zremrangebyrank key start end # 删除指定排名内的升序元素 O(logN + m)  </li>
<li>zremrangebyscore by minScore maxScore # 删除指定分值内的升序元素 O(logN + m)  </li>
</ol>
</li>
<li><p>实战</p>
<ol>
<li>排行榜 </li>
</ol>
</li>
<li><p>查缺补漏</p>
<ol>
<li>zrevrank  </li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="瑞士军刀-redis"><a href="#瑞士军刀-redis" class="headerlink" title="瑞士军刀 redis"></a>瑞士军刀 redis</h2><h3 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h3><ol>
<li><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><ol>
<li>过程  发送 排队 执行 返回结果</li>
<li>慢查询是发生在第三阶段 </li>
<li>客户端超时不一定慢，但慢查询是客户端超时的一个可能因素</li>
</ol>
</li>
<li><h4 id="两个配置"><a href="#两个配置" class="headerlink" title="两个配置"></a>两个配置</h4><ol>
<li><p>slowlog-max-len</p>
<ol>
<li><p>先进先出的队列</p>
</li>
<li><p>固定长度</p>
</li>
<li><p>保存在内存内  </p>
<img src="/images/redis/image-20201016175532537.png" alt="image-20201016175532537" style="zoom: 50%;" />
</li>
</ol>
</li>
<li><p>slowlog-log-slower-than</p>
<ol>
<li>慢查询的阈值（单位：微秒）</li>
<li>slowlog-log-slower-than=0 记录所有的命令 ps（因为客户端不会显示执行的时间，这时候可以将改配置记录为0 ，然后看一下慢查询中执行的时间）</li>
<li>slowlog-log-slower-than&lt;0 不记录任何命令</li>
</ol>
</li>
<li><p>配置方法</p>
<ol>
<li><p>默认值</p>
<ol>
<li>config get slowlog-max-len= 128 默认值 </li>
<li>config get slowlog-log-slower-than=10000 10ms</li>
</ol>
</li>
<li><p>修改配置文件重启（不推荐）</p>
</li>
<li><p>动态配置</p>
<ol>
<li>config set slowlog-max-len 1000</li>
<li>config set slowlog-log-slower-than=1000</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<ol start="3">
<li><h4 id="三个命令"><a href="#三个命令" class="headerlink" title="三个命令"></a>三个命令</h4><ol>
<li>slowlog get [n] : 获取慢查询队列</li>
<li>showlog len ： 获取慢查询队列的长度</li>
<li>showlog reset ： 清空慢查询队列</li>
</ol>
</li>
<li><h4 id="运维经验"><a href="#运维经验" class="headerlink" title="运维经验"></a>运维经验</h4><ol>
<li>slowlog-max-len 不要设置的过大，slowlog-log-slower-than默认是10ms，通常设置为1ms</li>
<li>slowlog-log-slower-than 不要设置的过小，通常设置在1000左右</li>
<li>理解命令的生命周期</li>
<li>定期持久化慢查询（因为慢查询是存在内存当中的，这样我们就能查到历史的慢查询，这些数据是非常重要的，可以使用一些开源的第三方方法来实现这个功能）</li>
</ol>
<h3 id="pipeline"><a href="#pipeline" class="headerlink" title="pipeline"></a>pipeline</h3></li>
<li><p>什么是流水线</p>
<ol>
<li><p>正常redis执行一条命令的时间= 客户端发送请求和获取请求算一次网络时间，+ 一次命令在客户端执行的时间</p>
<p>如果多次执行redis 命令就会浪费很多网络时间，所以我们将多次命令可以打包成pipeline，然后在服务端计算n次</p>
<p>将结果顺序返回，这样</p>
<p>1次pipeline(n条命令)=1次网络时间+ n次命令执行时间</p>
<p>注意：</p>
<p>​        redis的命令时间是微秒级别的</p>
<p>​        pipeline每次条数要控制（网络）</p>
</li>
</ol>
</li>
<li><p>客户端实现</p>
</li>
<li><p>与原生操作对比</p>
<ol>
<li>他不是原子操作</li>
<li>客户端将pipeline的命令发送到服务端之后 会将pipeline中的命令进行拆分的</li>
</ol>
</li>
<li><p>使用建议</p>
<ol>
<li>注意每次pipeline携带的数据量</li>
<li>pipeline每次只能作用在一个redis节点上</li>
<li>M操作与pipeline的区别</li>
</ol>
<h3 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h3></li>
<li><p>角色</p>
<ol>
<li>发布者 publisher</li>
<li>订阅者 subscriber</li>
</ol>
<h3 id="bitmap"><a href="#bitmap" class="headerlink" title="bitmap"></a>bitmap</h3><h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><h3 id="Geo"><a href="#Geo" class="headerlink" title="Geo"></a>Geo</h3></li>
</ol>
<h3 id="开发运维常见问题"><a href="#开发运维常见问题" class="headerlink" title="开发运维常见问题"></a>开发运维常见问题</h3><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><ol>
<li><h4 id="命令实现"><a href="#命令实现" class="headerlink" title="命令实现"></a>命令实现</h4><ol>
<li>slaveof  ip port     异步去执行复制 </li>
<li>取消复制<ol>
<li>slaveof no more 不在成为从节点  </li>
</ol>
</li>
</ol>
</li>
<li><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><ol>
<li>slaveif ip port</li>
<li>slave-read-only yes 只做读操作 </li>
</ol>
</li>
<li><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><table>
<thead>
<tr>
<th align="center">方式</th>
<th align="center">命令</th>
<th align="center">配置</th>
</tr>
</thead>
<tbody><tr>
<td align="center">优点</td>
<td align="center">不需要重启</td>
<td align="center">统一配置</td>
</tr>
<tr>
<td align="center">缺点</td>
<td align="center">不便于管理</td>
<td align="center">需要重启</td>
</tr>
</tbody></table>
</li>
<li><h4 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h4><p>redis&gt; info replication 查看分片的状态</p>
<p>主从复制的配置 实际上是从节点先flush本身的数据 然后在通过网络传输将master节点的rdb文件复制过来 然后再加载到内存当中</p>
</li>
<li><h4 id="全量复制和部分复制"><a href="#全量复制和部分复制" class="headerlink" title="全量复制和部分复制"></a>全量复制和部分复制</h4><ol>
<li><p>当不知道master节点的run id是多少 或者master节点重启或其他情况 run id会发生改变 这样都会出发slave节点全量复制</p>
</li>
<li><p>部分复制是要看 info replication</p>
<p>​    </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">10.49.1.43:6379&gt; info replication</span><br><span class="line"><span class="meta">#</span><span class="bash"> Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:1</span><br><span class="line">slave0:ip=192.168.16.74,port=6379,state=online,offset=102936066,lag=1</span><br><span class="line">master_replid:134e809e3fddd112cdb3235e0a0f15a167ea65b5</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:102936066</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:101887491</span><br><span class="line">repl_backlog_histlen:1048576</span><br><span class="line"></span><br><span class="line">10.49.1.121:6379&gt; info replication</span><br><span class="line"><span class="meta">#</span><span class="bash"> Replication</span></span><br><span class="line">role:slave</span><br><span class="line">master_host:192.168.51.59</span><br><span class="line">master_port:6379</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:1</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:421179470</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_replid:5267ce41ab6dcb2bb525b5279df006259e835153</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:421179470</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:420130895</span><br><span class="line">repl_backlog_histlen:1048576</span><br></pre></td></tr></table></figure>

<p>从节点会定时上报自己的状态到主节点 这样master就知道slave 的偏移情况，如果offset是差别比较多的情况下 ，证明你的主从复制是有问题的，有可能是阻塞 网络 或者是缓存区域有没有满的情况 </p>
</li>
<li><p>全量复制 首先slave先将获取到的rdb文件加载到内存中，加载完成后 ，然后通过偏移量的对比 将这个期间写入的值同步给slave节点</p>
<p>​    <img src="/images/redis/image-20201020165104374.png" alt="image-20201020165104374"></p>
</li>
</ol>
</li>
</ol>
<pre><code>     1. 1 redis 2.8之前是sync  2.8之后是psync  ，是完成全量复制和部分复制的一个功能，需要两个参数 一个是run id 一个是偏移量 offset ，完成全量复制之后 在将offset之后的写入数据同步到slave上，如果第一次不知道run id是多少 也不知道偏移量是多少 那么 run id 就传？offset 填 1
     2. master节点会告诉slave节点的run id和偏移量
     3. salve 会保存master的一个基本信息
     4. master 执行 持久化相关的bgsave，生一个快照 rdb文件
     5. 在生成rdb发给slave之后 实际上redis 还有一个复制缓存区
     6. 发送缓存区的数据
     7. flush 老数据
     8. 加载rdb和缓存区的数据

  4. 全量复制的开销

     1. bgsave 的时间
     2. RDB文件的网络传输时间
     3. 从节点清空数据时间
     4. 从节点加载rdb时间
     5. 可能的aof重写时间

     有一个场景就是slave在进行全量复制的过程中 master和slave之间发生了网络抖动，这样在网络抖动期间操作的数据 slave是不知道的，所以2.8之前会再进行一次全量复制 但是全量复制的开销也是比较大的 所以2.8之后 出现了部分复制，将这个损失降到最低

  5. 部分复制

     1. 连接断开
     2. master在写的时候会写一份复制到缓冲区的命令
     3. 网络抖动结束 slave继续连接master
     4. slave会执行一个psync命令 告诉master 自己的offset和run id
     5. offset在master有一个队列的概念 如果offset不在master的队列期间内 证明已经错过了很多数据，会进行全量复制，
     6. 如果再范围内，那么会将offset到队列结尾的数据同步给slave ，这样master和slave就达到了一致，后面的那些

  6. 故障处理

     1. 主从结构故障
        1. slave故障-宕机  改成连接其他的slave节点就可
        2. master故障宕机 找一个slave 选择成master  执行slaveof no one，其他的节点执行slave of new master，如果故障发生了 每一秒都很重要 最好能脚本化
        3. 可以使用redis sentinel来进行故障转移

  7. 主从复制

     1. 优点

        1. 实现高可用，分布式基础
        2. 数据备份
        3. 读写分离

     2. 可能遇到的问题

        1. 读写分离
        2. 主从配置不一致
        3. 规避全量复制
        4. 规避复制风暴

     3. 读写分离

        1. 读流量分摊到从节点

        2. 可能遇到的问题

           1. 复制数据的延迟 
           2. 读到过期的数据
           3. 从节点故障

        3. 配置不一致

           1. 主从节点的maxmemory 不一致，丢失数据， 从节点的内存比主节点小会触发最大内存的淘汰策略，将数据进行淘汰，如果过期的数据比较多，那么会优先剔出出去过期的数据，即使oom也不会报错，但是如果当slave晋升成为主节点的时候 就会因为内存不够从而淘汰一些数据 
           2. 例如数据结构优化参数(例如hash-max-ziplist-entries)： 内存不一致 

        4. 规避全量复制

           1. 产生的条件 

              1. 第一次全量复制  不可避免

                 ​    小主节点 低峰 （maxmemory 设置的小 或者在低峰的时候去复制）

              2. 节点运行的id 不匹配

                 1. 主节点重启（运行id变化）
                 2. 故障转移，例如哨兵或者集群 slave晋升为主节点

              3. 复制积压缓冲区不足  （1MB）判断主从的offset 如果没命中就需要进行全量复制

                 1. 网络中断，部分复制无法满足
                 2. 增大复制缓存去配置rel_backlog_size ，网络增强

        5. 规避复制风暴

           1. 单节点复制风暴

              1. 问题：主节点重启 ，多从节点复制

              2. 解决：更换网络拓扑&lt;img src=&quot;/images/redis/image-20201021214920029.png&quot; alt=&quot;image-20201021214920029&quot; style=&quot;zoom:33%;&quot; /&gt;

                 这样对于master来说会减轻他的压力，如果不考虑读写分离 那么完全可以在master节点挂掉之后 将slave节点晋升 然后在给它加一个slave 节点就可以了

           2. 单机器复制风暴

              1. 机器宕机之后 大量全量复制 ，&lt;img src=&quot;/images/redis/image-20201021215320889.png&quot; alt=&quot;image-20201021215320889&quot; style=&quot;zoom: 33%;&quot; /&gt;

                 ​    masterA 会进行大量的bgsave 然后传输rdb文件，很有可能会造成内存池满和大量的网络开销或者带宽池满的情况 

              2. 解决： 我们将master节点分数到多机器上 </code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://richard-xiong.github.io/2020/10/15/Golang%E5%B0%8F%E6%8A%80%E5%B7%A7-%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%89%E5%85%83%E8%A1%A8%E8%BE%BE%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Richard">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XingServer">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/15/Golang%E5%B0%8F%E6%8A%80%E5%B7%A7-%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%89%E5%85%83%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="post-title-link" itemprop="url">Golang小技巧-自定义三元表达式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-10-15 10:29:33 / 修改时间：02:30:34" itemprop="dateCreated datePublished" datetime="2020-10-15T10:29:33Z">2020-10-15</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>三元表达式的介绍在这里:</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/%3F">http://en.wikipedia.org/wiki/%3F</a>:</li>
<li><a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/IIf">http://en.wikipedia.org/wiki/IIf</a></li>
</ul>
<p>Go语言明确不支持三元表达式，这里是相关的讨论：<br><a target="_blank" rel="noopener" href="https://groups.google.com/d/msg/golang-nuts/dbyqx_LGUxM/tLFFSXSfOdQJ">https://groups.google.com/d/msg/golang-nuts/dbyqx_LGUxM/tLFFSXSfOdQJ</a></p>
<p>官方FAQ的说明在这里：<br><a target="_blank" rel="noopener" href="http://golang.org/doc/faq#Does_Go_have_a_ternary_form">http://golang.org/doc/faq#Does_Go_have_a_ternary_form</a></p>
<p>官方FAQ推荐的做法是用 <code>if</code> 代替：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> expr &#123;</span><br><span class="line">    n = trueVal</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    n = falseVal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过用 <code>if</code> 的问题是变量 <code>n</code> 有作用域问题.<br>我们需要在 <code>if</code> 之前先定义变量 <code>n</code>，这样才可以在 <code>if</code> 语句之后使用变量 <code>n</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n <span class="keyword">int</span></span><br><span class="line"><span class="keyword">if</span> expr &#123;</span><br><span class="line">    n = trueVal</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    n = falseVal</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println</span>(n)</span><br></pre></td></tr></table></figure>

<p>本来一个简单的 <code>n := expr? trueVal: falseVal</code> 就能够表达的问题，变的复杂了很多。<br>这和Go所追求的简单思路是有冲突的。</p>
<p>类似的有 <code>max</code>/<code>min</code> 等函数。因为这类函数使用频度比较高，在很多pkg的内部都定义了私有的实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>熟悉Go语言的用户应该可以发现，这个 <code>max</code> 只支持 <code>int</code> 类型。<br>对于支持泛型的C++语言来说，<code>max</code> 一般被实现为一个模板函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T&gt;</span><br><span class="line"><span class="keyword">const</span> T&amp; max (<span class="keyword">const</span> T&amp; a, <span class="keyword">const</span> T&amp; b) &#123;</span><br><span class="line">    <span class="keyword">return</span> (a&lt;b)?b:a;     <span class="comment">// or: return comp(a,b)?b:a; for version (2)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在C++版本中，不仅用到的泛型<code>T</code>，还依赖 <code>a&lt;b</code> 的运算符重载特性。<br>在C语言中，虽然没有泛型和运算符重载，但是三元表达式也具备全部的特性（因为表达式天生就是支持泛型的）。</p>
<p>而这些都是Go语言中缺少的特性。<br>不过在Go语言中可以模拟一个更普通的函数(<code>If</code> 的首字母大写，是函数名，不是 <code>if</code> 关键字)：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">If</span><span class="params">(condition <span class="keyword">bool</span>, trueVal, falseVal <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    <span class="keyword">if</span> condition &#123;</span><br><span class="line">        <span class="keyword">return</span> trueVal</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> falseVal</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a, b := <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">max := If(a &gt; b, a, b).(<span class="keyword">int</span>)</span><br><span class="line"><span class="built_in">println</span>(max)</span><br></pre></td></tr></table></figure>

<p>有几个关键点：</p>
<ul>
<li>Go不支持运算符重载，因此需要先将 <code>a&lt;b</code> 在函数外转换为 <code>bool</code> 条件</li>
<li>Go不支持泛型，只能用 <code>interface&#123;&#125;</code> 模拟</li>
<li>返回的类型安全需要用户自己保证，<code>.(type)</code> 的类型必须匹配</li>
<li><code>interface&#123;&#125;</code> 是运行时泛型，性能没有编译时泛型高</li>
</ul>
<p>由此可见，<code>?:</code> 不仅仅是一个简单的三元表达式。其实它更像一个内置的泛型版的函数（因为表达式天生就是支持泛型的）。</p>
<p>期望未来的Go版本中，能完善对 <code>?:</code> 三元表达式 和 编译时的泛型 的支持。</p>
<p>补充：<br>星星 同学的提示：可能会导致深入嵌套的滥用： <code>c?d?e?0:1:2:3</code> 。<br>因为三元表达式是一个表达式，必然是允许嵌套的。</p>
<p>不过我觉得嵌套不是问题的本质，函数也能导致嵌套的滥用。<br>但是不能因为滥用的行为来排斥有存在价值的语法（比如三元表达式）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://richard-xiong.github.io/2020/10/15/golang%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Richard">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XingServer">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/15/golang%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">golang设计模式之原型模式.md </a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-10-14 17:53:03 / 修改时间：13:15:20" itemprop="dateCreated datePublished" datetime="2020-10-14T17:53:03Z">2020-10-14</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>wiki:原型模式是创建型模式的一种，其特点在于通过“复制”一个已经存在的实例来返回新的实例,而不是新建实例。被复制的实例就是我们所称的“原型”，这个原型是可定制的。原型模式多用于创建复杂的或者耗时的实例，因为这种情况下，复制一个已经存在的实例使程序运行更高效；或者创建值相等，只是命名不一样的同类数据。</p>
</blockquote>
<p>这是一个十分简单的设计模式,可以看做是其他语言中的克隆方法，例如 <code>JAVA</code>/<code>PHP</code> 中都有相关方法，从一个内存中已经存在的对象中，拷贝出一个一模一样的对象来，针对复杂对象或比较大的对象，要比使用各种设计模式<code>new</code>出来的对象要快的多,</p>
<p>而且原型模式很少单独使用，一般与其他对象结合使用。</p>
<h3 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h3><ol>
<li><p>创建一个结构体</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F; 示例结构体</span><br><span class="line">  type Example struct &#123;</span><br><span class="line">      Content string</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加克隆方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  func (e *Example) Clone() *Example &#123;</span><br><span class="line">      res :&#x3D; *e</span><br><span class="line">      return &amp;res</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>我们仅仅一行代码就完成了值的拷贝，使用 <code>*指针</code>，直接获取了一个拷贝的值，然后将这个拷贝的值得指针返回，原理请阅读下面的扩展阅读。</p>
</li>
<li><p>编写主代码</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   func main() &#123;</span><br><span class="line">       r1 :&#x3D; new(Example)</span><br><span class="line">       r1.Content &#x3D; &quot;this is example 1&quot;</span><br><span class="line">       r2 :&#x3D; r1.Clone()</span><br><span class="line">       r2.Content &#x3D; &quot;this is example 2&quot;</span><br><span class="line">   </span><br><span class="line">       fmt.Println(r1)</span><br><span class="line">       fmt.Println(r2)</span><br><span class="line">   </span><br><span class="line">   &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="扩展阅读-深拷贝与浅拷贝"><a href="#扩展阅读-深拷贝与浅拷贝" class="headerlink" title="扩展阅读: 深拷贝与浅拷贝"></a>扩展阅读: 深拷贝与浅拷贝</h3><p><code>go</code> 语言中的传递都是值传递，传递一个对象，就会把对象拷贝一份传入函数中，传递一个指针，就会把指针拷贝一份传入进去。</p>
<p>赋值的时候也是这样，<code>res:=*e</code> 就会把传递的 <code>Example</code> 对象拷贝一份，如果是 <code>res:=e</code> 的话，那么拷贝的就是对象的指针了.</p>
<p>而深拷贝和浅拷贝也可以这样理解，深拷贝就是拷贝整个对象，浅拷贝就是拷贝对象指针。</p>
<p>对于深度拷贝，<code>go</code>和其他语言还经常使用序列化后反序列化的形式进行拷贝:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> func deepCopy(dst, src interface&#123;&#125;) error &#123;</span><br><span class="line">     var buf bytes.Buffer</span><br><span class="line">     if err :&#x3D; gob.NewEncoder(&amp;buf).Encode(src); err !&#x3D; nil &#123;</span><br><span class="line">         return err</span><br><span class="line">     &#125;</span><br><span class="line">     return gob.NewDecoder(bytes.NewBuffer(buf.Bytes())).Decode(dst)</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>实际上<code>gob</code>包序列化的时候也是用到了 <code>reflect</code>包来实现拷贝的</p>
<p><strong>注意:</strong> golang完全是按值传递，所以如果深度拷贝的对象中包含有指针的话，那么深度拷贝后，这些指针也会相同，会导致部分数据共享，要注意这一点.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://richard-xiong.github.io/2020/10/14/golang%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Richard">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XingServer">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/14/golang%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">golang设计模式之建造者模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-13 20:43:21" itemprop="dateCreated datePublished" datetime="2020-10-13T20:43:21Z">2020-10-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-10-14 09:52:11" itemprop="dateModified" datetime="2020-10-14T09:52:11Z">2020-10-14</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><p>建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</p>
<p><strong>主要解决：</strong>主要解决在软件系统中，有时候面临着”一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。</p>
<p><strong>何时使用：</strong>一些基本部件不会变，而其组合经常变化的时候。</p>
<p><strong>如何解决：</strong>将变与不变分离开。</p>
<p><strong>关键代码：</strong>建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。</p>
<p><strong>应用实例：</strong> 1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的”套餐”。 2、JAVA 中的 StringBuilder。</p>
<p><strong>优点：</strong> 1、建造者独立，易扩展。 2、便于控制细节风险。</p>
<p><strong>缺点：</strong> 1、产品必须有共同点，范围有限制。 2、如内部变化复杂，会有很多的建造类。</p>
<p><strong>使用场景：</strong> 1、需要生成的对象具有复杂的内部结构。 2、需要生成的对象内部属性本身相互依赖。</p>
<p><strong>注意事项：</strong>与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们假设一个快餐店的商业案例，其中，一个典型的套餐可以是一个汉堡（Burger）和一杯冷饮（Cold drink）。汉堡（Burger）可以是素食汉堡（Veg Burger）或鸡肉汉堡（Chicken Burger），它们是包在纸盒中。冷饮（Cold drink）可以是可口可乐（coke）或百事可乐（pepsi），它们是装在瓶子中。</p>
<p>我们将创建一个表示食物条目（比如汉堡和冷饮）的 <em>Item</em> 接口和实现 <em>Item</em> 接口的实体类，以及一个表示食物包装的 <em>Packing</em> 接口和实现 <em>Packing</em> 接口的实体类，汉堡是包在纸盒中，冷饮是装在瓶子中。</p>
<p>然后我们创建一个 <em>Meal</em> 类，带有 <em>Item</em> 的 <em>ArrayList</em> 和一个通过结合 <em>Item</em> 来创建不同类型的 <em>Meal</em> 对象的 <em>MealBuilder</em>。<em>BuilderPatternDemo</em>，我们的演示类使用 <em>MealBuilder</em> 来创建一个 <em>Meal</em>。</p>
<p><img src="/images/golang%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/builder_pattern_uml_diagram.jpg" alt="建造者模式的 UML 图"></p>
<h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤 1"></a>步骤 1</h3><p>创建一个表示食物条目和食物包装的接口。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Item <span class="keyword">interface</span> &#123;</span><br><span class="line">   GetName() <span class="keyword">string</span></span><br><span class="line">   GetPacking() Packing</span><br><span class="line">   GetPrice() <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Packing <span class="keyword">interface</span> &#123;</span><br><span class="line">    GetPack() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤 2"></a>步骤 2</h3><p>创建实现 Packing 接口的实体类。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Wrapper <span class="keyword">struct</span> &#123;</span><br><span class="line">    Pack <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Wrapper)</span> <span class="title">GetPack</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Wrapper&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Bottle <span class="keyword">struct</span> &#123;</span><br><span class="line">    Pack <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Bottle)</span> <span class="title">GetPack</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Bottle&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤 3"></a>步骤 3</h3><p>创建实现 Item 接口的抽象类，该类提供了默认的功能。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Burger <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Burger)</span> <span class="title">GetPacking</span><span class="params">(item Item)</span> <span class="title">Packing</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item.GetPacking()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Burger)</span> <span class="title">GetPrice</span><span class="params">(item Item)</span><span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item.GetPrice()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Burger)</span> <span class="title">GetName</span><span class="params">(item Item)</span><span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item.GetName()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ColdDrink <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *ColdDrink)</span> <span class="title">GetPacking</span><span class="params">(item Item)</span> <span class="title">Packing</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item.GetPacking()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *ColdDrink)</span> <span class="title">GetPrice</span><span class="params">(item Item)</span><span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item.GetPrice()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *ColdDrink)</span> <span class="title">GetName</span><span class="params">(item Item)</span><span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item.GetName()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤 4"></a>步骤 4</h3><p>创建扩展了 Burger 和 ColdDrink 的实体类。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ChickenBurger <span class="keyword">struct</span> &#123;</span><br><span class="line">    Burger</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *ChickenBurger)</span> <span class="title">GetPrice</span><span class="params">()</span> <span class="title">float64</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">50.5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(this *ChickenBurger)</span> <span class="title">GetName</span><span class="params">()</span><span class="title">string</span></span>  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Chicken Burger&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *ChickenBurger)</span> <span class="title">GetPacking</span><span class="params">()</span> <span class="title">Packing</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">new</span>(Wrapper)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> VegBurger <span class="keyword">struct</span> &#123;</span><br><span class="line">    Burger</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *VegBurger)</span> <span class="title">GetPrice</span><span class="params">()</span> <span class="title">float64</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">25.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(this *VegBurger)</span> <span class="title">GetName</span><span class="params">()</span><span class="title">string</span></span>  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Veg Burger&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *VegBurger)</span> <span class="title">GetPacking</span><span class="params">()</span> <span class="title">Packing</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">new</span>(Wrapper)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Coke <span class="keyword">struct</span> &#123;</span><br><span class="line">    ColdDrink</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Coke)</span> <span class="title">GetPrice</span><span class="params">()</span> <span class="title">float64</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">30.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(this *Coke)</span> <span class="title">GetName</span><span class="params">()</span><span class="title">string</span></span>  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Coke&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Coke)</span> <span class="title">GetPacking</span><span class="params">()</span> <span class="title">Packing</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">new</span>(Bottle)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Pepsi <span class="keyword">struct</span> &#123;</span><br><span class="line">    ColdDrink</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Pepsi)</span> <span class="title">GetPrice</span><span class="params">()</span> <span class="title">float64</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">35.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(this *Pepsi)</span> <span class="title">GetName</span><span class="params">()</span><span class="title">string</span></span>  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Pepsi&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Pepsi)</span> <span class="title">GetPacking</span><span class="params">()</span> <span class="title">Packing</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">new</span>(Bottle)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="步骤-5"><a href="#步骤-5" class="headerlink" title="步骤 5"></a>步骤 5</h3><p>创建一个 Meal 类，带有上面定义的 Item 对象。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Meal <span class="keyword">struct</span> &#123;</span><br><span class="line">    Items []Item</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Meal)</span> <span class="title">AddItem</span><span class="params">(item Item)</span></span> &#123;</span><br><span class="line">    this.Items = <span class="built_in">append</span>(this.Items, item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Meal)</span> <span class="title">GetCost</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> cost <span class="keyword">float64</span></span><br><span class="line">    <span class="keyword">for</span> _, item := <span class="keyword">range</span> this.Items &#123;</span><br><span class="line">        cost += item.GetPrice()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cost</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Meal)</span> <span class="title">ShowItems</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, item := <span class="keyword">range</span> this.Items &#123;</span><br><span class="line">        fmt.Print(<span class="string">&quot;Item : &quot;</span> + item.GetName())</span><br><span class="line">        fmt.Print(<span class="string">&quot;, Packing : &quot;</span> + item.GetPacking().GetPack())</span><br><span class="line">        fmt.Println(<span class="string">&quot;, Price : &quot;</span> + fmt.Sprintf(<span class="string">&quot;%f&quot;</span>, item.GetPrice()))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="步骤-6"><a href="#步骤-6" class="headerlink" title="步骤 6"></a>步骤 6</h3><p>创建一个 MealBuilder 类，实际的 builder 类负责创建 Meal 对象。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetPrepareNonVegMea</span><span class="params">()</span> <span class="title">Meal</span></span> &#123;</span><br><span class="line">    meal := <span class="built_in">new</span>(Meal)</span><br><span class="line">    meal.AddItem(<span class="built_in">new</span>(ChickenBurger))</span><br><span class="line">    meal.AddItem(<span class="built_in">new</span>(Pepsi))</span><br><span class="line">    <span class="keyword">return</span> *meal</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetPrepareVegMeal</span><span class="params">()</span> <span class="title">Meal</span></span> &#123;</span><br><span class="line">    meal := <span class="built_in">new</span>(Meal)</span><br><span class="line">    meal.AddItem(<span class="built_in">new</span>(VegBurger))</span><br><span class="line">    meal.AddItem(<span class="built_in">new</span>(Coke))</span><br><span class="line">    <span class="keyword">return</span> *meal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="步骤-7"><a href="#步骤-7" class="headerlink" title="步骤 7"></a>步骤 7</h3><p>BuiderPatternDemo 使用 MealBuider 来演示建造者模式（Builder Pattern）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    nonVegMeal := meal.GetPrepareNonVegMea()</span><br><span class="line">    fmt.Println(<span class="string">&quot;\\n\\nNon-Veg Meal&quot;</span>)</span><br><span class="line">    nonVegMeal.ShowItems()</span><br><span class="line">    fmt.Println(<span class="string">&quot;Total Cost: &quot;</span> + fmt.Sprintf(<span class="string">&quot;%f&quot;</span>, nonVegMeal.GetCost()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    VegMeal := meal.GetPrepareVegMeal()</span><br><span class="line">    fmt.Println(<span class="string">&quot;\\n\\nVegMeal Meal&quot;</span>)</span><br><span class="line">    VegMeal.ShowItems()</span><br><span class="line">    fmt.Println(<span class="string">&quot;Total Cost: &quot;</span> + fmt.Sprintf(<span class="string">&quot;%f&quot;</span>, VegMeal.GetCost()))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="步骤-8"><a href="#步骤-8" class="headerlink" title="步骤 8"></a>步骤 8</h3><p>执行程序，输出结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\n\nNon-Veg Meal</span><br><span class="line">Item : Chicken Burger, Packing : Wrapper, Price : 50.500000</span><br><span class="line">Item : Pepsi, Packing : Bottle, Price : 35.000000</span><br><span class="line">Total Cost: 85.500000</span><br><span class="line">\n\nVegMeal Meal</span><br><span class="line">Item : Veg Burger, Packing : Wrapper, Price : 25.000000</span><br><span class="line">Item : Coke, Packing : Bottle, Price : 30.000000</span><br><span class="line">Total Cost: 55.000000</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://richard-xiong.github.io/2020/10/14/golang%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7-%E5%AE%9E%E7%8E%B0%E6%8A%BD%E8%B1%A1%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Richard">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XingServer">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/14/golang%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7-%E5%AE%9E%E7%8E%B0%E6%8A%BD%E8%B1%A1%E7%B1%BB/" class="post-title-link" itemprop="url">golang开发技巧-实现抽象类</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-10-13 17:43:58 / 修改时间：09:45:14" itemprop="dateCreated datePublished" datetime="2020-10-13T17:43:58Z">2020-10-13</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文介绍了一种通过 struct 和 interface 来在 golang 中实现抽象类的方式。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 Java 这种面向对象的语言中，抽象类和接口是我们经常会运用到的 2 种对抽象概念进行定义的机制。在 golang 中，没有类和继承的概念。golang 中有结构体（struct），和面向对象语言中的类相似。golang 中也有接口（interface），接口可以定义一组不含有具体实现的方法，其提供了一种方式来说明对象的行为。</p>
<p>然而，在某些情况下，我们需要使用抽象类继承，来帮助我们写出更优雅的代码。可是在 golang 中又没有抽象类的概念，本文将介绍一种通过 struct 和 interface 来在 golang 中实现抽象类的方法。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>首先，我们会用 Java 语言作为示例，来看看如何在面向对象语言中实现抽象类。接着换 golang 语言，通过 struct 和 interface 来实现抽象类，完成相同的功能。</p>
<h4 id="面向对象语言中抽象类的实现"><a href="#面向对象语言中抽象类的实现" class="headerlink" title="面向对象语言中抽象类的实现"></a>面向对象语言中抽象类的实现</h4><p>假设我们需要实现下面这样的几个类（使用 Java 为例）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Game</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name() + <span class="string">&quot; is awesome!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dota</span> <span class="keyword">extends</span> <span class="title">Game</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Dota&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LOL</span> <span class="keyword">extends</span> <span class="title">Game</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;LOL&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们定义了 Game 抽象类，在此类中定义了 <code>public abstract String name();</code> 一个抽象方法和 <code>public void play()</code> 这样一个公开方法。然后我们定义了 <code>Dota</code> 和 <code>LOL</code> 2个类去继承 <code>Game</code>，并各自实现了 <code>public String name()</code>。</p>
<p>接下来让我们看看如何在 golang 中实现抽象类。</p>
<h4 id="golang-中实现抽象类的方式"><a href="#golang-中实现抽象类的方式" class="headerlink" title="golang 中实现抽象类的方式"></a>golang 中实现抽象类的方式</h4><ul>
<li>定义 interface</li>
</ul>
<p>首先，我们需要将抽象方法定义在 interface 中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IGame <span class="keyword">interface</span> &#123;</span><br><span class="line">    Name() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>定义”父类”</li>
</ul>
<p>然后，我们需要使用 struct 实现公共方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Game <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Game)</span> <span class="title">play</span><span class="params">(game IGame)</span></span> &#123;</span><br><span class="line">    fmt.Printf(fmt.Sprintf(<span class="string">&quot;%s is awesome!&quot;</span>, game.Name()))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是重点，我们将 <code>game IGame</code> 传了进来。这样我们便可以调用”子类”的方法来获取名字。<strong>从而间接地实现了在公共方法中调用不同”子类”的实现的抽象方法。</strong></p>
<ul>
<li>定义”子类”</li>
</ul>
<p>接着，我们再定义”Dota”和”LOL”这 2 个 struct 即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Dota <span class="keyword">struct</span> &#123;</span><br><span class="line">    Game</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dota)</span> <span class="title">Name</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Dota&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LOL <span class="keyword">struct</span> &#123;</span><br><span class="line">    Game</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LOL)</span> <span class="title">Name</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;LOL&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>大功告成</li>
</ul>
<p>现在，在初始化”Dota”和”LOL”结构体后，便可以调用 <code>func (g *Game) play(game IGame)</code> 方法了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dota := &amp;Dota&#123;&#125;</span><br><span class="line">dota.play(dota)</span><br><span class="line"></span><br><span class="line">lol := &amp;LOL&#123;&#125;</span><br><span class="line">lol.play(lol)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">//Dota is awesome!</span></span><br><span class="line"><span class="comment">//LOL is awesome!</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文通过 struct 和 interface 的组合，提供了一种思路，间接实现了面向对象语言中的抽象类继承的模式。旨在提供一种思路，希望能帮助到需要的同学，欢迎讨论 :)</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://richard-xiong.github.io/2020/10/13/Golang%E7%96%91%E9%97%AE-Use-of-new-vs-var-in-Go/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Richard">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XingServer">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/13/Golang%E7%96%91%E9%97%AE-Use-of-new-vs-var-in-Go/" class="post-title-link" itemprop="url">Golang疑问 Use of new vs var in Go</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-10-12 20:58:57 / 修改时间：13:36:35" itemprop="dateCreated datePublished" datetime="2020-10-12T20:58:57Z">2020-10-12</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>209</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>Q： Is there any difference between:</strong></p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b bar</span><br><span class="line">foo(&amp;b)</span><br></pre></td></tr></table></figure>

<p>and</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b := <span class="built_in">new</span>(bar)</span><br><span class="line">foo(b)</span><br></pre></td></tr></table></figure>

<p>The use of new creates an allocation.</p>
<p><strong>A： No, there is no difference, as, contrary to C, Go explicitly states that you can give a pointer to a locally created variable.</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Richard"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Richard</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">110</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/RomanSeven7" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;RomanSeven7" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:nizhidaoiedeyisima@gmail.com" title="E-Mail → mailto:nizhidaoiedeyisima@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/p/1005056204086487" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;p&#x2F;1005056204086487" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Richard</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">264k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">4:01</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
